
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">github.com/silouanwright/gh-comment/cmd/add-review.go (78.2%)</option>

				<option value="file1">github.com/silouanwright/gh-comment/cmd/add.go (69.1%)</option>

				<option value="file2">github.com/silouanwright/gh-comment/cmd/batch.go (85.3%)</option>

				<option value="file3">github.com/silouanwright/gh-comment/cmd/client_helper.go (0.0%)</option>

				<option value="file4">github.com/silouanwright/gh-comment/cmd/edit.go (91.2%)</option>

				<option value="file5">github.com/silouanwright/gh-comment/cmd/helpers.go (91.7%)</option>

				<option value="file6">github.com/silouanwright/gh-comment/cmd/integration_testing.go (0.0%)</option>

				<option value="file7">github.com/silouanwright/gh-comment/cmd/list.go (78.9%)</option>

				<option value="file8">github.com/silouanwright/gh-comment/cmd/reply.go (56.8%)</option>

				<option value="file9">github.com/silouanwright/gh-comment/cmd/resolve.go (96.6%)</option>

				<option value="file10">github.com/silouanwright/gh-comment/cmd/review.go (94.6%)</option>

				<option value="file11">github.com/silouanwright/gh-comment/cmd/root.go (72.7%)</option>

				<option value="file12">github.com/silouanwright/gh-comment/cmd/submit-review.go (94.3%)</option>

				<option value="file13">github.com/silouanwright/gh-comment/cmd/suggestions.go (88.2%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">package cmd

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
)

var (
        reviewBody                string
        reviewComments            []string
        reviewEvent               string
        noExpandSuggestionsReview bool

        // Client for dependency injection (tests can override)
        addReviewClient github.GitHubAPI
)

var addReviewCmd = &amp;cobra.Command{
        Use:   "add-review [pr] [review-body]",
        Short: "Create a review with multiple comments in one shot",
        Long: `Create a complete review with multiple line-specific comments.

Since GitHub's API requires all review comments to be created together,
this command allows you to specify multiple comments for a single review.

The review can be submitted immediately or left as a pending draft.

Examples:
  # Create pending review with multiple comments
  gh comment add-review 123 "Overall looks good" \
    --comment "src/api.js:42:This handles rate limiting well" \
    --comment "src/auth.js:15:20:Consider using async/await here"

  # Create and submit review immediately
  gh comment add-review 123 "LGTM with minor suggestions" \
    --event APPROVE \
    --comment "src/api.js:42:Great error handling" \
    --comment "src/utils.js:10:Minor: consider extracting this constant"

  # Auto-detect PR from current branch
  gh comment add-review "Code review feedback" \
    --comment "README.md:25:Update installation instructions" \
    --comment "package.json:15:Bump version number"`,
        Args: cobra.RangeArgs(0, 2),
        RunE: runAddReview,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(addReviewCmd)
        addReviewCmd.Flags().StringVar(&amp;reviewBody, "body", "", "Review summary body (optional)")
        addReviewCmd.Flags().StringArrayVar(&amp;reviewComments, "comment", []string{}, "Add comment in format 'file:line:message' or 'file:start:end:message' (can be used multiple times)")
        addReviewCmd.Flags().StringVar(&amp;reviewEvent, "event", "", "Review event: APPROVE, REQUEST_CHANGES, or COMMENT (leave empty for pending review)")
        addReviewCmd.Flags().BoolVar(&amp;noExpandSuggestionsReview, "no-expand-suggestions", false, "Disable automatic expansion of [SUGGEST:] and &lt;&lt;&lt;SUGGEST&gt;&gt;&gt; syntax")
}</span>

func runAddReview(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if addReviewClient == nil </span><span class="cov0" title="0">{
                addReviewClient = &amp;github.RealClient{}
        }</span>

        <span class="cov8" title="1">var pr int
        var body string
        var err error

        // Parse arguments
        if len(args) == 2 </span><span class="cov8" title="1">{
                // PR number and body provided
                pr, err = strconv.Atoi(args[0])
                if err != nil </span><span class="cov8" title="1">{
                        return formatValidationError("PR number", args[0], "must be a valid integer")
                }</span>
                <span class="cov8" title="1">body = args[1]</span>
        } else<span class="cov8" title="1"> if len(args) == 1 </span><span class="cov8" title="1">{
                // Check if it's a PR number or review body
                if prNum, err := strconv.Atoi(args[0]); err == nil </span><span class="cov8" title="1">{
                        // It's a PR number
                        pr = prNum
                }</span> else<span class="cov8" title="1"> {
                        // It's a review body, auto-detect PR
                        pr, err = getCurrentPR()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">body = args[0]</span>
                }
        } else<span class="cov8" title="1"> {
                // Auto-detect PR
                pr, err = getCurrentPR()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Use --body flag if provided, otherwise use positional arg
        <span class="cov8" title="1">if reviewBody != "" </span><span class="cov8" title="1">{
                body = reviewBody
        }</span>

        // Validate that we have at least one comment
        <span class="cov8" title="1">if len(reviewComments) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("must provide at least one --comment")
        }</span>

        // Get repository
        <span class="cov8" title="1">repository, err := getCurrentRepo()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if verbose </span><span class="cov0" title="0">{
                fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("PR: %d\n", pr)
                fmt.Printf("Review body: %s\n", body)
                fmt.Printf("Review event: %s\n", reviewEvent)
                fmt.Printf("Comments: %d\n", len(reviewComments))
                fmt.Println()
        }</span>

        <span class="cov8" title="1">if dryRun </span><span class="cov0" title="0">{
                fmt.Printf("Would create review on PR #%d:\n", pr)
                fmt.Printf("Body: %s\n", body)
                fmt.Printf("Event: %s\n", reviewEvent)
                fmt.Printf("Comments:\n")
                for i, comment := range reviewComments </span><span class="cov0" title="0">{
                        fmt.Printf("  %d. %s\n", i+1, comment)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Parse owner/repo
        <span class="cov8" title="1">parts := strings.Split(repository, "/")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid repository format: %s (expected owner/repo)", repository)
        }</span>
        <span class="cov8" title="1">owner, repoName := parts[0], parts[1]

        // Create the review with all comments using the client
        return createReviewWithComments(addReviewClient, owner, repoName, pr, body, reviewEvent, reviewComments)</span>
}

func createReviewWithComments(client github.GitHubAPI, owner, repo string, pr int, body, event string, commentSpecs []string) error <span class="cov8" title="1">{
        // Get PR details for commit SHA
        prDetails, err := client.GetPRDetails(owner, repo, pr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get PR details: %w", err)
        }</span>

        // Extract commit SHA from PR details
        <span class="cov8" title="1">var commitSHA string
        if head, ok := prDetails["head"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                if sha, ok := head["sha"].(string); ok </span><span class="cov8" title="1">{
                        commitSHA = sha
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("could not extract commit SHA from PR details")
                }</span>
        } else<span class="cov0" title="0"> {
                return fmt.Errorf("could not extract head information from PR details")
        }</span>

        // Parse comment specifications
        <span class="cov8" title="1">var reviewComments []github.ReviewCommentInput
        for _, spec := range commentSpecs </span><span class="cov8" title="1">{
                comment, err := parseCommentSpec(spec, commitSHA)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid comment spec '%s': %w", spec, err)
                }</span>
                <span class="cov8" title="1">reviewComments = append(reviewComments, comment)</span>
        }

        // Create review input
        <span class="cov8" title="1">reviewInput := github.ReviewInput{
                Body:     body,
                Comments: reviewComments,
        }

        // Set event if specified (otherwise creates pending review)
        if event != "" </span><span class="cov8" title="1">{
                reviewInput.Event = event
        }</span> else<span class="cov8" title="1"> {
                reviewInput.Event = "COMMENT" // Default for pending review
        }</span>

        // Create the review
        <span class="cov8" title="1">err = client.CreateReview(owner, repo, pr, reviewInput)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create review: %w", err)
        }</span>

        // Display success message
        <span class="cov8" title="1">if event == "" </span><span class="cov8" title="1">{
                fmt.Printf("✅ Created pending review with %d comments on PR #%d\n", len(reviewComments), pr)
                fmt.Printf("💡 Use 'gh pr review --approve/--request-changes/--comment' to submit the review\n")
        }</span> else<span class="cov8" title="1"> {
                fmt.Printf("✅ Created and submitted %s review with %d comments on PR #%d\n", event, len(reviewComments), pr)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func parseCommentSpec(spec, commitSHA string) (github.ReviewCommentInput, error) <span class="cov8" title="1">{
        // Format: "file:line:message" or "file:start:end:message"
        parts := strings.Split(spec, ":")
        if len(parts) &lt; 3 </span><span class="cov8" title="1">{
                return github.ReviewCommentInput{}, fmt.Errorf("format should be 'file:line:message' or 'file:start:end:message'")
        }</span>

        <span class="cov8" title="1">file := parts[0]

        // Try to parse as range first (file:start:end:message...)
        if len(parts) &gt;= 4 </span><span class="cov8" title="1">{
                startLine, err := strconv.Atoi(parts[1])
                if err == nil </span><span class="cov8" title="1">{
                        endLine, err := strconv.Atoi(parts[2])
                        if err == nil </span><span class="cov8" title="1">{
                                // This is a valid range format
                                if startLine &gt; endLine </span><span class="cov8" title="1">{
                                        return github.ReviewCommentInput{}, fmt.Errorf("start line (%d) cannot be greater than end line (%d)", startLine, endLine)
                                }</span>

                                // Join remaining parts as the message (in case message contains colons)
                                <span class="cov8" title="1">body := strings.Join(parts[3:], ":")
                                if !noExpandSuggestionsReview </span><span class="cov8" title="1">{
                                        body = expandSuggestions(body)
                                }</span>

                                <span class="cov8" title="1">return github.ReviewCommentInput{
                                        Path:      file,
                                        Line:      endLine,
                                        StartLine: startLine,
                                        Side:      "RIGHT",
                                        Body:      body,
                                        CommitID:  commitSHA,
                                }, nil</span>
                        }
                }
        }

        // Parse as single line: file:line:message...
        <span class="cov8" title="1">line, err := strconv.Atoi(parts[1])
        if err != nil </span><span class="cov8" title="1">{
                return github.ReviewCommentInput{}, fmt.Errorf("invalid line number: %s", parts[1])
        }</span>

        // Join remaining parts as the message (in case message contains colons)
        <span class="cov8" title="1">body := strings.Join(parts[2:], ":")
        if !noExpandSuggestionsReview </span><span class="cov8" title="1">{
                body = expandSuggestions(body)
        }</span>

        <span class="cov8" title="1">return github.ReviewCommentInput{
                Path:     file,
                Line:     line,
                Body:     body,
                CommitID: commitSHA,
        }, nil</span>
}
</pre>

		<pre class="file" id="file1" style="display: none">package cmd

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/MakeNowJust/heredoc"
        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
)

var (
        messages            []string
        noExpandSuggestions bool

        // Client for dependency injection (tests can override)
        addClient github.GitHubAPI
)

var addCmd = &amp;cobra.Command{
        Use:   "add [pr] &lt;file&gt; &lt;line&gt; &lt;comment&gt;",
        Short: "Add a comment to a pull request",
        Long: heredoc.Doc(`
                Add a comment to a pull request. Comments can be general PR comments
                or line-specific review comments.

                For line-specific comments, use file and line arguments to target
                specific code locations. Supports both single-line and range comments.

                The comment message supports GitHub markdown formatting and can include
                code suggestions using the [SUGGEST: code] syntax.
        `),
        Example: heredoc.Doc(`
                # Strategic line-specific commenting
                $ gh comment add 123 src/api.js 42 "This rate limiting logic needs edge case handling for concurrent requests"
                $ gh comment add 123 auth.go 15:25 "Consider OAuth2 PKCE flow for mobile clients - current implementation has security gaps"

                # Security-focused reviews
                $ gh comment add 123 database.py 156 "This query is vulnerable to SQL injection - use parameterized queries"
                $ gh comment add 123 crypto.js 67 "[SUGGEST: use crypto.randomBytes(32) instead of Math.random()]"

                # Performance optimization suggestions
                $ gh comment add 123 performance.js 89:95 "Extract this expensive calculation to a cached service - it's called on every render"
                $ gh comment add 123 db/migrations.sql 23 "Add index on user_id column for faster lookups: CREATE INDEX idx_user_id ON orders(user_id)"

                # Architecture and design feedback
                $ gh comment add 123 service.go 134:150 "This business logic should be extracted to a domain service layer"
                $ gh comment add 123 component.tsx 45 "Consider using React.memo() to prevent unnecessary re-renders"

                # Multi-line strategic feedback
                $ gh comment add 123 error-handler.js 78 -m "**Critical:** This error handling is incomplete" -m "Missing: rate limit errors, network timeouts, auth failures"

                # Auto-detect PR from current branch
                $ gh comment add src/validation.js 156 "Add input sanitization before database operations"
        `),
        Args: cobra.RangeArgs(2, 4),
        RunE: runAdd,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(addCmd)
        addCmd.Flags().StringArrayVarP(&amp;messages, "message", "m", []string{}, "Add message (can be used multiple times for multi-line comments)")
        addCmd.Flags().BoolVar(&amp;noExpandSuggestions, "no-expand-suggestions", false, "Disable automatic expansion of [SUGGEST:] and &lt;&lt;&lt;SUGGEST&gt;&gt;&gt; syntax")
}</span>

func runAdd(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if addClient == nil </span><span class="cov0" title="0">{
                client, err := createGitHubClient()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to initialize GitHub client: %w", err)
                }</span>
                <span class="cov0" title="0">addClient = client</span>
        }

        <span class="cov8" title="1">var pr int
        var file, lineSpec, comment string
        var err error

        // Parse arguments - handle both 3 and 4 arg cases, plus --message flags
        if len(args) == 4 </span><span class="cov8" title="1">{
                // PR number provided
                pr, err = strconv.Atoi(args[0])
                if err != nil </span><span class="cov8" title="1">{
                        return formatValidationError("PR number", args[0], "must be a valid integer")
                }</span>
                <span class="cov8" title="1">file = args[1]
                lineSpec = args[2]
                comment = args[3]</span>
        } else<span class="cov8" title="1"> if len(args) == 3 </span><span class="cov8" title="1">{
                // PR number not provided, auto-detect
                pr, err = getCurrentPR()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">file = args[0]
                lineSpec = args[1]
                comment = args[2]</span>
        } else<span class="cov8" title="1"> if len(args) == 2 &amp;&amp; len(messages) &gt; 0 </span><span class="cov8" title="1">{
                // Using --message flags instead of positional comment
                pr, err = getCurrentPR()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">file = args[0]
                lineSpec = args[1]
                comment = strings.Join(messages, "\n")</span>
        } else<span class="cov8" title="1"> if len(args) == 3 &amp;&amp; len(messages) &gt; 0 </span><span class="cov0" title="0">{
                // PR provided + --message flags
                pr, err = strconv.Atoi(args[0])
                if err != nil </span><span class="cov0" title="0">{
                        return formatValidationError("PR number", args[0], "must be a valid integer")
                }</span>
                <span class="cov0" title="0">file = args[1]
                lineSpec = args[2]
                comment = strings.Join(messages, "\n")</span>
        } else<span class="cov8" title="1"> {
                return fmt.Errorf("invalid arguments. Use: gh comment add [pr] &lt;file&gt; &lt;line&gt; &lt;comment&gt; OR gh comment add [pr] &lt;file&gt; &lt;line&gt; --message \"line1\" --message \"line2\"")
        }</span>

        // Get repository
        <span class="cov8" title="1">repository, err := getCurrentRepo()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Parse line specification
        <span class="cov8" title="1">startLine, endLine, err := parseLineSpec(lineSpec)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Expand suggestion syntax to GitHub markdown (unless disabled)
        <span class="cov8" title="1">var transformedComment string
        if noExpandSuggestions </span><span class="cov0" title="0">{
                transformedComment = comment
        }</span> else<span class="cov8" title="1"> {
                transformedComment = expandSuggestions(comment)
        }</span>

        <span class="cov8" title="1">if verbose </span><span class="cov0" title="0">{
                fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("PR: %d\n", pr)
                fmt.Printf("File: %s\n", file)
                fmt.Printf("Line(s): %d", startLine)
                if endLine != startLine </span><span class="cov0" title="0">{
                        fmt.Printf("-%d", endLine)
                }</span>
                <span class="cov0" title="0">fmt.Printf("\nOriginal comment: %s\n", comment)
                fmt.Printf("Transformed comment: %s\n", transformedComment)</span>
        }

        <span class="cov8" title="1">if dryRun </span><span class="cov0" title="0">{
                fmt.Printf("Would add comment to %s:%d", file, startLine)
                if endLine != startLine </span><span class="cov0" title="0">{
                        fmt.Printf("-%d", endLine)
                }</span>
                <span class="cov0" title="0">fmt.Printf(" in PR #%d:\n%s\n", pr, transformedComment)
                return nil</span>
        }

        // Parse owner/repo
        <span class="cov8" title="1">parts := strings.Split(repository, "/")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid repository format: %s (expected owner/repo)", repository)
        }</span>
        <span class="cov8" title="1">owner, repoName := parts[0], parts[1]

        // Create review comment input
        reviewComment := github.ReviewCommentInput{
                Body: transformedComment,
                Path: file,
                Line: endLine, // GitHub API uses the end line for ranges
        }

        // If it's a range, add start_line
        if startLine != endLine </span><span class="cov8" title="1">{
                reviewComment.StartLine = startLine
                reviewComment.Side = "RIGHT"
        }</span>

        // We need the commit SHA - get PR details first
        <span class="cov8" title="1">prDetails, err := addClient.GetPRDetails(owner, repoName, pr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get PR details: %w", err)
        }</span>

        // Extract commit SHA from PR details
        <span class="cov8" title="1">if head, ok := prDetails["head"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                if sha, ok := head["sha"].(string); ok </span><span class="cov8" title="1">{
                        reviewComment.CommitID = sha
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("could not extract commit SHA from PR details")
                }</span>
        } else<span class="cov0" title="0"> {
                return fmt.Errorf("could not extract head information from PR details")
        }</span>

        // Add the comment via GitHub API
        <span class="cov8" title="1">err = addClient.AddReviewComment(owner, repoName, pr, reviewComment)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add comment: %w", err)
        }</span>

        // Success message
        <span class="cov8" title="1">fmt.Printf("✓ Added comment to %s:%d", file, startLine)
        if endLine != startLine </span><span class="cov8" title="1">{
                fmt.Printf("-%d", endLine)
        }</span>
        <span class="cov8" title="1">fmt.Printf(" in PR #%d\n", pr)

        return nil</span>
}

func parseLineSpec(lineSpec string) (int, int, error) <span class="cov8" title="1">{
        if strings.Contains(lineSpec, ":") </span><span class="cov8" title="1">{
                // Range specification
                parts := strings.Split(lineSpec, ":")
                if len(parts) != 2 </span><span class="cov8" title="1">{
                        return 0, 0, fmt.Errorf("invalid line range format: %s (use start:end)", lineSpec)
                }</span>

                <span class="cov8" title="1">start, err := strconv.Atoi(parts[0])
                if err != nil </span><span class="cov8" title="1">{
                        return 0, 0, fmt.Errorf("invalid start line: %s", parts[0])
                }</span>

                <span class="cov8" title="1">end, err := strconv.Atoi(parts[1])
                if err != nil </span><span class="cov8" title="1">{
                        return 0, 0, fmt.Errorf("invalid end line: %s", parts[1])
                }</span>

                <span class="cov8" title="1">if start &lt;= 0 || end &lt;= 0 </span><span class="cov0" title="0">{
                        return 0, 0, fmt.Errorf("line numbers must be positive")
                }</span>

                <span class="cov8" title="1">if start &gt; end </span><span class="cov8" title="1">{
                        return 0, 0, fmt.Errorf("start line (%d) cannot be greater than end line (%d)", start, end)
                }</span>

                <span class="cov8" title="1">return start, end, nil</span>
        } else<span class="cov8" title="1"> {
                // Single line
                line, err := strconv.Atoi(lineSpec)
                if err != nil </span><span class="cov8" title="1">{
                        return 0, 0, fmt.Errorf("invalid line number: %s", lineSpec)
                }</span>
                <span class="cov8" title="1">if line &lt;= 0 </span><span class="cov0" title="0">{
                        return 0, 0, fmt.Errorf("line numbers must be positive")
                }</span>
                <span class="cov8" title="1">return line, line, nil</span>
        }
}


</pre>

		<pre class="file" id="file2" style="display: none">package cmd

import (
        "fmt"
        "io/ioutil"
        "strconv"
        "strings"

        "github.com/MakeNowJust/heredoc"
        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"
)

var (
        // Client for dependency injection (tests can override)
        batchClient github.GitHubAPI
)

// BatchConfig represents the structure of a batch comment configuration file
type BatchConfig struct {
        PR       int             `yaml:"pr,omitempty"`
        Repo     string          `yaml:"repo,omitempty"`
        Review   *ReviewConfig   `yaml:"review,omitempty"`
        Comments []CommentConfig `yaml:"comments,omitempty"`
}

// ReviewConfig represents review-level configuration
type ReviewConfig struct {
        Body  string `yaml:"body,omitempty"`
        Event string `yaml:"event,omitempty"` // APPROVE, REQUEST_CHANGES, COMMENT
}

// CommentConfig represents individual comment configuration
type CommentConfig struct {
        File    string `yaml:"file"`
        Line    int    `yaml:"line,omitempty"`
        Range   string `yaml:"range,omitempty"` // e.g., "10-15"
        Message string `yaml:"message"`
        Type    string `yaml:"type,omitempty"` // "review" or "issue", defaults to "review"
}

var batchCmd = &amp;cobra.Command{
        Use:   "batch &lt;config-file&gt;",
        Short: "Process multiple comments from a YAML configuration file",
        Long: heredoc.Doc(`
                Process multiple comments, reactions, and reviews from a YAML configuration file.

                This is ideal for bulk operations, automated workflows, or complex review
                scenarios. The config file can specify mixed comment types, create reviews
                with multiple comments, and set up entire review workflows.
        `),
        Example: heredoc.Doc(`
                # Process comments from config
                $ gh comment batch review-config.yaml

                # Validate config without executing
                $ gh comment batch review-config.yaml --dry-run

                # Process with custom PR number
                $ gh comment batch review-config.yaml --pr 456
        `),
        Args: cobra.ExactArgs(2),
        RunE: runBatch,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(batchCmd)
}</span>

func runBatch(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if batchClient == nil </span><span class="cov0" title="0">{
                batchClient = &amp;github.RealClient{}
        }</span>

        // Parse PR number
        <span class="cov8" title="1">prArg := args[0]
        pr, err := strconv.Atoi(prArg)
        if err != nil </span><span class="cov8" title="1">{
                return formatValidationError("PR number", prArg, "must be a valid integer")
        }</span>

        // Read and parse configuration file
        <span class="cov8" title="1">configFile := args[1]
        config, err := readBatchConfig(configFile)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to read config file: %w", err)
        }</span>

        // Override PR and repo from config if specified
        <span class="cov8" title="1">if config.PR != 0 </span><span class="cov8" title="1">{
                pr = config.PR
        }</span>

        <span class="cov8" title="1">repository := repo
        if config.Repo != "" </span><span class="cov8" title="1">{
                repository = config.Repo
        }</span>

        // Get repository and PR context if not specified
        <span class="cov8" title="1">if repository == "" </span><span class="cov0" title="0">{
                repository, pr, err = getPRContext()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Parse owner/repo
        <span class="cov8" title="1">parts := strings.Split(repository, "/")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid repository format: %s (expected owner/repo)", repository)
        }</span>
        <span class="cov8" title="1">owner, repoName := parts[0], parts[1]

        if verbose </span><span class="cov8" title="1">{
                fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("PR: %d\n", pr)
                fmt.Printf("Config file: %s\n", configFile)
                fmt.Printf("Comments to process: %d\n", len(config.Comments))
                if config.Review != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Review event: %s\n", config.Review.Event)
                }</span>
                <span class="cov8" title="1">fmt.Println()</span>
        }

        <span class="cov8" title="1">if dryRun </span><span class="cov8" title="1">{
                fmt.Printf("Would process %d comments from %s on PR #%d:\n", len(config.Comments), configFile, pr)
                for i, comment := range config.Comments </span><span class="cov8" title="1">{
                        fmt.Printf("  %d. %s:%s - %s\n", i+1, comment.File, formatLineOrRange(comment), truncateMessage(comment.Message, 50))
                }</span>
                <span class="cov8" title="1">if config.Review != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Would create review with event: %s\n", config.Review.Event)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        // Process comments
        <span class="cov8" title="1">return processBatchComments(batchClient, owner, repoName, pr, config)</span>
}

func readBatchConfig(configFile string) (*BatchConfig, error) <span class="cov8" title="1">{
        // Read file
        data, err := ioutil.ReadFile(configFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read file %s: %w", configFile, err)
        }</span>

        // Parse YAML
        <span class="cov8" title="1">var config BatchConfig
        err = yaml.Unmarshal(data, &amp;config)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse YAML: %w", err)
        }</span>

        // Validate configuration
        <span class="cov8" title="1">if len(config.Comments) == 0 &amp;&amp; config.Review == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("configuration must contain either comments or review")
        }</span>

        // Validate comments
        <span class="cov8" title="1">for i, comment := range config.Comments </span><span class="cov8" title="1">{
                if comment.File == "" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("comment %d: file is required", i+1)
                }</span>
                <span class="cov8" title="1">if comment.Message == "" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("comment %d: message is required", i+1)
                }</span>
                <span class="cov8" title="1">if comment.Line == 0 &amp;&amp; comment.Range == "" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("comment %d: either line or range is required", i+1)
                }</span>
                <span class="cov8" title="1">if comment.Line != 0 &amp;&amp; comment.Range != "" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("comment %d: cannot specify both line and range", i+1)
                }</span>
                <span class="cov8" title="1">if comment.Type != "" &amp;&amp; comment.Type != "review" &amp;&amp; comment.Type != "issue" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("comment %d: type must be 'review' or 'issue'", i+1)
                }</span>
        }

        // Validate review if present
        <span class="cov8" title="1">if config.Review != nil </span><span class="cov8" title="1">{
                if config.Review.Event != "" </span><span class="cov8" title="1">{
                        validEvents := []string{"APPROVE", "REQUEST_CHANGES", "COMMENT"}
                        isValid := false
                        for _, validEvent := range validEvents </span><span class="cov8" title="1">{
                                if config.Review.Event == validEvent </span><span class="cov8" title="1">{
                                        isValid = true
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if !isValid </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("review event must be one of: %s", strings.Join(validEvents, ", "))
                        }</span>
                }
        }

        <span class="cov8" title="1">return &amp;config, nil</span>
}

func processBatchComments(client github.GitHubAPI, owner, repo string, pr int, config *BatchConfig) error <span class="cov8" title="1">{
        // If we have a review configuration, create the review with comments
        if config.Review != nil </span><span class="cov8" title="1">{
                return processAsReview(client, owner, repo, pr, config)
        }</span>

        // Otherwise, process comments individually
        <span class="cov8" title="1">return processIndividualComments(client, owner, repo, pr, config.Comments)</span>
}

func processAsReview(client github.GitHubAPI, owner, repo string, pr int, config *BatchConfig) error <span class="cov8" title="1">{
        // Convert comments to review comment format
        var reviewComments []github.ReviewCommentInput

        for _, comment := range config.Comments </span><span class="cov8" title="1">{
                if comment.Type == "issue" </span><span class="cov8" title="1">{
                        // Issue comments can't be part of a review, process separately
                        if verbose </span><span class="cov0" title="0">{
                                fmt.Printf("Processing issue comment separately: %s:%s\n", comment.File, formatLineOrRange(comment))
                        }</span>
                        <span class="cov8" title="1">_, err := client.CreateIssueComment(owner, repo, pr, comment.Message)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create issue comment: %w", err)
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                // Get commit SHA for the PR
                <span class="cov8" title="1">prDetails, err := client.GetPRDetails(owner, repo, pr)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get PR details: %w", err)
                }</span>

                <span class="cov8" title="1">headSHA, ok := prDetails["head"].(map[string]interface{})["sha"].(string)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get commit SHA from PR details")
                }</span>

                // Create review comment input
                <span class="cov8" title="1">reviewComment := github.ReviewCommentInput{
                        Body:     expandSuggestions(comment.Message),
                        Path:     comment.File,
                        CommitID: headSHA,
                }

                // Set line or range
                if comment.Range != "" </span><span class="cov0" title="0">{
                        startLine, endLine, err := parseRange(comment.Range)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid range %s: %w", comment.Range, err)
                        }</span>
                        <span class="cov0" title="0">reviewComment.StartLine = startLine
                        reviewComment.Line = endLine</span>
                } else<span class="cov8" title="1"> {
                        reviewComment.Line = comment.Line
                }</span>

                <span class="cov8" title="1">reviewComments = append(reviewComments, reviewComment)</span>
        }

        // Create the review
        <span class="cov8" title="1">reviewInput := github.ReviewInput{
                Body:     config.Review.Body,
                Event:    config.Review.Event,
                Comments: reviewComments,
        }

        if reviewInput.Event == "" </span><span class="cov0" title="0">{
                reviewInput.Event = "COMMENT"
        }</span>

        <span class="cov8" title="1">err := client.CreateReview(owner, repo, pr, reviewInput)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create review: %w", err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("✅ Successfully created review with %d comments\n", len(reviewComments))
        return nil</span>
}

func processIndividualComments(client github.GitHubAPI, owner, repo string, pr int, comments []CommentConfig) error <span class="cov8" title="1">{
        successCount := 0

        for i, comment := range comments </span><span class="cov8" title="1">{
                if verbose </span><span class="cov8" title="1">{
                        fmt.Printf("Processing comment %d/%d: %s:%s\n", i+1, len(comments), comment.File, formatLineOrRange(comment))
                }</span>

                <span class="cov8" title="1">commentType := comment.Type
                if commentType == "" </span><span class="cov8" title="1">{
                        commentType = "review" // Default to review comments
                }</span>

                <span class="cov8" title="1">var err error
                if commentType == "issue" </span><span class="cov0" title="0">{
                        _, err = client.CreateIssueComment(owner, repo, pr, expandSuggestions(comment.Message))
                }</span> else<span class="cov8" title="1"> {
                        // For review comments, we need the commit SHA
                        prDetails, err := client.GetPRDetails(owner, repo, pr)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get PR details: %w", err)
                        }</span>

                        <span class="cov8" title="1">headSHA, ok := prDetails["head"].(map[string]interface{})["sha"].(string)
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get commit SHA from PR details")
                        }</span>

                        <span class="cov8" title="1">reviewComment := github.ReviewCommentInput{
                                Body:     expandSuggestions(comment.Message),
                                Path:     comment.File,
                                CommitID: headSHA,
                        }

                        // Set line or range
                        if comment.Range != "" </span><span class="cov8" title="1">{
                                startLine, endLine, err := parseRange(comment.Range)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("invalid range %s: %w", comment.Range, err)
                                }</span>
                                <span class="cov8" title="1">reviewComment.StartLine = startLine
                                reviewComment.Line = endLine</span>
                        } else<span class="cov8" title="1"> {
                                reviewComment.Line = comment.Line
                        }</span>

                        <span class="cov8" title="1">err = client.AddReviewComment(owner, repo, pr, reviewComment)</span>
                }

                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create comment %d: %w", i+1, err)
                }</span>

                <span class="cov8" title="1">successCount++</span>
        }

        <span class="cov8" title="1">fmt.Printf("✅ Successfully created %d comments\n", successCount)
        return nil</span>
}

// Helper functions
func formatLineOrRange(comment CommentConfig) string <span class="cov8" title="1">{
        if comment.Range != "" </span><span class="cov8" title="1">{
                return comment.Range
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%d", comment.Line)</span>
}

func truncateMessage(message string, maxLen int) string <span class="cov8" title="1">{
        if len(message) &lt;= maxLen </span><span class="cov8" title="1">{
                return message
        }</span>
        <span class="cov8" title="1">return message[:maxLen-3] + "..."</span>
}

func parseRange(rangeStr string) (startLine, endLine int, err error) <span class="cov8" title="1">{
        parts := strings.Split(rangeStr, "-")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return 0, 0, fmt.Errorf("range must be in format 'start-end'")
        }</span>

        <span class="cov8" title="1">startLine, err = strconv.Atoi(strings.TrimSpace(parts[0]))
        if err != nil </span><span class="cov8" title="1">{
                return 0, 0, fmt.Errorf("invalid start line: %w", err)
        }</span>

        <span class="cov8" title="1">endLine, err = strconv.Atoi(strings.TrimSpace(parts[1]))
        if err != nil </span><span class="cov8" title="1">{
                return 0, 0, fmt.Errorf("invalid end line: %w", err)
        }</span>

        <span class="cov8" title="1">if startLine &lt;= 0 || endLine &lt;= 0 </span><span class="cov8" title="1">{
                return 0, 0, fmt.Errorf("line numbers must be positive")
        }</span>

        <span class="cov8" title="1">if startLine &gt; endLine </span><span class="cov8" title="1">{
                return 0, 0, fmt.Errorf("start line must be &lt;= end line")
        }</span>

        <span class="cov8" title="1">return startLine, endLine, nil</span>
}</pre>

		<pre class="file" id="file3" style="display: none">package cmd

import (
        "os"

        "github.com/silouanwright/gh-comment/internal/github"
)

// createGitHubClient creates the appropriate GitHub client based on environment
func createGitHubClient() (github.GitHubAPI, error) <span class="cov0" title="0">{
        // Check if we're in a test environment with mock server
        if mockURL := os.Getenv("MOCK_SERVER_URL"); mockURL != "" </span><span class="cov0" title="0">{
                return github.NewTestClient()
        }</span>

        // Use real client for production
        <span class="cov0" title="0">return github.NewRealClient()</span>
}</pre>

		<pre class="file" id="file4" style="display: none">package cmd

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
)

var (
        editMessages []string

        // Client for dependency injection (tests can override)
        editClient github.GitHubAPI
)

var editCmd = &amp;cobra.Command{
        Use:   "edit &lt;comment-id&gt; [message]",
        Short: "Edit an existing comment on a PR",
        Long: `Edit an existing comment on a pull request.

You can edit with a new message using either positional argument or --message flags.
Use the comment ID from the URL shown in 'gh comment list' output.

Common use cases:
- Fix typos in comments: "Fixed typo in previous comment"
- Add more context: "Adding more details about the implementation"
- Refine AI-generated comments: "Updating comment based on new analysis"
- Correct mistakes: "Correcting the suggested approach"

Examples:
  # Edit with new message
  gh comment edit 2246362251 "Updated comment with better explanation"

  # Edit with multi-line content using --message flags (AI-friendly)
  gh comment edit 2246362251 --message "First paragraph" --message "Second paragraph"

  # Edit with multi-line content (shell native)
  gh comment edit 2246362251 "Line 1
Line 2
Line 3"`,
        Args: cobra.RangeArgs(1, 2),
        RunE: runEdit,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(editCmd)
        editCmd.Flags().StringArrayVarP(&amp;editMessages, "message", "m", []string{}, "Edit message (can be used multiple times for multi-line comments)")
}</span>

func runEdit(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if editClient == nil </span><span class="cov0" title="0">{
                editClient = &amp;github.RealClient{}
        }</span>

        // Parse comment ID
        <span class="cov8" title="1">commentID, err := strconv.Atoi(args[0])
        if err != nil </span><span class="cov8" title="1">{
                return formatValidationError("comment ID", args[0], "must be a valid integer")
        }</span>

        <span class="cov8" title="1">var message string

        // Handle message from positional arg or --message flags
        if len(args) == 2 </span><span class="cov8" title="1">{
                message = args[1]
        }</span> else<span class="cov8" title="1"> if len(editMessages) &gt; 0 </span><span class="cov8" title="1">{
                message = strings.Join(editMessages, "\n")
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("must provide either a message argument or --message flags")
        }</span>

        // Get repository
        <span class="cov8" title="1">repository, err := getCurrentRepo()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Parse owner/repo
        <span class="cov8" title="1">parts := strings.Split(repository, "/")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid repository format: %s (expected owner/repo)", repository)
        }</span>
        <span class="cov8" title="1">owner, repoName := parts[0], parts[1]

        if verbose </span><span class="cov8" title="1">{
                fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("Comment ID: %d\n", commentID)
                fmt.Printf("New message: %s\n", message)
                fmt.Println()
        }</span>

        <span class="cov8" title="1">if dryRun </span><span class="cov8" title="1">{
                fmt.Printf("Would edit comment #%d:\n", commentID)
                fmt.Printf("New message: %s\n", message)
                return nil
        }</span>

        // Edit the comment using the client
        <span class="cov8" title="1">err = editClient.EditComment(owner, repoName, commentID, message)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to edit comment: %w", err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("✅ Edited comment #%d\n", commentID)
        return nil</span>
}

</pre>

		<pre class="file" id="file5" style="display: none">package cmd

import (
        "fmt"
)

// Constants for API limits and defaults
const (
        MaxGraphQLResults = 100
        MaxCommentLength  = 65536
        DefaultPageSize   = 30
)

// getPRContext gets the repository and PR number, handling both flag and auto-detection
func getPRContext() (repo string, pr int, err error) <span class="cov8" title="1">{
        repo, err = getCurrentRepo()
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, fmt.Errorf("failed to get repository: %w", err)
        }</span>

        <span class="cov8" title="1">if prNumber &gt; 0 </span><span class="cov8" title="1">{
                pr = prNumber
        }</span> else<span class="cov8" title="1"> {
                pr, err = getCurrentPR()
                if err != nil </span><span class="cov8" title="1">{
                        return "", 0, fmt.Errorf("failed to detect PR number: %w (try specifying --pr)", err)
                }</span>
        }

        <span class="cov8" title="1">return repo, pr, nil</span>
}

// formatAPIError creates consistent error messages for API failures
func formatAPIError(operation, endpoint string, err error) error <span class="cov8" title="1">{
        return fmt.Errorf("GitHub API error during %s: %w", operation, err)
}</span>

// formatValidationError creates consistent error messages for validation failures
func formatValidationError(field, value, expected string) error <span class="cov8" title="1">{
        return fmt.Errorf("invalid %s '%s': %s", field, value, expected)
}</span>

// formatNotFoundError creates consistent error messages for missing resources
func formatNotFoundError(resource string, identifier interface{}) error <span class="cov8" title="1">{
        return fmt.Errorf("%s not found: %v", resource, identifier)
}</span>
</pre>

		<pre class="file" id="file6" style="display: none">package cmd

import (
        "encoding/json"
        "fmt"
        "net/http"
        "net/http/httptest"
        "strconv"
        "strings"
        "sync"
        "time"
)

// MockGitHubServer represents a mock GitHub API server for integration testing
type MockGitHubServer struct {
        server   *httptest.Server
        mu       sync.RWMutex
        comments map[string][]MockComment
        reviews  map[string][]MockReview
        users    map[string]MockUser
}

// MockComment represents a GitHub comment for testing
type MockComment struct {
        ID        int       `json:"id"`
        Body      string    `json:"body"`
        User      MockUser  `json:"user"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
        HTMLURL   string    `json:"html_url"`
        Path      string    `json:"path,omitempty"`
        Line      int       `json:"line,omitempty"`
        StartLine int       `json:"start_line,omitempty"`
}

// MockReview represents a GitHub review for testing
type MockReview struct {
        ID       int          `json:"id"`
        Body     string       `json:"body"`
        User     MockUser     `json:"user"`
        State    string       `json:"state"`
        Comments []MockComment `json:"comments,omitempty"`
}

// MockUser represents a GitHub user for testing
type MockUser struct {
        Login string `json:"login"`
        ID    int    `json:"id"`
}

// MockPRDetails represents PR details for testing
type MockPRDetails struct {
        Number int `json:"number"`
        Head   struct {
                SHA string `json:"sha"`
        } `json:"head"`
}

// NewMockGitHubServer creates a new mock GitHub API server
func NewMockGitHubServer() *MockGitHubServer <span class="cov0" title="0">{
        s := &amp;MockGitHubServer{
                comments: make(map[string][]MockComment),
                reviews:  make(map[string][]MockReview),
                users: map[string]MockUser{
                        "test-user":    {Login: "test-user", ID: 1},
                        "reviewer":     {Login: "reviewer", ID: 2},
                        "senior-dev":   {Login: "senior-dev", ID: 3},
                        "security-bot": {Login: "security-bot", ID: 4},
                },
        }

        mux := http.NewServeMux()

        // GET /repos/{owner}/{repo}/pulls/{pr}/comments - List review comments
        mux.HandleFunc("/repos/", s.handleRepoRequests)

        s.server = httptest.NewServer(mux)
        return s
}</span>

// URL returns the mock server URL
func (s *MockGitHubServer) URL() string <span class="cov0" title="0">{
        return s.server.URL
}</span>

// Close shuts down the mock server
func (s *MockGitHubServer) Close() <span class="cov0" title="0">{
        s.server.Close()
}</span>

// AddComment adds a mock comment to the server state
func (s *MockGitHubServer) AddComment(repo string, pr int, comment MockComment) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        key := fmt.Sprintf("%s/%d", repo, pr)
        if comment.ID == 0 </span><span class="cov0" title="0">{
                comment.ID = len(s.comments[key]) + 1000
        }</span>
        <span class="cov0" title="0">if comment.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                comment.CreatedAt = time.Now()
        }</span>
        <span class="cov0" title="0">if comment.UpdatedAt.IsZero() </span><span class="cov0" title="0">{
                comment.UpdatedAt = comment.CreatedAt
        }</span>
        <span class="cov0" title="0">if comment.HTMLURL == "" </span><span class="cov0" title="0">{
                comment.HTMLURL = fmt.Sprintf("%s/repos/%s/pulls/%d#issuecomment-%d", s.URL(), repo, pr, comment.ID)
        }</span>

        <span class="cov0" title="0">s.comments[key] = append(s.comments[key], comment)</span>
}

// GetComments returns comments for a PR
func (s *MockGitHubServer) GetComments(repo string, pr int) []MockComment <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        key := fmt.Sprintf("%s/%d", repo, pr)
        return s.comments[key]
}</span>

// SetupTestScenario sets up predefined test data
func (s *MockGitHubServer) SetupTestScenario(scenario string) <span class="cov0" title="0">{
        switch scenario </span>{
        case "basic":<span class="cov0" title="0">
                s.AddComment("test-owner/test-repo", 123, MockComment{
                        Body: "This looks good to me!",
                        User: s.users["test-user"],
                })
                s.AddComment("test-owner/test-repo", 123, MockComment{
                        Body: "Please fix the typo in line 42",
                        User: s.users["reviewer"],
                        Path: "src/main.go",
                        Line: 42,
                })</span>
        case "security-review":<span class="cov0" title="0">
                s.AddComment("test-owner/test-repo", 456, MockComment{
                        Body: "Security scan detected potential SQL injection vulnerability",
                        User: s.users["security-bot"],
                        Path: "database.py",
                        Line: 156,
                })
                s.AddComment("test-owner/test-repo", 456, MockComment{
                        Body: "Use crypto.randomBytes(32) instead of Math.random() for token generation",
                        User: s.users["senior-dev"],
                        Path: "auth.go",
                        Line: 67,
                })</span>
        }
}

// handleRepoRequests handles all repository-related API requests
func (s *MockGitHubServer) handleRepoRequests(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        path := strings.TrimPrefix(r.URL.Path, "/repos/")
        parts := strings.Split(path, "/")

        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                http.Error(w, "Invalid repository path", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">owner, repo := parts[0], parts[1]
        repoKey := fmt.Sprintf("%s/%s", owner, repo)

        // Handle different API endpoints
        if len(parts) &gt;= 4 &amp;&amp; parts[2] == "pulls" </span><span class="cov0" title="0">{
                prStr := parts[3]
                pr, err := strconv.Atoi(prStr)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Invalid PR number", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">if len(parts) == 4 </span><span class="cov0" title="0">{
                        // GET /repos/{owner}/{repo}/pulls/{pr} - Get PR details
                        if r.Method == "GET" </span><span class="cov0" title="0">{
                                s.handleGetPRDetails(w, r, repoKey, pr)
                                return
                        }</span>
                }

                <span class="cov0" title="0">if len(parts) &gt;= 5 &amp;&amp; parts[4] == "comments" </span><span class="cov0" title="0">{
                        switch r.Method </span>{
                        case "GET":<span class="cov0" title="0">
                                // GET /repos/{owner}/{repo}/pulls/{pr}/comments - List comments
                                s.handleListComments(w, r, repoKey, pr)</span>
                        case "POST":<span class="cov0" title="0">
                                // POST /repos/{owner}/{repo}/pulls/{pr}/comments - Create comment
                                s.handleCreateComment(w, r, repoKey, pr)</span>
                        }
                }

                <span class="cov0" title="0">if len(parts) &gt;= 5 &amp;&amp; parts[4] == "reviews" </span><span class="cov0" title="0">{
                        if r.Method == "POST" </span><span class="cov0" title="0">{
                                // POST /repos/{owner}/{repo}/pulls/{pr}/reviews - Create review
                                s.handleCreateReview(w, r, repoKey, pr)
                        }</span>
                }
        }

        <span class="cov0" title="0">if len(parts) &gt;= 4 &amp;&amp; parts[2] == "issues" </span><span class="cov0" title="0">{
                prStr := parts[3]
                pr, err := strconv.Atoi(prStr)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Invalid issue number", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">if len(parts) &gt;= 5 &amp;&amp; parts[4] == "comments" </span><span class="cov0" title="0">{
                        switch r.Method </span>{
                        case "GET":<span class="cov0" title="0">
                                // GET /repos/{owner}/{repo}/issues/{pr}/comments - List issue comments
                                s.handleListIssueComments(w, r, repoKey, pr)</span>
                        case "POST":<span class="cov0" title="0">
                                // POST /repos/{owner}/{repo}/issues/{pr}/comments - Create issue comment
                                s.handleCreateIssueComment(w, r, repoKey, pr)</span>
                        }
                }
        }
}

// handleGetPRDetails handles GET /repos/{owner}/{repo}/pulls/{pr}
func (s *MockGitHubServer) handleGetPRDetails(w http.ResponseWriter, r *http.Request, repo string, pr int) <span class="cov0" title="0">{
        details := MockPRDetails{
                Number: pr,
        }
        details.Head.SHA = "abc123def456" // Mock commit SHA

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(details)
}</span>

// handleListComments handles GET /repos/{owner}/{repo}/pulls/{pr}/comments
func (s *MockGitHubServer) handleListComments(w http.ResponseWriter, r *http.Request, repo string, pr int) <span class="cov0" title="0">{
        comments := s.GetComments(repo, pr)

        // Filter for review comments only (have path/line)
        var reviewComments []MockComment
        for _, comment := range comments </span><span class="cov0" title="0">{
                if comment.Path != "" </span><span class="cov0" title="0">{
                        reviewComments = append(reviewComments, comment)
                }</span>
        }

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(reviewComments)</span>
}

// handleListIssueComments handles GET /repos/{owner}/{repo}/issues/{pr}/comments
func (s *MockGitHubServer) handleListIssueComments(w http.ResponseWriter, r *http.Request, repo string, pr int) <span class="cov0" title="0">{
        comments := s.GetComments(repo, pr)

        // Filter for issue comments only (no path/line)
        var issueComments []MockComment
        for _, comment := range comments </span><span class="cov0" title="0">{
                if comment.Path == "" </span><span class="cov0" title="0">{
                        issueComments = append(issueComments, comment)
                }</span>
        }

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(issueComments)</span>
}

// handleCreateComment handles POST /repos/{owner}/{repo}/pulls/{pr}/comments
func (s *MockGitHubServer) handleCreateComment(w http.ResponseWriter, r *http.Request, repo string, pr int) <span class="cov0" title="0">{
        var comment MockComment
        if err := json.NewDecoder(r.Body).Decode(&amp;comment); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        // Set defaults
        <span class="cov0" title="0">comment.User = s.users["test-user"] // Default test user
        s.AddComment(repo, pr, comment)

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(comment)</span>
}

// handleCreateIssueComment handles POST /repos/{owner}/{repo}/issues/{pr}/comments
func (s *MockGitHubServer) handleCreateIssueComment(w http.ResponseWriter, r *http.Request, repo string, pr int) <span class="cov0" title="0">{
        var comment MockComment
        if err := json.NewDecoder(r.Body).Decode(&amp;comment); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        // Issue comments don't have path/line
        <span class="cov0" title="0">comment.Path = ""
        comment.Line = 0
        comment.StartLine = 0
        comment.User = s.users["test-user"]

        s.AddComment(repo, pr, comment)

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(comment)</span>
}

// handleCreateReview handles POST /repos/{owner}/{repo}/pulls/{pr}/reviews
func (s *MockGitHubServer) handleCreateReview(w http.ResponseWriter, r *http.Request, repo string, pr int) <span class="cov0" title="0">{
        var review MockReview
        if err := json.NewDecoder(r.Body).Decode(&amp;review); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">s.mu.Lock()
        defer s.mu.Unlock()

        key := fmt.Sprintf("%s/%d", repo, pr)
        review.ID = len(s.reviews[key]) + 2000
        review.User = s.users["test-user"]

        // Add review comments to the comment list
        for _, comment := range review.Comments </span><span class="cov0" title="0">{
                comment.User = s.users["test-user"]
                s.AddComment(repo, pr, comment)
        }</span>

        <span class="cov0" title="0">s.reviews[key] = append(s.reviews[key], review)

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(review)</span>
}</pre>

		<pre class="file" id="file7" style="display: none">package cmd

import (
        "fmt"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/MakeNowJust/heredoc"
        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
)

var (
        showResolved   bool
        onlyUnresolved bool
        author         string
        quiet          bool
        hideAuthors    bool

        // Advanced filtering flags
        status       string
        since        string
        until        string
        resolved     string
        listType     string

        // Parsed time values
        sinceTime *time.Time
        untilTime *time.Time

        // Client for dependency injection (tests can override)
        listClient github.GitHubAPI
)

var listCmd = &amp;cobra.Command{
        Use:   "list [pr]",
        Short: "List comments with advanced filtering and formatting options",
        Long: heredoc.Doc(`
                List all comments on a pull request with powerful filtering capabilities.

                Supports both general PR comments and line-specific review comments.
                Comments can be filtered by author, date range, resolution status, and more.

                Output can be formatted as tables, JSON, or plain text with color coding.
                Perfect for code review workflows, comment analysis, and automation.
        `),
        Example: heredoc.Doc(`
                # Review team analysis and metrics
                $ gh comment list 123 --author "senior-dev*" --status open --since "1 week ago"
                $ gh comment list 123 --type review --author "*@company.com" --since "deployment-date"

                # Security audit and compliance tracking
                $ gh comment list 123 --author "security-team*" --since "2024-01-01" --type review
                $ gh comment list 123 --author "bot*" --since "3 days ago" --quiet

                # Code review workflow optimization
                $ gh comment list 123 --status open --since "sprint-start" --author "lead*"
                $ gh comment list 123 --until "release-date" --type issue --status resolved

                # Team communication patterns
                $ gh comment list 123 --author "qa*" --since "last-deployment" --type review
                $ gh comment list 123 --author "*@contractor.com" --status open --since "1 month ago"

                # Blocker identification and resolution tracking
                $ gh comment list 123 --author "architect*" --status open --type review
                $ gh comment list 123 --since "critical-bug-report" --author "oncall*" --status resolved

                # Performance review analysis
                $ gh comment list 123 --author "performance-team" --since "load-test-date" --type review
                $ gh comment list 123 --status open --author "*perf*" --since "1 week ago"

                # Export for further analysis
                $ gh comment list 123 --author "all-reviewers*" --format json --since "quarter-start"
                $ gh comment list 123 --quiet --type review --status open | review-metrics.sh
        `),
        Args: cobra.MaximumNArgs(1),
        RunE: runList,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(listCmd)

        // Legacy flags (kept for backward compatibility)
        listCmd.Flags().BoolVar(&amp;showResolved, "resolved", false, "Include resolved comments (legacy, use --status instead)")
        listCmd.Flags().BoolVar(&amp;onlyUnresolved, "unresolved", false, "Show only unresolved comments (legacy, use --status instead)")

        // Enhanced filtering flags
        listCmd.Flags().StringVar(&amp;author, "author", "", "Filter comments by author (supports wildcards: 'user*', '*@company.com')")
        listCmd.Flags().StringVar(&amp;status, "status", "all", "Filter by comment status: open, resolved, all")
        listCmd.Flags().StringVar(&amp;since, "since", "", "Show comments created after date (e.g., '2024-01-01', '1 week ago', '3 days ago')")
        listCmd.Flags().StringVar(&amp;until, "until", "", "Show comments created before date (e.g., '2024-12-31', '1 day ago')")
        listCmd.Flags().StringVar(&amp;resolved, "resolved-status", "", "Filter by resolution status: pending, resolved, dismissed")
        listCmd.Flags().StringVar(&amp;listType, "type", "all", "Filter by comment type: issue, review, all")

        // Display options
        listCmd.Flags().BoolVarP(&amp;quiet, "quiet", "q", false, "Minimal output without URLs and IDs (default shows full context for AI)")
        listCmd.Flags().BoolVar(&amp;hideAuthors, "hide-authors", false, "Hide author names for privacy")
}</span>

func runList(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if listClient == nil </span><span class="cov0" title="0">{
                client, err := createGitHubClient()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to initialize GitHub client: %w", err)
                }</span>
                <span class="cov0" title="0">listClient = client</span>
        }

        // Validate and parse filtering flags
        <span class="cov8" title="1">if err := validateAndParseFilters(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var pr int
        var err error

        // Parse PR argument
        if len(args) == 1 </span><span class="cov8" title="1">{
                pr, err = strconv.Atoi(args[0])
                if err != nil </span><span class="cov8" title="1">{
                        return formatValidationError("PR number", args[0], "must be a valid integer")
                }</span>
        } else<span class="cov0" title="0"> {
                // Auto-detect PR
                pr, err = getCurrentPR()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Get repository
        <span class="cov8" title="1">repository, err := getCurrentRepo()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if verbose </span><span class="cov0" title="0">{
                fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("PR: %d\n", pr)
                fmt.Printf("Show resolved: %v\n", showResolved)
                fmt.Printf("Only unresolved: %v\n", onlyUnresolved)
                fmt.Printf("Quiet mode: %v\n", quiet)
                fmt.Printf("Hide authors: %v\n", hideAuthors)
                if author != "" </span><span class="cov0" title="0">{
                        fmt.Printf("Filter by author: %s\n", author)
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        // Fetch comments
        <span class="cov8" title="1">comments, err := fetchAllComments(listClient, repository, pr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Filter comments
        <span class="cov8" title="1">filteredComments := filterComments(comments)

        // Display comments
        displayComments(filteredComments, pr)

        return nil</span>
}

type Comment struct {
        ID        int       `json:"id"`
        Author    string    `json:"author"`
        Body      string    `json:"body"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
        HTMLURL   string    `json:"html_url"`

        // For line-specific comments
        Path      string `json:"path,omitempty"`
        Line      int    `json:"line,omitempty"`
        StartLine int    `json:"start_line,omitempty"`
        DiffHunk  string `json:"diff_hunk,omitempty"`

        // Comment type
        Type string `json:"type"` // "issue" or "review"

        // Resolution status (for review comments)
        State string `json:"state,omitempty"` // "pending", "submitted", etc.
}

func fetchAllComments(client github.GitHubAPI, repo string, pr int) ([]Comment, error) <span class="cov8" title="1">{
        // Parse owner/repo
        parts := strings.Split(repo, "/")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid repository format: %s (expected owner/repo)", repo)
        }</span>
        <span class="cov8" title="1">owner, repoName := parts[0], parts[1]

        var allComments []Comment

        // Fetch general PR comments (issue comments)
        issueComments, err := client.ListIssueComments(owner, repoName, pr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch issue comments: %w", err)
        }</span>

        // Convert issue comments
        <span class="cov8" title="1">for _, comment := range issueComments </span><span class="cov8" title="1">{
                allComments = append(allComments, Comment{
                        ID:        comment.ID,
                        Author:    comment.User.Login,
                        Body:      comment.Body,
                        CreatedAt: comment.CreatedAt,
                        UpdatedAt: comment.UpdatedAt,
                        HTMLURL:   "", // TODO: Add HTMLURL to github.Comment
                        Type:      "issue",
                })
        }</span>

        // Fetch review comments (line-specific)
        <span class="cov8" title="1">reviewComments, err := client.ListReviewComments(owner, repoName, pr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch review comments: %w", err)
        }</span>

        // Convert review comments
        <span class="cov8" title="1">for _, comment := range reviewComments </span><span class="cov8" title="1">{
                allComments = append(allComments, Comment{
                        ID:        comment.ID,
                        Author:    comment.User.Login,
                        Body:      comment.Body,
                        CreatedAt: comment.CreatedAt,
                        UpdatedAt: comment.UpdatedAt,
                        HTMLURL:   "", // TODO: Add HTMLURL to github.Comment
                        Path:      comment.Path,
                        Line:      comment.Line,
                        Type:      "review",
                })
        }</span>

        <span class="cov8" title="1">return allComments, nil</span>
}

func validateAndParseFilters() error <span class="cov8" title="1">{
        // Validate status flag
        validStatuses := []string{"all", "open", "resolved"}
        if status != "" &amp;&amp; !containsString(validStatuses, status) </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid status '%s'. Must be one of: %s", status, strings.Join(validStatuses, ", "))
        }</span>

        // Validate comment type flag
        <span class="cov8" title="1">validTypes := []string{"all", "issue", "review"}
        if listType != "" &amp;&amp; !containsString(validTypes, listType) </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid type '%s'. Must be one of: %s", listType, strings.Join(validTypes, ", "))
        }</span>

        // Parse since date
        <span class="cov8" title="1">if since != "" </span><span class="cov8" title="1">{
                parsedTime, err := parseFlexibleDate(since)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid since date '%s': %w", since, err)
                }</span>
                <span class="cov8" title="1">sinceTime = &amp;parsedTime</span>
        }

        // Parse until date
        <span class="cov8" title="1">if until != "" </span><span class="cov8" title="1">{
                parsedTime, err := parseFlexibleDate(until)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid until date '%s': %w", until, err)
                }</span>
                <span class="cov8" title="1">untilTime = &amp;parsedTime</span>
        }

        // Validate date range
        <span class="cov8" title="1">if sinceTime != nil &amp;&amp; untilTime != nil &amp;&amp; sinceTime.After(*untilTime) </span><span class="cov8" title="1">{
                return fmt.Errorf("since date (%s) cannot be after until date (%s)", since, until)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func parseFlexibleDate(dateStr string) (time.Time, error) <span class="cov8" title="1">{
        dateStr = strings.TrimSpace(dateStr)
        now := time.Now()

        // Try relative time parsing first
        if strings.HasSuffix(dateStr, " ago") </span><span class="cov8" title="1">{
                return parseRelativeTime(dateStr, now)
        }</span>

        // Try common date formats
        <span class="cov8" title="1">formats := []string{
                "2006-01-02",           // YYYY-MM-DD
                "2006-01-02 15:04:05",  // YYYY-MM-DD HH:MM:SS
                "01/02/2006",           // MM/DD/YYYY
                "Jan 2, 2006",          // Month DD, YYYY
                "January 2, 2006",      // Full month name
                "2006-01-02T15:04:05Z", // ISO 8601
        }

        for _, format := range formats </span><span class="cov8" title="1">{
                if parsed, err := time.Parse(format, dateStr); err == nil </span><span class="cov8" title="1">{
                        return parsed, nil
                }</span>
        }

        <span class="cov8" title="1">return time.Time{}, fmt.Errorf("unrecognized date format. Supported formats: YYYY-MM-DD, 'N days ago', 'N weeks ago', etc.")</span>
}

func parseRelativeTime(relativeStr string, now time.Time) (time.Time, error) <span class="cov8" title="1">{
        // Remove " ago" suffix
        timeStr := strings.TrimSuffix(relativeStr, " ago")
        parts := strings.Fields(timeStr)

        if len(parts) != 2 </span><span class="cov8" title="1">{
                return time.Time{}, fmt.Errorf("invalid relative time format")
        }</span>

        <span class="cov8" title="1">amount, err := strconv.Atoi(parts[0])
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("invalid time amount: %s", parts[0])
        }</span>

        <span class="cov8" title="1">unit := strings.ToLower(parts[1])
        // Handle both singular and plural forms
        if strings.HasSuffix(unit, "s") </span><span class="cov8" title="1">{
                unit = unit[:len(unit)-1]
        }</span>

        <span class="cov8" title="1">switch unit </span>{
        case "second":<span class="cov0" title="0">
                return now.Add(-time.Duration(amount) * time.Second), nil</span>
        case "minute":<span class="cov0" title="0">
                return now.Add(-time.Duration(amount) * time.Minute), nil</span>
        case "hour":<span class="cov8" title="1">
                return now.Add(-time.Duration(amount) * time.Hour), nil</span>
        case "day":<span class="cov8" title="1">
                return now.AddDate(0, 0, -amount), nil</span>
        case "week":<span class="cov8" title="1">
                return now.AddDate(0, 0, -amount*7), nil</span>
        case "month":<span class="cov8" title="1">
                return now.AddDate(0, -amount, 0), nil</span>
        case "year":<span class="cov8" title="1">
                return now.AddDate(-amount, 0, 0), nil</span>
        default:<span class="cov8" title="1">
                return time.Time{}, fmt.Errorf("unsupported time unit: %s", unit)</span>
        }
}

func filterComments(comments []Comment) []Comment <span class="cov8" title="1">{
        var filtered []Comment

        for _, comment := range comments </span><span class="cov8" title="1">{
                // Filter by author (supports wildcards)
                if author != "" &amp;&amp; !matchesAuthorFilter(comment.Author, author) </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Filter by comment type
                <span class="cov8" title="1">if listType != "all" &amp;&amp; comment.Type != listType </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Filter by status (legacy support)
                <span class="cov8" title="1">if showResolved &amp;&amp; onlyUnresolved </span>{<span class="cov0" title="0">
                        // Conflicting flags - show all
                }</span> else<span class="cov8" title="1"> if onlyUnresolved </span><span class="cov0" title="0">{
                        // Only show unresolved comments (this is a placeholder - actual resolution status would come from API)
                        // For now, we'll consider all comments as "open" since we don't have resolution data
                        if status == "resolved" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                } else<span class="cov8" title="1"> if !showResolved </span><span class="cov8" title="1">{
                        // Default behavior - don't show resolved comments
                        if status == "resolved" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                // Filter by new status flag
                <span class="cov8" title="1">if status != "all" </span><span class="cov0" title="0">{
                        // This is a placeholder for actual resolution status filtering
                        // In a real implementation, you'd check comment.ResolvedAt or similar
                        // For now, we'll treat all comments as "open"
                        if status == "resolved" </span><span class="cov0" title="0">{
                                continue</span> // Skip since we don't have resolution data yet
                        }
                }

                // Filter by date range
                <span class="cov8" title="1">if sinceTime != nil &amp;&amp; comment.CreatedAt.Before(*sinceTime) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if untilTime != nil &amp;&amp; comment.CreatedAt.After(*untilTime) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">filtered = append(filtered, comment)</span>
        }

        <span class="cov8" title="1">return filtered</span>
}

func matchesAuthorFilter(author, filter string) bool <span class="cov8" title="1">{
        // Exact match
        if author == filter </span><span class="cov8" title="1">{
                return true
        }</span>

        // Wildcard matching
        <span class="cov8" title="1">if strings.Contains(filter, "*") </span><span class="cov8" title="1">{
                // Convert wildcard pattern to regex
                pattern := strings.ReplaceAll(regexp.QuoteMeta(filter), `\*`, `.*`)
                pattern = "^" + pattern + "$"

                if matched, err := regexp.MatchString(pattern, author); err == nil &amp;&amp; matched </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        // Case-insensitive partial match
        <span class="cov8" title="1">return strings.Contains(strings.ToLower(author), strings.ToLower(filter))</span>
}

func containsString(slice []string, item string) bool <span class="cov8" title="1">{
        for _, s := range slice </span><span class="cov8" title="1">{
                if s == item </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func displayComments(comments []Comment, pr int) <span class="cov8" title="1">{
        if len(comments) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("No comments found on PR #%d\n", pr)
                return
        }</span>

        <span class="cov8" title="1">fmt.Printf("📝 Comments on PR #%d (%d total)\n\n", pr, len(comments))

        // Group comments by type
        var issueComments, reviewComments, lineComments []Comment
        for _, comment := range comments </span><span class="cov8" title="1">{

                if comment.Type == "issue" </span><span class="cov8" title="1">{
                        issueComments = append(issueComments, comment)
                }</span> else<span class="cov8" title="1"> if comment.Type == "review" </span><span class="cov8" title="1">{
                        reviewComments = append(reviewComments, comment)
                }</span> else<span class="cov0" title="0"> {
                        lineComments = append(lineComments, comment)
                }</span>
        }

        // Display general PR comments
        <span class="cov8" title="1">if len(issueComments) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf("💬 General PR Comments (%d)\n", len(issueComments))
                fmt.Println(strings.Repeat("─", 50))
                for i, comment := range issueComments </span><span class="cov8" title="1">{
                        displayComment(comment, i+1)
                }</span>
                <span class="cov8" title="1">fmt.Println()</span>
        }

        // Display review-level comments (parent comments that group line-specific ones)
        <span class="cov8" title="1">if len(reviewComments) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf("📋 Review Comments (%d)\n", len(reviewComments))
                fmt.Println(strings.Repeat("─", 50))
                for i, comment := range reviewComments </span><span class="cov8" title="1">{
                        displayComment(comment, i+1)
                }</span>
                <span class="cov8" title="1">fmt.Println()</span>
        }

        // Display line-specific comments
        <span class="cov8" title="1">if len(lineComments) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("📍 Line-Specific Comments (%d)\n", len(lineComments))
                fmt.Println(strings.Repeat("─", 50))
                for i, comment := range lineComments </span><span class="cov0" title="0">{
                        displayComment(comment, i+1)
                }</span>
        }
}

func displayComment(comment Comment, index int) <span class="cov8" title="1">{
        // Header with author and timestamp
        timeAgo := formatTimeAgo(comment.CreatedAt)
        if hideAuthors </span><span class="cov0" title="0">{
                fmt.Printf("[%d] 👤 [hidden] • %s", index, timeAgo)
        }</span> else<span class="cov8" title="1"> {
                fmt.Printf("[%d] 👤 %s • %s", index, comment.Author, timeAgo)
        }</span>

        // Show review state for review-level comments
        <span class="cov8" title="1">if comment.Type == "review" &amp;&amp; comment.State != "" </span><span class="cov0" title="0">{
                stateEmoji := "📝"
                switch comment.State </span>{
                case "approved":<span class="cov0" title="0">
                        stateEmoji = "✅"</span>
                case "changes_requested":<span class="cov0" title="0">
                        stateEmoji = "🔴"</span>
                case "commented":<span class="cov0" title="0">
                        stateEmoji = "💬"</span>
                }
                <span class="cov0" title="0">fmt.Printf(" %s %s", stateEmoji, comment.State)</span>
        }
        <span class="cov8" title="1">fmt.Println()

        // File and line info for line-specific comments
        if comment.Path != "" </span><span class="cov8" title="1">{
                lineInfo := fmt.Sprintf("L%d", comment.Line)
                if comment.StartLine &gt; 0 &amp;&amp; comment.StartLine != comment.Line </span><span class="cov0" title="0">{
                        lineInfo = fmt.Sprintf("L%d-L%d", comment.StartLine, comment.Line)
                }</span>
                <span class="cov8" title="1">fmt.Printf("📁 %s:%s\n", comment.Path, lineInfo)

                // Show the actual diff context if available
                if comment.DiffHunk != "" </span><span class="cov0" title="0">{
                        fmt.Printf("📝 Code Context:\n")
                        displayDiffHunk(comment.DiffHunk)
                }</span>
        }

        // Comment body (truncate if too long)
        <span class="cov8" title="1">body := strings.TrimSpace(comment.Body)
        if len(body) &gt; 200 </span><span class="cov0" title="0">{
                body = body[:197] + "..."
        }</span>

        // Indent the comment body
        <span class="cov8" title="1">lines := strings.Split(body, "\n")
        for _, line := range lines </span><span class="cov8" title="1">{
                fmt.Printf("   %s\n", line)
        }</span>

        // Show URLs by default (AI-friendly), hide only in quiet mode
        <span class="cov8" title="1">if !quiet </span><span class="cov8" title="1">{
                fmt.Printf("   🔗 %s\n", comment.HTMLURL)
        }</span>

        <span class="cov8" title="1">fmt.Println()</span>
}

func formatTimeAgo(t time.Time) string <span class="cov8" title="1">{
        now := time.Now()
        diff := now.Sub(t)

        if diff &lt; time.Minute </span><span class="cov8" title="1">{
                return "just now"
        }</span> else<span class="cov8" title="1"> if diff &lt; time.Hour </span><span class="cov8" title="1">{
                minutes := int(diff.Minutes())
                if minutes == 1 </span><span class="cov8" title="1">{
                        return "1 minute ago"
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%d minutes ago", minutes)</span>
        } else<span class="cov8" title="1"> if diff &lt; 24*time.Hour </span><span class="cov8" title="1">{
                hours := int(diff.Hours())
                if hours == 1 </span><span class="cov8" title="1">{
                        return "1 hour ago"
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%d hours ago", hours)</span>
        } else<span class="cov8" title="1"> {
                days := int(diff.Hours() / 24)
                if days == 1 </span><span class="cov8" title="1">{
                        return "1 day ago"
                }</span> else<span class="cov8" title="1"> if days &lt; 7 </span><span class="cov8" title="1">{
                        return fmt.Sprintf("%d days ago", days)
                }</span> else<span class="cov8" title="1"> {
                        return t.Format("Jan 2, 2006")
                }</span>
        }
}

func displayDiffHunk(diffHunk string) <span class="cov8" title="1">{
        // Split diff hunk into lines
        lines := strings.Split(strings.TrimSpace(diffHunk), "\n")

        for _, line := range lines </span><span class="cov8" title="1">{
                if line == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Color code the diff lines
                <span class="cov8" title="1">if strings.HasPrefix(line, "@@") </span><span class="cov8" title="1">{
                        // Diff header - show line numbers
                        fmt.Printf("   🔹 %s\n", line)
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(line, "+") </span><span class="cov8" title="1">{
                        // Added line - green
                        fmt.Printf("   ➕ %s\n", line)
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(line, "-") </span><span class="cov8" title="1">{
                        // Removed line - red
                        fmt.Printf("   ➖ %s\n", line)
                }</span> else<span class="cov8" title="1"> {
                        // Context line - neutral
                        fmt.Printf("     %s\n", line)
                }</span>
        }
        <span class="cov8" title="1">fmt.Println()</span>
}

</pre>

		<pre class="file" id="file8" style="display: none">package cmd

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/MakeNowJust/heredoc"
        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
)

var (
        reaction                 string
        removeReaction           string
        resolveConversation      bool
        noExpandSuggestionsReply bool
        commentType              string

        // Client for dependency injection (tests can override)
        replyClient github.GitHubAPI
)

var replyCmd = &amp;cobra.Command{
        Use:   "reply &lt;comment-id&gt; [message]",
        Short: "Reply to a comment or add reactions",
        Long: heredoc.Doc(`
                Reply to an existing comment with a message or reaction.

                Supports threaded replies to create discussion threads, and emoji
                reactions for quick feedback. Reactions can be added or removed.

                Comment IDs can be found in the output of 'gh comment list'.
        `),
        Example: heredoc.Doc(`
                # Reply with a message
                $ gh comment reply 123456 "Good point, I'll fix that"

                # Add a thumbs up reaction
                $ gh comment reply 123456 --reaction +1

                # Remove a reaction
                $ gh comment reply 123456 --remove-reaction +1

                # Reply and resolve conversation
                $ gh comment reply 123456 "Fixed in latest commit" --resolve

                # Add multiple reactions
                $ gh comment reply 123456 --reaction +1 --reaction heart

                # Reply with code suggestion
                $ gh comment reply 123456 "[SUGGEST: if (condition) { return early; }]"
        `),
        Args: cobra.RangeArgs(1, 2),
        RunE: runReply,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(replyCmd)

        replyCmd.Flags().StringVar(&amp;reaction, "reaction", "", "Add reaction: +1, -1, laugh, confused, heart, hooray, rocket, eyes")
        replyCmd.Flags().StringVar(&amp;removeReaction, "remove-reaction", "", "Remove reaction: +1, -1, laugh, confused, heart, hooray, rocket, eyes")
        replyCmd.Flags().BoolVar(&amp;resolveConversation, "resolve", false, "Resolve the conversation after replying")
        replyCmd.Flags().BoolVar(&amp;noExpandSuggestionsReply, "no-expand-suggestions", false, "Disable automatic expansion of [SUGGEST:] and &lt;&lt;&lt;SUGGEST&gt;&gt;&gt; syntax")
        replyCmd.Flags().StringVar(&amp;commentType, "type", "review", "Comment type: 'issue' for general PR comments, 'review' for line-specific comments (default: review)")
}</span>

func runReply(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if replyClient == nil </span><span class="cov8" title="1">{
                replyClient = &amp;github.RealClient{}
        }</span>

        // Parse comment ID
        <span class="cov8" title="1">commentIDStr := args[0]
        commentID, err := strconv.Atoi(commentIDStr)
        if err != nil </span><span class="cov8" title="1">{
                return formatValidationError("comment ID", commentIDStr, "must be a valid integer")
        }</span>

        // We'll get repository from getPRContext below

        // Get message if provided
        <span class="cov8" title="1">var message string
        if len(args) &gt; 1 </span><span class="cov8" title="1">{
                message = args[1]
        }</span>

        // Validate that we have either message, reaction, remove-reaction, or resolve
        <span class="cov8" title="1">if message == "" &amp;&amp; reaction == "" &amp;&amp; removeReaction == "" &amp;&amp; !resolveConversation </span><span class="cov8" title="1">{
                return fmt.Errorf("must provide either a message, --reaction, --remove-reaction, or --resolve")
        }</span>

        // Validate that we don't have both reaction and remove-reaction
        <span class="cov8" title="1">if reaction != "" &amp;&amp; removeReaction != "" </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot use both --reaction and --remove-reaction at the same time")
        }</span>

        // Validate reaction if provided
        <span class="cov8" title="1">if reaction != "" &amp;&amp; !validateReaction(reaction) </span><span class="cov8" title="1">{
                return formatValidationError("reaction", reaction, "must be one of: +1, -1, laugh, confused, heart, hooray, rocket, eyes")
        }</span>

        // Validate remove-reaction if provided
        <span class="cov8" title="1">if removeReaction != "" &amp;&amp; !validateReaction(removeReaction) </span><span class="cov0" title="0">{
                return formatValidationError("remove-reaction", removeReaction, "must be one of: +1, -1, laugh, confused, heart, hooray, rocket, eyes")
        }</span>

        // Validate comment type
        <span class="cov8" title="1">if commentType != "issue" &amp;&amp; commentType != "review" </span><span class="cov8" title="1">{
                return formatValidationError("type", commentType, "must be either 'issue' or 'review'")
        }</span>

        // Get repository context
        <span class="cov8" title="1">repository, _, err := getPRContext()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Parse owner/repo
        <span class="cov8" title="1">parts := strings.Split(repository, "/")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid repository format: %s (expected owner/repo)", repository)
        }</span>
        <span class="cov8" title="1">owner, repoName := parts[0], parts[1]

        if verbose </span><span class="cov0" title="0">{
                fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("Comment ID: %d\n", commentID)
                fmt.Printf("Comment Type: %s\n", commentType)
                if message != "" </span><span class="cov0" title="0">{
                        fmt.Printf("Message: %s\n", message)
                }</span>
                <span class="cov0" title="0">if reaction != "" </span><span class="cov0" title="0">{
                        fmt.Printf("Reaction: %s\n", reaction)
                }</span>
                <span class="cov0" title="0">if removeReaction != "" </span><span class="cov0" title="0">{
                        fmt.Printf("Remove Reaction: %s\n", removeReaction)
                }</span>
                <span class="cov0" title="0">if resolveConversation </span><span class="cov0" title="0">{
                        fmt.Printf("Resolve Conversation: true\n")
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        <span class="cov8" title="1">if dryRun </span><span class="cov0" title="0">{
                fmt.Printf("Would reply to comment #%d:\n", commentID)
                if message != "" </span><span class="cov0" title="0">{
                        fmt.Printf("Message: %s\n", message)
                }</span>
                <span class="cov0" title="0">if reaction != "" </span><span class="cov0" title="0">{
                        fmt.Printf("Reaction: %s\n", reaction)
                }</span>
                <span class="cov0" title="0">if removeReaction != "" </span><span class="cov0" title="0">{
                        fmt.Printf("Remove Reaction: %s\n", removeReaction)
                }</span>
                <span class="cov0" title="0">if resolveConversation </span><span class="cov0" title="0">{
                        fmt.Printf("Resolve Conversation: true\n")
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Add reaction if specified
        <span class="cov8" title="1">if reaction != "" </span><span class="cov8" title="1">{
                err = replyClient.AddReaction(owner, repoName, commentID, reaction)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to add reaction: %w", err)
                }</span>
                <span class="cov8" title="1">fmt.Printf("✅ Added %s reaction to comment #%d\n", reaction, commentID)</span>
        }

        // Remove reaction if specified
        <span class="cov8" title="1">if removeReaction != "" </span><span class="cov8" title="1">{
                err = replyClient.RemoveReaction(owner, repoName, commentID, removeReaction)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to remove reaction: %w", err)
                }</span>
                <span class="cov8" title="1">fmt.Printf("✅ Removed %s reaction from comment #%d\n", removeReaction, commentID)</span>
        }

        // Handle message reply
        <span class="cov8" title="1">if message != "" </span><span class="cov8" title="1">{
                // Expand suggestions if enabled
                if !noExpandSuggestionsReply </span><span class="cov8" title="1">{
                        message = expandSuggestions(message)
                }</span>

                <span class="cov8" title="1">var err error
                if commentType == "issue" </span><span class="cov0" title="0">{
                        // For issue comments, create a new issue comment (GitHub API doesn't support direct replies to issue comments)
                        // We need the PR number for this - let's get it from context
                        _, prNum, err := getPRContext()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get PR context: %w", err)
                        }</span>
                        <span class="cov0" title="0">_, err = replyClient.CreateIssueComment(owner, repoName, prNum, message)</span>
                } else<span class="cov8" title="1"> {
                        // Reply to review comment
                        _, err = replyClient.CreateReviewCommentReply(owner, repoName, commentID, message)
                }</span>

                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create reply: %w", err)
                }</span>
                <span class="cov8" title="1">fmt.Printf("✅ Replied to comment #%d: %s\n", commentID, message)</span>
        }

        // Handle resolve conversation
        <span class="cov8" title="1">if resolveConversation </span><span class="cov0" title="0">{
                if commentType == "issue" </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot resolve issue comments - only review comments can be resolved")
                }</span>

                // Find the thread ID for this comment
                <span class="cov0" title="0">threadID, err := replyClient.FindReviewThreadForComment(owner, repoName, 0, commentID) // PR number not needed for this operation
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to find review thread: %w", err)
                }</span>

                // Resolve the thread
                <span class="cov0" title="0">err = replyClient.ResolveReviewThread(threadID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to resolve conversation: %w", err)
                }</span>
                <span class="cov0" title="0">fmt.Printf("✅ Resolved conversation for comment #%d\n", commentID)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func validateReaction(reaction string) bool <span class="cov8" title="1">{
        validReactions := []string{"+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"}
        for _, valid := range validReactions </span><span class="cov8" title="1">{
                if reaction == valid </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>

		<pre class="file" id="file9" style="display: none">package cmd

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
)

var (
        // Client for dependency injection (tests can override)
        resolveClient github.GitHubAPI
)

var resolveCmd = &amp;cobra.Command{
        Use:   "resolve &lt;comment-id&gt;",
        Short: "Resolve a conversation thread",
        Long: `Resolve a conversation thread for a pull request review comment.

This marks the conversation as resolved, indicating that the feedback
has been addressed. Use the comment ID from 'gh comment list' output.

Examples:
  # Resolve a conversation
  gh comment resolve 2246362251

  # Resolve with dry-run
  gh comment resolve --dry-run 2246362251`,
        Args: cobra.ExactArgs(1),
        RunE: runResolve,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(resolveCmd)
}</span>

func runResolve(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if resolveClient == nil </span><span class="cov8" title="1">{
                resolveClient = &amp;github.RealClient{}
        }</span>

        // Parse comment ID
        <span class="cov8" title="1">commentID, err := strconv.Atoi(args[0])
        if err != nil </span><span class="cov8" title="1">{
                return formatValidationError("comment ID", args[0], "must be a valid integer")
        }</span>

        // Get repository and PR context
        <span class="cov8" title="1">repository, pr, err := getPRContext()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Parse owner/repo
        <span class="cov8" title="1">parts := strings.Split(repository, "/")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid repository format: %s (expected owner/repo)", repository)
        }</span>
        <span class="cov8" title="1">owner, repoName := parts[0], parts[1]

        if verbose </span><span class="cov8" title="1">{
                fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("PR Number: %d\n", pr)
                fmt.Printf("Comment ID: %d\n", commentID)
                fmt.Println()
        }</span>

        <span class="cov8" title="1">if dryRun </span><span class="cov8" title="1">{
                fmt.Printf("Would resolve conversation for comment #%d in PR #%d\n", commentID, pr)
                return nil
        }</span>

        // Find the review thread for this comment
        <span class="cov8" title="1">threadID, err := resolveClient.FindReviewThreadForComment(owner, repoName, pr, commentID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to find review thread for comment: %w", err)
        }</span>

        // Resolve the review thread
        <span class="cov8" title="1">err = resolveClient.ResolveReviewThread(threadID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to resolve conversation: %w", err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("✅ Resolved conversation for comment #%d\n", commentID)
        return nil</span>
}
</pre>

		<pre class="file" id="file10" style="display: none">package cmd

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/MakeNowJust/heredoc"
        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
)

var (
        // Client for dependency injection (tests can override)
        reviewClient github.GitHubAPI

        // Review-specific flags
        reviewEventFlag    string
        reviewCommentsFlag []string
)

var reviewCmd = &amp;cobra.Command{
        Use:   "review &lt;pr&gt; &lt;body&gt;",
        Short: "Create a review with multiple comments",
        Long: heredoc.Doc(`
                Create a review with multiple comments using a streamlined interface.

                This command provides a simplified way to create reviews with multiple comments
                using command-line flags. Perfect for comprehensive code reviews where you
                want to add several comments and submit a review decision in one operation.
        `),
        Example: heredoc.Doc(`
                # Security-focused comprehensive review
                $ gh comment review 123 "Security audit complete - critical issues found" \
                  --comment auth.go:67:"Use crypto.randomBytes(32) instead of Math.random() for token generation" \
                  --comment api.js:134:140:"This endpoint lacks rate limiting - vulnerable to DoS attacks" \
                  --comment validation.js:25:"Input sanitization missing - SQL injection risk" \
                  --event REQUEST_CHANGES

                # Performance optimization review
                $ gh comment review 123 "Performance review - optimization opportunities identified" \
                  --comment database.py:89:95:"Extract this N+1 query to a single batch operation" \
                  --comment cache.js:156:"Consider Redis clustering for this high-traffic endpoint" \
                  --comment monitoring.go:78:"Add performance metrics for this critical path" \
                  --event COMMENT

                # Architecture migration approval
                $ gh comment review 123 "Migration to microservices architecture approved" \
                  --comment service-layer.js:45:"Excellent separation of concerns in the new service layer" \
                  --comment api-gateway.go:123:130:"API gateway implementation follows best practices" \
                  --comment docker-compose.yml:67:"Container orchestration setup looks solid" \
                  --event APPROVE

                # Code quality and maintainability review
                $ gh comment review 123 "Code quality review - refactoring needed" \
                  --comment legacy-handler.js:200:250:"This function is doing too much - extract into separate services" \
                  --comment utils.go:45:"Consider using dependency injection pattern here" \
                  --comment test-helpers.js:89:"Add integration tests for this critical business logic" \
                  --event REQUEST_CHANGES
        `),
        Args: cobra.RangeArgs(1, 2),
        RunE: runReview,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(reviewCmd)
        reviewCmd.Flags().StringVar(&amp;reviewEventFlag, "event", "COMMENT", "Review event: APPROVE, REQUEST_CHANGES, or COMMENT")
        reviewCmd.Flags().StringArrayVar(&amp;reviewCommentsFlag, "comment", []string{}, "Add comment in format file:line:message or file:start-end:message")
}</span>

func runReview(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if reviewClient == nil </span><span class="cov0" title="0">{
                reviewClient = &amp;github.RealClient{}
        }</span>

        <span class="cov8" title="1">var pr int
        var body string
        var err error

        // Parse arguments
        if len(args) == 2 </span><span class="cov8" title="1">{
                // PR number and body provided
                pr, err = strconv.Atoi(args[0])
                if err != nil </span><span class="cov8" title="1">{
                        return formatValidationError("PR number", args[0], "must be a valid integer")
                }</span>
                <span class="cov8" title="1">body = args[1]</span>
        } else<span class="cov8" title="1"> if len(args) == 1 </span><span class="cov8" title="1">{
                // Check if it's a PR number or review body
                if prNum, err := strconv.Atoi(args[0]); err == nil </span><span class="cov8" title="1">{
                        // It's a PR number
                        pr = prNum
                }</span> else<span class="cov8" title="1"> {
                        // It's a review body, auto-detect PR
                        _, pr, err = getPRContext()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">body = args[0]</span>
                }
        }

        // Validate event type
        <span class="cov8" title="1">validEvents := []string{"APPROVE", "REQUEST_CHANGES", "COMMENT"}
        isValidEvent := false
        for _, validEvent := range validEvents </span><span class="cov8" title="1">{
                if reviewEventFlag == validEvent </span><span class="cov8" title="1">{
                        isValidEvent = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !isValidEvent </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid event type: %s (must be APPROVE, REQUEST_CHANGES, or COMMENT)", reviewEventFlag)
        }</span>

        // Validate that we have either a body or comments
        <span class="cov8" title="1">if body == "" &amp;&amp; len(reviewCommentsFlag) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("review must have either a body message or comments (use --comment)")
        }</span>

        // Get repository and PR context
        <span class="cov8" title="1">repository, pr, err := getPRContext()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Parse owner/repo
        <span class="cov8" title="1">parts := strings.Split(repository, "/")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid repository format: %s (expected owner/repo)", repository)
        }</span>
        <span class="cov8" title="1">owner, repoName := parts[0], parts[1]

        if verbose </span><span class="cov8" title="1">{
                fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("PR: %d\n", pr)
                fmt.Printf("Review body: %s\n", body)
                fmt.Printf("Review event: %s\n", reviewEventFlag)
                fmt.Printf("Comments: %d\n", len(reviewCommentsFlag))
                fmt.Println()
        }</span>

        <span class="cov8" title="1">if dryRun </span><span class="cov8" title="1">{
                fmt.Printf("Would create review on PR #%d:\n", pr)
                fmt.Printf("Body: %s\n", body)
                fmt.Printf("Event: %s\n", reviewEventFlag)
                fmt.Printf("Comments: %d\n", len(reviewCommentsFlag))
                for i, comment := range reviewCommentsFlag </span><span class="cov8" title="1">{
                        fmt.Printf("  %d. %s\n", i+1, comment)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        // Get PR details for commit SHA
        <span class="cov8" title="1">prDetails, err := reviewClient.GetPRDetails(owner, repoName, pr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get PR details: %w", err)
        }</span>

        <span class="cov8" title="1">headSHA, ok := prDetails["head"].(map[string]interface{})["sha"].(string)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get commit SHA from PR details")
        }</span>

        // Parse and create review comments
        <span class="cov8" title="1">var reviewCommentInputs []github.ReviewCommentInput
        for i, commentSpec := range reviewCommentsFlag </span><span class="cov8" title="1">{
                commentInput, err := parseReviewCommentSpec(commentSpec, headSHA)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid comment %d (%s): %w", i+1, commentSpec, err)
                }</span>
                <span class="cov8" title="1">reviewCommentInputs = append(reviewCommentInputs, commentInput)</span>
        }

        // Create the review
        <span class="cov8" title="1">review := github.ReviewInput{
                Body:     body,
                Event:    reviewEventFlag,
                Comments: reviewCommentInputs,
        }

        err = reviewClient.CreateReview(owner, repoName, pr, review)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create review: %w", err)
        }</span>

        // Display success message
        <span class="cov8" title="1">eventText := ""
        switch reviewEventFlag </span>{
        case "APPROVE":<span class="cov8" title="1">
                eventText = "approved"</span>
        case "REQUEST_CHANGES":<span class="cov8" title="1">
                eventText = "requested changes"</span>
        case "COMMENT":<span class="cov8" title="1">
                eventText = "commented on"</span>
        }

        <span class="cov8" title="1">fmt.Printf("✅ Successfully created review and %s PR #%d", eventText, pr)
        if len(reviewCommentInputs) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf(" with %d comments", len(reviewCommentInputs))
        }</span>
        <span class="cov8" title="1">fmt.Println()

        return nil</span>
}

// parseReviewCommentSpec parses a comment specification in the format:
// file:line:message or file:start-end:message
func parseReviewCommentSpec(spec, commitSHA string) (github.ReviewCommentInput, error) <span class="cov8" title="1">{
        parts := strings.SplitN(spec, ":", 3)
        if len(parts) &lt; 3 </span><span class="cov8" title="1">{
                return github.ReviewCommentInput{}, fmt.Errorf("format must be file:line:message or file:start-end:message")
        }</span>

        <span class="cov8" title="1">filePath := parts[0]
        lineSpec := parts[1]
        message := strings.Join(parts[2:], ":") // Rejoin in case message contains colons

        if filePath == "" </span><span class="cov8" title="1">{
                return github.ReviewCommentInput{}, fmt.Errorf("file path cannot be empty")
        }</span>
        <span class="cov8" title="1">if message == "" </span><span class="cov8" title="1">{
                return github.ReviewCommentInput{}, fmt.Errorf("message cannot be empty")
        }</span>

        <span class="cov8" title="1">comment := github.ReviewCommentInput{
                Body:     expandSuggestions(message),
                Path:     filePath,
                CommitID: commitSHA,
        }

        // Parse line specification (single line or range)
        if strings.Contains(lineSpec, "-") </span><span class="cov8" title="1">{
                // Range format: start-end
                rangeParts := strings.Split(lineSpec, "-")
                if len(rangeParts) != 2 </span><span class="cov8" title="1">{
                        return github.ReviewCommentInput{}, fmt.Errorf("range format must be start-end")
                }</span>

                <span class="cov8" title="1">startLine, err := strconv.Atoi(strings.TrimSpace(rangeParts[0]))
                if err != nil </span><span class="cov8" title="1">{
                        return github.ReviewCommentInput{}, fmt.Errorf("invalid start line: %w", err)
                }</span>

                <span class="cov8" title="1">endLine, err := strconv.Atoi(strings.TrimSpace(rangeParts[1]))
                if err != nil </span><span class="cov8" title="1">{
                        return github.ReviewCommentInput{}, fmt.Errorf("invalid end line: %w", err)
                }</span>

                <span class="cov8" title="1">if startLine &lt;= 0 || endLine &lt;= 0 </span><span class="cov8" title="1">{
                        return github.ReviewCommentInput{}, fmt.Errorf("line numbers must be positive")
                }</span>

                <span class="cov8" title="1">if startLine &gt; endLine </span><span class="cov8" title="1">{
                        return github.ReviewCommentInput{}, fmt.Errorf("start line must be &lt;= end line")
                }</span>

                <span class="cov8" title="1">comment.StartLine = startLine
                comment.Line = endLine</span>
        } else<span class="cov8" title="1"> {
                // Single line format
                line, err := strconv.Atoi(lineSpec)
                if err != nil </span><span class="cov8" title="1">{
                        return github.ReviewCommentInput{}, fmt.Errorf("invalid line number: %w", err)
                }</span>

                <span class="cov8" title="1">if line &lt;= 0 </span><span class="cov8" title="1">{
                        return github.ReviewCommentInput{}, fmt.Errorf("line number must be positive")
                }</span>

                <span class="cov8" title="1">comment.Line = line</span>
        }

        <span class="cov8" title="1">return comment, nil</span>
}</pre>

		<pre class="file" id="file11" style="display: none">package cmd

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/MakeNowJust/heredoc"
        "github.com/cli/go-gh/v2"
        "github.com/spf13/cobra"
)

var (
        // Global flags
        prNumber     int
        repo         string
        validateDiff bool
        dryRun       bool
        verbose      bool
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &amp;cobra.Command{
        Use:   "gh-comment",
        Short: "Strategic GitHub PR commenting and review management",
        Long: heredoc.Doc(`
                gh-comment provides professional-grade tools for GitHub pull request
                comment management, systematic code reviews, and review process automation.

                Designed for developers, code review leads, and teams who need sophisticated
                comment workflows beyond GitHub's web interface capabilities.

                Strategic GitHub PR Commenting - Beyond the Web Interface:

                gh-comment is designed for professional code review workflows that require:
                • Systematic line-by-line code analysis with context
                • Bulk comment operations for comprehensive reviews
                • Advanced filtering for comment analysis and metrics
                • Automation integration for CI/CD review processes
                • Data export for review process optimization

                Perfect for: Senior developers, code review leads, QA teams, and DevOps engineers
                who need sophisticated comment management beyond GitHub's web interface.
        `),
        Example: heredoc.Doc(`
                Commands:
                  add           Add targeted comments to specific lines
                  add-review    Create draft reviews with multiple comments
                  batch         Process comments from YAML configuration files
                  edit          Modify existing comments
                  list          List and filter comments with advanced options
                  reply         Reply to comments and manage reactions
                  resolve       Resolve conversation threads
                  review        Create reviews with comments in one operation
                  submit-review Submit pending reviews with approval/changes
                  help          Help about any command

                Global Flags:
                  -p, --pr int        PR number (auto-detect from branch if omitted)
                  -R, --repo string   Repository (owner/repo format)
                      --dry-run       Show what would be commented without executing
                  -v, --verbose       Show detailed API interactions
                      --validate      Validate line exists in diff before commenting (default true)

                Filtering Flags (list command):
                      --author string     Filter by author (supports wildcards: 'user*')
                      --since string      Show comments after date ('2024-01-01', '1 week ago')
                      --until string      Show comments before date
                      --status string     Filter by status: open, resolved, all
                      --type string       Filter by type: issue, review, all
                  -q, --quiet            Minimal output for scripts

                Review Flags:
                      --event string      Review event: APPROVE, REQUEST_CHANGES, COMMENT
                      --comment strings   Add comments: file:line:message

                Examples:
                # Basic Operations
                $ gh comment list 123                           List all comments on PR #123
                $ gh comment add 123 "Looks good overall!"     Add general PR comment

                # Strategic Line Commenting (Unique Value)
                $ gh comment add 123 src/api.js 42 "This handles the rate limiting edge case - consider moving to middleware"
                $ gh comment add 123 auth.go 15:25 "This entire auth flow needs refactoring for OAuth2 compliance"
                $ gh comment add 123 database.py 156 "This query is vulnerable to SQL injection - use parameterized queries"

                # Advanced Filtering (Power User Features)
                $ gh comment list 123 --author "senior-dev*" --status open --since "1 week ago"
                $ gh comment list 123 --type review --author "*@company.com" --since "deployment-date"
                $ gh comment list 123 --status resolved --until "2024-01-01" --format json

                # Review Workflows (Professional Code Review)
                $ gh comment review 123 "Migration review complete" \
                  --comment src/api.js:42:"Add rate limiting middleware" \
                  --comment src/auth.js:15:20:"Update to OAuth2 flow" \
                  --comment tests/api_test.go:100:"Add edge case tests" \
                  --event REQUEST_CHANGES

                $ gh comment add-review 123 "Security audit findings" \
                  --comment auth.go:67:"Use crypto.randomBytes(32) for tokens" \
                  --comment api.js:134:140:"Extract business logic to service layer"

                # Batch Operations (Systematic Reviews)
                $ gh comment batch comprehensive-review.yaml
                $ gh comment batch --dry-run security-audit.yaml
                $ gh comment batch post-deployment-checklist.yaml --pr $(gh pr view --json number -q .number)

                # Conversation Management
                $ gh comment reply 2246362251 "Fixed in commit abc123" --resolve
                $ gh comment reply 3141344022 "Great catch! This would have caused issues in production" --reaction +1
                $ gh comment resolve --thread 2246362251 --reason "Addressed in latest commit"

                # Data Export &amp; Analysis (Automation)
                $ gh comment list 123 --format json | jq '.comments[].author' | sort | uniq -c
                $ gh comment list 123 --format csv --since "2024-01-01" --output q1-review-data.csv
                $ gh comment list 123 --author "qa-team*" --format json | analyze-feedback.py

                # Automation &amp; CI Integration
                $ gh comment add 123 src/security.js 67 "[SUGGEST: use crypto.randomBytes(32)]"
                $ for file in $(git diff --name-only); do gh comment add 123 "$file" 1 "Auto-generated security scan results"; done
                $ gh comment list --since "deployment-date" --type review --status open | review-blocker-analysis.sh

                # Advanced Comment Management
                $ gh comment edit 2246362251 "Updated: This rate limiting logic handles concurrent requests properly"
                $ gh comment list 123 --author "bot*" --format json | jq '.comments[].id' | xargs -I {} gh comment resolve {}
                $ gh comment add 123 performance.js 89:95 "Consider caching this expensive calculation"
        `),
        Version: "1.0.0",
}

// Execute adds all child commands to the root command and sets flags appropriately.
func Execute() error <span class="cov8" title="1">{
        return rootCmd.Execute()
}</span>

func init() <span class="cov8" title="1">{
        // Global flags
        rootCmd.PersistentFlags().IntVarP(&amp;prNumber, "pr", "p", 0, "PR number (auto-detect from branch if omitted)")
        rootCmd.PersistentFlags().StringVarP(&amp;repo, "repo", "R", "", "Repository (owner/repo format)")

        rootCmd.PersistentFlags().BoolVar(&amp;validateDiff, "validate", true, "Validate line exists in diff before commenting")
        rootCmd.PersistentFlags().BoolVar(&amp;dryRun, "dry-run", false, "Show what would be commented without executing")
        rootCmd.PersistentFlags().BoolVarP(&amp;verbose, "verbose", "v", false, "Show detailed API interactions")
}</span>

// Helper function to get current repository if not specified
func getCurrentRepo() (string, error) <span class="cov8" title="1">{
        if repo != "" </span><span class="cov8" title="1">{
                return repo, nil
        }</span>

        // Use gh CLI to get current repository
        <span class="cov8" title="1">stdout, _, err := gh.Exec("repo", "view", "--json", "nameWithOwner", "-q", ".nameWithOwner")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get current repository: %w", err)
        }</span>

        <span class="cov8" title="1">return strings.TrimSpace(stdout.String()), nil</span>
}

// Helper function to get current PR number if not specified
func getCurrentPR() (int, error) <span class="cov8" title="1">{
        if prNumber != 0 </span><span class="cov8" title="1">{
                return prNumber, nil
        }</span>

        // Use gh CLI to get PR for current branch
        <span class="cov8" title="1">stdout, _, err := gh.Exec("pr", "view", "--json", "number", "-q", ".number")
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("failed to get current PR: %w (try specifying --pr)", err)
        }</span>

        <span class="cov0" title="0">prStr := strings.TrimSpace(stdout.String())
        pr, err := strconv.Atoi(prStr)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid PR number: %s", prStr)
        }</span>

        <span class="cov0" title="0">return pr, nil</span>
}
</pre>

		<pre class="file" id="file12" style="display: none">package cmd

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
)

var (
        submitEvent   string
        submitBody    string
        submitClient  github.GitHubAPI
)

var submitReviewCmd = &amp;cobra.Command{
        Use:   "submit-review [pr] [body]",
        Short: "Submit a pending review",
        Long: `Submit a pending review with a summary message and approval status.

This command finds your pending review on the PR and submits it with the specified
event type (APPROVE, REQUEST_CHANGES, or COMMENT) and optional summary body.

Once submitted, the pending review becomes visible to others and you can create
new reviews.

Examples:
  # Submit pending review with approval
  gh comment submit-review 123 "LGTM! Great work" --event APPROVE

  # Submit with change requests
  gh comment submit-review 123 "Please address the comments" --event REQUEST_CHANGES

  # Submit as general comment
  gh comment submit-review 123 "Thanks for the updates" --event COMMENT

  # Submit with minimal body (auto-detect PR)
  gh comment submit-review "Looks good" --event APPROVE

  # Submit without additional body
  gh comment submit-review 123 --event APPROVE`,
        Args: cobra.RangeArgs(0, 2),
        RunE: runSubmitReview,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(submitReviewCmd)
        submitReviewCmd.Flags().StringVar(&amp;submitEvent, "event", "COMMENT", "Review event: APPROVE, REQUEST_CHANGES, or COMMENT")
        submitReviewCmd.Flags().StringVar(&amp;submitBody, "body", "", "Review summary body (optional)")
}</span>

func runSubmitReview(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if submitClient == nil </span><span class="cov0" title="0">{
                submitClient = &amp;github.RealClient{}
        }</span>

        <span class="cov8" title="1">var pr int
        var body string
        var err error

        // Parse arguments
        if len(args) == 2 </span><span class="cov8" title="1">{
                // PR number and body provided
                pr, err = strconv.Atoi(args[0])
                if err != nil </span><span class="cov8" title="1">{
                        return formatValidationError("PR number", args[0], "must be a valid integer")
                }</span>
                <span class="cov8" title="1">body = args[1]</span>
        } else<span class="cov8" title="1"> if len(args) == 1 </span><span class="cov8" title="1">{
                // Check if it's a PR number or review body
                if prNum, err := strconv.Atoi(args[0]); err == nil </span><span class="cov8" title="1">{
                        // It's a PR number
                        pr = prNum
                }</span> else<span class="cov8" title="1"> {
                        // It's a review body, auto-detect PR
                        _, prNum, err := getPRContext()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">pr = prNum
                        body = args[0]</span>
                }
        } else<span class="cov8" title="1"> {
                // Auto-detect PR
                _, prNum, err := getPRContext()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">pr = prNum</span>
        }

        // Use --body flag if provided, otherwise use positional arg
        <span class="cov8" title="1">if submitBody != "" </span><span class="cov8" title="1">{
                body = submitBody
        }</span>

        // Validate event type
        <span class="cov8" title="1">validEvents := []string{"APPROVE", "REQUEST_CHANGES", "COMMENT"}
        isValidEvent := false
        for _, validEvent := range validEvents </span><span class="cov8" title="1">{
                if submitEvent == validEvent </span><span class="cov8" title="1">{
                        isValidEvent = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !isValidEvent </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid event type: %s (must be APPROVE, REQUEST_CHANGES, or COMMENT)", submitEvent)
        }</span>

        // Get repository and PR context
        <span class="cov8" title="1">repository, pr, err := getPRContext()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Parse owner/repo
        <span class="cov8" title="1">parts := strings.Split(repository, "/")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid repository format: %s (expected owner/repo)", repository)
        }</span>
        <span class="cov8" title="1">owner, repoName := parts[0], parts[1]

        if verbose </span><span class="cov8" title="1">{
                fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("PR: %d\n", pr)
                fmt.Printf("Review body: %s\n", body)
                fmt.Printf("Review event: %s\n", submitEvent)
                fmt.Println()
        }</span>

        <span class="cov8" title="1">if dryRun </span><span class="cov8" title="1">{
                fmt.Printf("Would submit pending review on PR #%d:\n", pr)
                fmt.Printf("Body: %s\n", body)
                fmt.Printf("Event: %s\n", submitEvent)
                return nil
        }</span>

        // Find the pending review
        <span class="cov8" title="1">reviewID, err := submitClient.FindPendingReview(owner, repoName, pr)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to find pending review: %w", err)
        }</span>

        <span class="cov8" title="1">if reviewID == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("no pending review found on PR #%d", pr)
        }</span>

        <span class="cov8" title="1">if verbose </span><span class="cov8" title="1">{
                fmt.Printf("Found pending review ID: %d\n", reviewID)
        }</span>

        // Submit the review
        <span class="cov8" title="1">err = submitClient.SubmitReview(owner, repoName, pr, reviewID, body, submitEvent)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to submit review: %w", err)
        }</span>

        // Display success message
        <span class="cov8" title="1">eventText := ""
        switch submitEvent </span>{
        case "APPROVE":<span class="cov8" title="1">
                eventText = "approved"</span>
        case "REQUEST_CHANGES":<span class="cov8" title="1">
                eventText = "requested changes"</span>
        case "COMMENT":<span class="cov8" title="1">
                eventText = "commented"</span>
        }

        <span class="cov8" title="1">fmt.Printf("✅ Successfully submitted review and %s PR #%d\n", eventText, pr)
        return nil</span>
}
</pre>

		<pre class="file" id="file13" style="display: none">package cmd

import (
        "regexp"
        "strings"
)

// expandSuggestions processes inline suggestion syntax and converts to GitHub markdown
func expandSuggestions(message string) string <span class="cov8" title="1">{
        // First handle multi-line suggestions: &lt;&lt;&lt;SUGGEST\ncode\nSUGGEST&gt;&gt;&gt;
        message = expandMultilineSuggestions(message)

        // Then handle inline suggestions: [SUGGEST: code]
        message = expandInlineSuggestions(message)

        return message
}</span>

// expandInlineSuggestions handles [SUGGEST: code] syntax
func expandInlineSuggestions(message string) string <span class="cov8" title="1">{
        // Regex to match [SUGGEST: code] patterns
        re := regexp.MustCompile(`\[SUGGEST:\s*([^\]]+)\]`)

        return re.ReplaceAllStringFunc(message, func(match string) string </span><span class="cov8" title="1">{
                // Extract the code part
                submatches := re.FindStringSubmatch(match)
                if len(submatches) &lt; 2 </span><span class="cov0" title="0">{
                        return match // Return original if parsing fails
                }</span>

                <span class="cov8" title="1">code := strings.TrimSpace(submatches[1])
                return "\n\n```suggestion\n" + code + "\n```\n\n"</span>
        })
}

// expandMultilineSuggestions handles &lt;&lt;&lt;SUGGEST\ncode\nSUGGEST&gt;&gt;&gt; syntax
func expandMultilineSuggestions(message string) string <span class="cov8" title="1">{
        // Regex to match &lt;&lt;&lt;SUGGEST...code...SUGGEST&gt;&gt;&gt; blocks (with flexible whitespace)
        re := regexp.MustCompile(`(?s)&lt;&lt;&lt;SUGGEST\s*\n(.*?)\nSUGGEST&gt;&gt;&gt;`)

        return re.ReplaceAllStringFunc(message, func(match string) string </span><span class="cov8" title="1">{
                // Extract the code part
                submatches := re.FindStringSubmatch(match)
                if len(submatches) &lt; 2 </span><span class="cov0" title="0">{
                        return match // Return original if parsing fails
                }</span>

                <span class="cov8" title="1">code := strings.TrimSpace(submatches[1])
                return "\n\n```suggestion\n" + code + "\n```\n\n"</span>
        })
}
</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
