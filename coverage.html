
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/silouanwright/gh-comment/cmd/add.go (65.7%)</option>
				
				<option value="file1">github.com/silouanwright/gh-comment/cmd/batch.go (83.0%)</option>
				
				<option value="file2">github.com/silouanwright/gh-comment/cmd/client_helper.go (100.0%)</option>
				
				<option value="file3">github.com/silouanwright/gh-comment/cmd/close-pending-review.go (90.4%)</option>
				
				<option value="file4">github.com/silouanwright/gh-comment/cmd/edit.go (83.8%)</option>
				
				<option value="file5">github.com/silouanwright/gh-comment/cmd/helpers.go (91.5%)</option>
				
				<option value="file6">github.com/silouanwright/gh-comment/cmd/integration_testing.go (65.0%)</option>
				
				<option value="file7">github.com/silouanwright/gh-comment/cmd/lines.go (89.2%)</option>
				
				<option value="file8">github.com/silouanwright/gh-comment/cmd/list.go (79.9%)</option>
				
				<option value="file9">github.com/silouanwright/gh-comment/cmd/prompts.go (34.3%)</option>
				
				<option value="file10">github.com/silouanwright/gh-comment/cmd/react.go (68.0%)</option>
				
				<option value="file11">github.com/silouanwright/gh-comment/cmd/resolve.go (84.4%)</option>
				
				<option value="file12">github.com/silouanwright/gh-comment/cmd/review-reply.go (58.9%)</option>
				
				<option value="file13">github.com/silouanwright/gh-comment/cmd/review.go (82.9%)</option>
				
				<option value="file14">github.com/silouanwright/gh-comment/cmd/root.go (45.5%)</option>
				
				<option value="file15">github.com/silouanwright/gh-comment/cmd/suggestions.go (97.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "fmt"
        "strings"

        "github.com/MakeNowJust/heredoc"
        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
)

var (
        messages            []string
        noExpandSuggestions bool

        // Client for dependency injection (tests can override)
        addClient github.GitHubAPI
)

var addCmd = &amp;cobra.Command{
        Use:   "add [pr] &lt;comment&gt;",
        Short: "Add a general discussion comment to a pull request",
        Long: heredoc.Doc(`
                Add a general discussion comment to a pull request conversation.

                This command creates issue-style comments that appear in the main PR conversation,
                not attached to specific code lines. These comments support threaded replies
                and are perfect for general discussion, approval, or high-level feedback.

                For line-specific code review comments, use: 'gh comment review'

                The comment message supports GitHub markdown formatting and can include
                code suggestions using the [SUGGEST: code] syntax.
        `),
        Example: heredoc.Doc(`
                # General PR discussion comments
                $ gh comment add 123 "LGTM! Just a few minor suggestions below"
                $ gh comment add 123 "Thanks for addressing the security concerns"
                $ gh comment add 123 "This looks great - ready to merge after CI passes"

                # Multi-line comments with --message flags
                $ gh comment add 123 -m "Overall this is excellent work!" -m "The architecture is clean and the tests are comprehensive"

                # Auto-detect PR from current branch
                $ gh comment add "Looks good to merge!"

                # Approval with context
                $ gh comment add 123 "Approved! The performance improvements in this PR will make a huge difference"

                # Request for changes with discussion
                $ gh comment add 123 "Could you address the failing tests? Otherwise looks good to go"
        `),
        Args: cobra.RangeArgs(1, 2),
        RunE: runAdd,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(addCmd)
        addCmd.Flags().StringArrayVarP(&amp;messages, "message", "m", []string{}, "Add message (can be used multiple times for multi-line comments)")
        addCmd.Flags().BoolVar(&amp;noExpandSuggestions, "no-expand-suggestions", false, "Disable automatic expansion of [SUGGEST:] and &lt;&lt;&lt;SUGGEST&gt;&gt;&gt; syntax")
}</span>

func runAdd(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if addClient == nil </span><span class="cov0" title="0">{
                client, err := createGitHubClient()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to initialize GitHub client: %w", err)
                }</span>
                <span class="cov0" title="0">addClient = client</span>
        }

        <span class="cov8" title="1">var pr int
        var repository string
        var comment string
        var err error

        // Parse arguments for general PR comments
        if len(messages) &gt; 0 </span><span class="cov8" title="1">{
                // Using --message flags
                if len(args) == 1 </span><span class="cov8" title="1">{
                        // PR provided + --message flags
                        pr, err = parsePositiveInt(args[0], "PR number")
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // Get repository for explicitly provided PR
                        <span class="cov8" title="1">repository, err = getCurrentRepo()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> if len(args) == 0 </span><span class="cov0" title="0">{
                        // Auto-detect PR + --message flags using centralized function
                        repository, pr, err = getPRContext()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        return fmt.Errorf("invalid arguments when using --message flags: expected [pr] or no args")
                }</span>
                <span class="cov8" title="1">comment = strings.Join(messages, "\n")</span>
        } else<span class="cov8" title="1"> if len(args) == 2 </span><span class="cov8" title="1">{
                // PR number provided + comment
                pr, err = parsePositiveInt(args[0], "PR number")
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">comment = args[1]
                // Get repository for explicitly provided PR
                repository, err = getCurrentRepo()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> if len(args) == 1 </span><span class="cov8" title="1">{
                // Auto-detect PR from current branch + comment using centralized function
                repository, pr, err = getPRContext()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">comment = args[0]</span>
        } else<span class="cov8" title="1"> {
                return fmt.Errorf("invalid arguments. Use: gh comment add [pr] &lt;comment&gt; OR gh comment add [pr] --message \"line1\" --message \"line2\"")
        }</span>

        // Validate comment
        <span class="cov8" title="1">if strings.TrimSpace(comment) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("comment cannot be empty")
        }</span>

        // Expand suggestion syntax to GitHub markdown (unless disabled)
        <span class="cov8" title="1">var transformedComment string
        if noExpandSuggestions </span><span class="cov0" title="0">{
                transformedComment = comment
        }</span> else<span class="cov8" title="1"> {
                transformedComment = expandSuggestions(comment)
        }</span>

        <span class="cov8" title="1">if verbose </span><span class="cov0" title="0">{
                fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("PR: %d\n", pr)
                fmt.Printf("Comment type: General discussion\n")
                fmt.Printf("Original comment: %s\n", comment)
                fmt.Printf("Transformed comment: %s\n", transformedComment)
        }</span>

        <span class="cov8" title="1">if dryRun </span><span class="cov0" title="0">{
                fmt.Printf("Would add general comment to PR #%d:\n%s\n", pr, transformedComment)
                return nil
        }</span>

        // Parse owner/repo
        <span class="cov8" title="1">parts := strings.Split(repository, "/")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid repository format: %s (expected owner/repo)", repository)
        }</span>
        <span class="cov8" title="1">owner, repoName := parts[0], parts[1]

        // Create general issue comment (not review comment)
        createdComment, err := addClient.CreateIssueComment(owner, repoName, pr, transformedComment)
        if err != nil </span><span class="cov0" title="0">{
                return formatActionableError("comment creation", err)
        }</span>

        // Success message
        <span class="cov8" title="1">fmt.Printf("âœ“ Added comment to PR #%d", pr)
        if createdComment != nil &amp;&amp; createdComment.ID != 0 </span><span class="cov8" title="1">{
                fmt.Printf(" (ID: %d)", createdComment.ID)
        }</span>
        <span class="cov8" title="1">fmt.Println()

        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "fmt"
        "io/ioutil"
        "strconv"
        "strings"

        "github.com/MakeNowJust/heredoc"
        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"
)

var (
        // Client for dependency injection (tests can override)
        batchClient github.GitHubAPI
)

// BatchConfig represents the structure of a batch comment configuration file
type BatchConfig struct {
        PR       int             `yaml:"pr,omitempty"`
        Repo     string          `yaml:"repo,omitempty"`
        Review   *ReviewConfig   `yaml:"review,omitempty"`
        Comments []CommentConfig `yaml:"comments,omitempty"`
}

// ReviewConfig represents review-level configuration
type ReviewConfig struct {
        Body  string `yaml:"body,omitempty"`
        Event string `yaml:"event,omitempty"` // APPROVE, REQUEST_CHANGES, COMMENT
}

// CommentConfig represents individual comment configuration
type CommentConfig struct {
        File    string `yaml:"file"`
        Line    int    `yaml:"line,omitempty"`
        Range   string `yaml:"range,omitempty"` // e.g., "10-15"
        Message string `yaml:"message"`
        Type    string `yaml:"type,omitempty"` // "review" or "issue", defaults to "review"
}

var batchCmd = &amp;cobra.Command{
        Use:   "batch &lt;config-file&gt;",
        Short: "Process multiple comments from a YAML configuration file",
        Long: heredoc.Doc(`
                Process multiple comments, reactions, and reviews from a YAML configuration file.

                This is ideal for bulk operations, automated workflows, or complex review
                scenarios. The config file can specify mixed comment types, create reviews
                with multiple comments, and set up entire review workflows.
        `),
        Example: heredoc.Doc(`
                # Process comments from config
                $ gh comment batch 123 review-config.yaml

                # Validate config without executing
                $ gh comment batch 123 review-config.yaml --dry-run

                # Use verbose output
                $ gh comment batch 123 review-config.yaml --verbose
        `),
        Args: cobra.ExactArgs(2),
        RunE: runBatch,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(batchCmd)
}</span>

func runBatch(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if batchClient == nil </span><span class="cov0" title="0">{
                client, err := createGitHubClient()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create GitHub client: %w", err)
                }</span>
                <span class="cov0" title="0">batchClient = client</span>
        }

        // Parse PR number
        <span class="cov8" title="1">prArg := args[0]
        pr, err := strconv.Atoi(prArg)
        if err != nil </span><span class="cov8" title="1">{
                return formatValidationError("PR number", prArg, "must be a valid integer")
        }</span>

        // Read and parse configuration file
        <span class="cov8" title="1">configFile := args[1]
        config, err := readBatchConfig(configFile)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to read config file: %w", err)
        }</span>

        // Override PR and repo from config if specified
        <span class="cov8" title="1">if config.PR != 0 </span><span class="cov8" title="1">{
                pr = config.PR
        }</span>

        <span class="cov8" title="1">repository := repo
        if config.Repo != "" </span><span class="cov8" title="1">{
                repository = config.Repo
        }</span>

        // Get repository and PR context if not specified
        <span class="cov8" title="1">if repository == "" </span><span class="cov0" title="0">{
                repository, pr, err = getPRContext()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Parse owner/repo
        <span class="cov8" title="1">parts := strings.Split(repository, "/")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid repository format: %s (expected owner/repo)", repository)
        }</span>
        <span class="cov8" title="1">owner, repoName := parts[0], parts[1]

        if verbose </span><span class="cov8" title="1">{
                fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("PR: %d\n", pr)
                fmt.Printf("Config file: %s\n", configFile)
                fmt.Printf("Comments to process: %d\n", len(config.Comments))
                if config.Review != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Review event: %s\n", config.Review.Event)
                }</span>
                <span class="cov8" title="1">fmt.Println()</span>
        }

        <span class="cov8" title="1">if dryRun </span><span class="cov8" title="1">{
                fmt.Printf("Would process %d comments from %s on PR #%d:\n", len(config.Comments), configFile, pr)
                for i, comment := range config.Comments </span><span class="cov8" title="1">{
                        fmt.Printf("  %d. %s:%s - %s\n", i+1, comment.File, formatLineOrRange(comment), truncateMessage(comment.Message, 50))
                }</span>
                <span class="cov8" title="1">if config.Review != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Would create review with event: %s\n", config.Review.Event)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        // Process comments
        <span class="cov8" title="1">return processBatchComments(batchClient, owner, repoName, pr, config)</span>
}

func readBatchConfig(configFile string) (*BatchConfig, error) <span class="cov8" title="1">{
        // Read file
        data, err := ioutil.ReadFile(configFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read file %s: %w", configFile, err)
        }</span>

        // Parse YAML
        <span class="cov8" title="1">var config BatchConfig
        err = yaml.Unmarshal(data, &amp;config)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse YAML: %w", err)
        }</span>

        // Validate configuration
        <span class="cov8" title="1">if len(config.Comments) == 0 &amp;&amp; config.Review == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("configuration must contain either comments or review")
        }</span>

        // Validate comments
        <span class="cov8" title="1">for i, comment := range config.Comments </span><span class="cov8" title="1">{
                if comment.File == "" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("comment %d: file is required", i+1)
                }</span>
                <span class="cov8" title="1">if comment.Message == "" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("comment %d: message is required", i+1)
                }</span>
                <span class="cov8" title="1">if comment.Line == 0 &amp;&amp; comment.Range == "" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("comment %d: either line or range is required", i+1)
                }</span>
                <span class="cov8" title="1">if comment.Line != 0 &amp;&amp; comment.Range != "" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("comment %d: cannot specify both line and range", i+1)
                }</span>
                <span class="cov8" title="1">if comment.Type != "" &amp;&amp; comment.Type != "review" &amp;&amp; comment.Type != "issue" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("comment %d: type must be 'review' or 'issue'", i+1)
                }</span>
        }

        // Validate review if present
        <span class="cov8" title="1">if config.Review != nil </span><span class="cov8" title="1">{
                if config.Review.Event != "" </span><span class="cov8" title="1">{
                        validEvents := []string{"APPROVE", "REQUEST_CHANGES", "COMMENT"}
                        isValid := false
                        for _, validEvent := range validEvents </span><span class="cov8" title="1">{
                                if config.Review.Event == validEvent </span><span class="cov8" title="1">{
                                        isValid = true
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if !isValid </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("review event must be one of: %s", strings.Join(validEvents, ", "))
                        }</span>
                }
        }

        <span class="cov8" title="1">return &amp;config, nil</span>
}

func processBatchComments(client github.GitHubAPI, owner, repo string, pr int, config *BatchConfig) error <span class="cov8" title="1">{
        // If we have a review configuration, create the review with comments
        if config.Review != nil </span><span class="cov8" title="1">{
                return processAsReview(client, owner, repo, pr, config)
        }</span>

        // Otherwise, process comments individually
        <span class="cov8" title="1">return processIndividualComments(client, owner, repo, pr, config.Comments)</span>
}

func processAsReview(client github.GitHubAPI, owner, repo string, pr int, config *BatchConfig) error <span class="cov8" title="1">{
        // Convert comments to review comment format
        var reviewComments []github.ReviewCommentInput

        for _, comment := range config.Comments </span><span class="cov8" title="1">{
                if comment.Type == "issue" </span><span class="cov8" title="1">{
                        // Issue comments can't be part of a review, process separately
                        if verbose </span><span class="cov0" title="0">{
                                fmt.Printf("Processing issue comment separately: %s:%s\n", comment.File, formatLineOrRange(comment))
                        }</span>
                        <span class="cov8" title="1">_, err := client.CreateIssueComment(owner, repo, pr, comment.Message)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create issue comment: %w", err)
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                // Note: GitHub automatically uses the latest commit SHA for review comments

                // Create review comment input
                <span class="cov8" title="1">reviewComment := github.ReviewCommentInput{
                        Body: expandSuggestions(comment.Message),
                        Path: comment.File,
                        Side: "RIGHT", // Default to RIGHT side (additions/new lines)
                }

                // Set line or range
                if comment.Range != "" </span><span class="cov0" title="0">{
                        startLine, endLine, err := parseRange(comment.Range)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid range %s: %w", comment.Range, err)
                        }</span>
                        <span class="cov0" title="0">reviewComment.StartLine = startLine
                        reviewComment.Line = endLine</span>
                } else<span class="cov8" title="1"> {
                        reviewComment.Line = comment.Line
                }</span>

                // Validate line exists in diff if validation is enabled
                <span class="cov8" title="1">if validateDiff </span><span class="cov0" title="0">{
                        if err := validateCommentLine(client, owner, repo, pr, reviewComment); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("review comment validation failed: %w", err)
                        }</span>
                }

                <span class="cov8" title="1">reviewComments = append(reviewComments, reviewComment)</span>
        }

        // Create the review
        <span class="cov8" title="1">reviewInput := github.ReviewInput{
                Body:     config.Review.Body,
                Event:    config.Review.Event,
                Comments: reviewComments,
        }

        if reviewInput.Event == "" </span><span class="cov0" title="0">{
                reviewInput.Event = "COMMENT"
        }</span>

        <span class="cov8" title="1">err := client.CreateReview(owner, repo, pr, reviewInput)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create review: %w", err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("âœ… Successfully created review with %d comments\n", len(reviewComments))
        return nil</span>
}

func processIndividualComments(client github.GitHubAPI, owner, repo string, pr int, comments []CommentConfig) error <span class="cov8" title="1">{
        successCount := 0

        for i, comment := range comments </span><span class="cov8" title="1">{
                if verbose </span><span class="cov8" title="1">{
                        fmt.Printf("Processing comment %d/%d: %s:%s\n", i+1, len(comments), comment.File, formatLineOrRange(comment))
                }</span>

                <span class="cov8" title="1">commentType := comment.Type
                if commentType == "" </span><span class="cov8" title="1">{
                        commentType = "review" // Default to review comments
                }</span>

                <span class="cov8" title="1">var err error
                if commentType == "issue" </span><span class="cov0" title="0">{
                        _, err = client.CreateIssueComment(owner, repo, pr, expandSuggestions(comment.Message))
                }</span> else<span class="cov8" title="1"> {
                        // For review comments, we need the commit SHA
                        // Note: GitHub automatically uses the latest commit SHA for review comments

                        reviewComment := github.ReviewCommentInput{
                                Body: expandSuggestions(comment.Message),
                                Path: comment.File,
                                Side: "RIGHT", // Default to RIGHT side (additions/new lines)
                        }

                        // Set line or range
                        if comment.Range != "" </span><span class="cov8" title="1">{
                                startLine, endLine, err := parseRange(comment.Range)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("invalid range %s: %w", comment.Range, err)
                                }</span>
                                <span class="cov8" title="1">reviewComment.StartLine = startLine
                                reviewComment.Line = endLine</span>
                        } else<span class="cov8" title="1"> {
                                reviewComment.Line = comment.Line
                        }</span>

                        // Validate line exists in diff if validation is enabled
                        <span class="cov8" title="1">if validateDiff </span><span class="cov0" title="0">{
                                if err := validateCommentLine(client, owner, repo, pr, reviewComment); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("comment %d validation failed: %w", i+1, err)
                                }</span>
                        }

                        <span class="cov8" title="1">err = client.AddReviewComment(owner, repo, pr, reviewComment)</span>
                }

                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create comment %d: %w", i+1, err)
                }</span>

                <span class="cov8" title="1">successCount++</span>
        }

        <span class="cov8" title="1">fmt.Printf("âœ… Successfully created %d comments\n", successCount)
        return nil</span>
}

// Helper functions
func formatLineOrRange(comment CommentConfig) string <span class="cov8" title="1">{
        if comment.Range != "" </span><span class="cov8" title="1">{
                return comment.Range
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%d", comment.Line)</span>
}

func truncateMessage(message string, maxLen int) string <span class="cov8" title="1">{
        if len(message) &lt;= maxLen </span><span class="cov8" title="1">{
                return message
        }</span>
        <span class="cov8" title="1">return message[:maxLen-3] + "..."</span>
}

func parseRange(rangeStr string) (startLine, endLine int, err error) <span class="cov8" title="1">{
        parts := strings.Split(rangeStr, "-")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return 0, 0, fmt.Errorf("range must be in format 'start-end'")
        }</span>

        <span class="cov8" title="1">startLine, err = strconv.Atoi(strings.TrimSpace(parts[0]))
        if err != nil </span><span class="cov8" title="1">{
                return 0, 0, fmt.Errorf("invalid start line: %w", err)
        }</span>

        <span class="cov8" title="1">endLine, err = strconv.Atoi(strings.TrimSpace(parts[1]))
        if err != nil </span><span class="cov8" title="1">{
                return 0, 0, fmt.Errorf("invalid end line: %w", err)
        }</span>

        <span class="cov8" title="1">if startLine &lt;= 0 || endLine &lt;= 0 </span><span class="cov8" title="1">{
                return 0, 0, fmt.Errorf("line numbers must be positive")
        }</span>

        <span class="cov8" title="1">if startLine &gt; endLine </span><span class="cov8" title="1">{
                return 0, 0, fmt.Errorf("start line (%d) cannot be greater than end line (%d)", startLine, endLine)
        }</span>

        <span class="cov8" title="1">return startLine, endLine, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cmd

import (
        "os"

        "github.com/silouanwright/gh-comment/internal/github"
)

// createGitHubClient creates the appropriate GitHub client based on environment
func createGitHubClient() (github.GitHubAPI, error) <span class="cov8" title="1">{
        // Check if we're in a test environment with mock server
        if mockURL := os.Getenv("MOCK_SERVER_URL"); mockURL != "" </span><span class="cov8" title="1">{
                return github.NewTestClient()
        }</span>

        // Use real client for production
        <span class="cov8" title="1">return github.NewRealClient()</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package cmd

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
)

var (
        closePendingEvent  string
        closePendingBody   string
        closePendingClient github.GitHubAPI
)

var closePendingReviewCmd = &amp;cobra.Command{
        Use:   "close-pending-review [pr] [body]",
        Short: "Close/submit a pending review created in GitHub's web interface",
        Long: `Close and submit a pending review that was created in GitHub's web interface.

IMPORTANT: This command only works with pending reviews created through GitHub's
web interface. The GitHub API cannot create pending reviews - only the web UI can.

This command finds your existing pending review on the PR and submits it with
the specified event type (APPROVE, REQUEST_CHANGES, or COMMENT) and optional
summary body.

Once submitted, the pending review becomes visible to others and you can create
new reviews.

Note: This does NOT work with reviews created via 'gh comment add-review' or
'gh comment review' commands, as those create submitted reviews immediately.`,
        Example: `  # Submit GUI-created pending review with approval
  gh comment close-pending-review 123 "LGTM! Great work" --event APPROVE

  # Submit with change requests
  gh comment close-pending-review 123 "Please address the comments" --event REQUEST_CHANGES

  # Submit as general comment
  gh comment close-pending-review 123 "Thanks for the updates" --event COMMENT

  # Submit with minimal body (auto-detect PR)
  gh comment close-pending-review "Looks good" --event APPROVE

  # Submit without additional body
  gh comment close-pending-review 123 --event APPROVE`,
        Args: cobra.RangeArgs(0, 2),
        RunE: runClosePendingReview,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(closePendingReviewCmd)
        closePendingReviewCmd.Flags().StringVar(&amp;closePendingEvent, "event", "COMMENT", "Review event: APPROVE, REQUEST_CHANGES, or COMMENT")
        closePendingReviewCmd.Flags().StringVar(&amp;closePendingBody, "body", "", "Review summary body (optional)")
}</span>

func runClosePendingReview(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if closePendingClient == nil </span><span class="cov0" title="0">{
                client, err := createGitHubClient()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create GitHub client: %w", err)
                }</span>
                <span class="cov0" title="0">closePendingClient = client</span>
        }

        <span class="cov8" title="1">var pr int
        var body string
        var err error

        // Parse arguments
        if len(args) == 2 </span><span class="cov8" title="1">{
                // PR number and body provided
                pr, err = strconv.Atoi(args[0])
                if err != nil </span><span class="cov8" title="1">{
                        return formatValidationError("PR number", args[0], "must be a valid integer")
                }</span>
                <span class="cov8" title="1">body = args[1]</span>
        } else<span class="cov8" title="1"> if len(args) == 1 </span><span class="cov8" title="1">{
                // Check if it's a PR number or review body
                if prNum, err := strconv.Atoi(args[0]); err == nil </span><span class="cov8" title="1">{
                        // It's a PR number
                        pr = prNum
                }</span> else<span class="cov8" title="1"> {
                        // It's a review body, auto-detect PR
                        _, prNum, err := getPRContext()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">pr = prNum
                        body = args[0]</span>
                }
        } else<span class="cov8" title="1"> {
                // Auto-detect PR
                _, prNum, err := getPRContext()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">pr = prNum</span>
        }

        // Use --body flag if provided, otherwise use positional arg
        <span class="cov8" title="1">if closePendingBody != "" </span><span class="cov8" title="1">{
                body = closePendingBody
        }</span>

        // Validate event type
        <span class="cov8" title="1">validEvents := []string{"APPROVE", "REQUEST_CHANGES", "COMMENT"}
        isValidEvent := false
        for _, validEvent := range validEvents </span><span class="cov8" title="1">{
                if closePendingEvent == validEvent </span><span class="cov8" title="1">{
                        isValidEvent = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !isValidEvent </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid event type: %s (must be APPROVE, REQUEST_CHANGES, or COMMENT)", closePendingEvent)
        }</span>

        // Get repository and PR context
        <span class="cov8" title="1">repository, pr, err := getPRContext()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Parse owner/repo
        <span class="cov8" title="1">parts := strings.Split(repository, "/")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid repository format: %s (expected owner/repo)", repository)
        }</span>
        <span class="cov8" title="1">owner, repoName := parts[0], parts[1]

        if verbose </span><span class="cov8" title="1">{
                fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("PR: %d\n", pr)
                fmt.Printf("Review body: %s\n", body)
                fmt.Printf("Review event: %s\n", closePendingEvent)
                fmt.Println()
        }</span>

        <span class="cov8" title="1">if dryRun </span><span class="cov8" title="1">{
                fmt.Printf("Would close pending review on PR #%d:\n", pr)
                fmt.Printf("Body: %s\n", body)
                fmt.Printf("Event: %s\n", closePendingEvent)
                return nil
        }</span>

        // Find the pending review
        <span class="cov8" title="1">reviewID, err := closePendingClient.FindPendingReview(owner, repoName, pr)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to find pending review: %w", err)
        }</span>

        <span class="cov8" title="1">if reviewID == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("no pending review found on PR #%d\n\nNote: This command only works with pending reviews created in GitHub's web interface.\nUse 'gh comment review' to create and submit reviews via CLI.", pr)
        }</span>

        <span class="cov8" title="1">if verbose </span><span class="cov8" title="1">{
                fmt.Printf("Found pending review ID: %d\n", reviewID)
        }</span>

        // Submit the review
        <span class="cov8" title="1">err = closePendingClient.SubmitReview(owner, repoName, pr, reviewID, body, closePendingEvent)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to submit review: %w", err)
        }</span>

        // Display success message
        <span class="cov8" title="1">eventText := ""
        switch closePendingEvent </span>{
        case "APPROVE":<span class="cov8" title="1">
                eventText = "approved"</span>
        case "REQUEST_CHANGES":<span class="cov8" title="1">
                eventText = "requested changes"</span>
        case "COMMENT":<span class="cov8" title="1">
                eventText = "commented"</span>
        }

        <span class="cov8" title="1">fmt.Printf("âœ… Successfully submitted pending review and %s PR #%d\n", eventText, pr)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package cmd

import (
        "fmt"
        "strings"

        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
)

var (
        editMessages []string

        // Client for dependency injection (tests can override)
        editClient github.GitHubAPI
)

var editCmd = &amp;cobra.Command{
        Use:   "edit &lt;comment-id&gt; [message]",
        Short: "Edit an existing comment on a PR",
        Long: `Edit an existing comment on a pull request.

You can edit with a new message using either positional argument or --message flags.
Use the comment ID from the URL shown in 'gh comment list' output.

Common use cases:
- Fix typos in comments: "Fixed typo in previous comment"
- Add more context: "Adding more details about the implementation"
- Refine AI-generated comments: "Updating comment based on new analysis"
- Correct mistakes: "Correcting the suggested approach"

Examples:
  # Edit with new message
  gh comment edit 2246362251 "Updated comment with better explanation"

  # Edit with multi-line content using --message flags (AI-friendly)
  gh comment edit 2246362251 --message "First paragraph" --message "Second paragraph"

  # Edit with multi-line content (shell native)
  gh comment edit 2246362251 "Line 1
Line 2
Line 3"`,
        Args: cobra.RangeArgs(1, 2),
        RunE: runEdit,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(editCmd)
        editCmd.Flags().StringArrayVarP(&amp;editMessages, "message", "m", []string{}, "Edit message (can be used multiple times for multi-line comments)")
}</span>

func runEdit(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if editClient == nil </span><span class="cov0" title="0">{
                client, err := createGitHubClient()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create GitHub client: %w", err)
                }</span>
                <span class="cov0" title="0">editClient = client</span>
        }

        // Parse comment ID
        <span class="cov8" title="1">commentID, err := parsePositiveInt(args[0], "comment ID")
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">var message string

        // Handle message from positional arg or --message flags
        if len(args) == 2 </span><span class="cov8" title="1">{
                message = args[1]
        }</span> else<span class="cov8" title="1"> if len(editMessages) &gt; 0 </span><span class="cov8" title="1">{
                message = strings.Join(editMessages, "\n")
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("must provide either a message argument or --message flags")
        }</span>

        // Get repository context
        <span class="cov8" title="1">repository, prNumber, err := getPRContext()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Parse owner/repo
        <span class="cov8" title="1">parts := strings.Split(repository, "/")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid repository format: %s (expected owner/repo)", repository)
        }</span>
        <span class="cov8" title="1">owner, repoName := parts[0], parts[1]

        if verbose </span><span class="cov8" title="1">{
                fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("Comment ID: %d\n", commentID)
                fmt.Printf("New message: %s\n", message)
                fmt.Println()
        }</span>

        <span class="cov8" title="1">if dryRun </span><span class="cov8" title="1">{
                fmt.Printf("Would edit comment #%d:\n", commentID)
                fmt.Printf("New message: %s\n", message)
                return nil
        }</span>

        // Edit the comment using the client
        <span class="cov8" title="1">err = editClient.EditComment(owner, repoName, commentID, prNumber, message)
        if err != nil </span><span class="cov0" title="0">{
                return formatActionableError("comment editing", err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("âœ… Edited comment #%d\n", commentID)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package cmd

import (
        "fmt"
        "strconv"
        "strings"
)

// Constants for API limits and defaults
const (
        MaxGraphQLResults = 100
        MaxCommentLength  = 65536
        DefaultPageSize   = 30
)

// getPRContext gets the repository and PR number, handling both flag and auto-detection
func getPRContext() (repo string, pr int, err error) <span class="cov8" title="1">{
        repo, err = getCurrentRepo()
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, fmt.Errorf("failed to get repository: %w", err)
        }</span>

        <span class="cov8" title="1">if prNumber &gt; 0 </span><span class="cov8" title="1">{
                pr = prNumber
        }</span> else<span class="cov0" title="0"> {
                pr, err = getCurrentPR()
                if err != nil </span><span class="cov0" title="0">{
                        return "", 0, fmt.Errorf("failed to detect PR number: %w (try specifying --pr)", err)
                }</span>
        }

        <span class="cov8" title="1">return repo, pr, nil</span>
}

// formatAPIError creates consistent error messages for API failures
func formatAPIError(operation, endpoint string, err error) error <span class="cov8" title="1">{
        return fmt.Errorf("GitHub API error during %s: %w", operation, err)
}</span>

// formatActionableError creates user-friendly error messages with actionable suggestions
func formatActionableError(operation string, err error) error <span class="cov8" title="1">{
        errStr := err.Error()

        // Handle common GitHub API error patterns
        switch </span>{
        case containsAny(errStr, []string{"422", "Unprocessable Entity", "validation failed"}):<span class="cov8" title="1">
                return fmt.Errorf("validation error during %s: %w\n\nðŸ’¡ Suggestions:\n  â€¢ Check if the line number exists in the PR diff\n  â€¢ Use 'gh comment lines &lt;pr&gt; &lt;file&gt;' to see commentable lines\n  â€¢ Verify the file path is correct in the PR\n  â€¢ For line-specific comments, ensure the line was modified in this PR", operation, err)</span>

        case containsAny(errStr, []string{"404", "Not Found"}):<span class="cov8" title="1">
                return fmt.Errorf("resource not found during %s: %w\n\nðŸ’¡ Suggestions:\n  â€¢ Verify the PR number exists and is accessible\n  â€¢ Check if the comment ID is valid\n  â€¢ Ensure you have permission to access this repository", operation, err)</span>

        case containsAny(errStr, []string{"403", "Forbidden"}):<span class="cov8" title="1">
                return fmt.Errorf("permission denied during %s: %w\n\nðŸ’¡ Suggestions:\n  â€¢ Check if you have write access to the repository\n  â€¢ Verify your GitHub authentication with 'gh auth status'\n  â€¢ You cannot approve your own PR or comment on private repos without access", operation, err)</span>

        case containsAny(errStr, []string{"401", "Unauthorized"}):<span class="cov8" title="1">
                return fmt.Errorf("authentication failed during %s: %w\n\nðŸ’¡ Suggestions:\n  â€¢ Run 'gh auth login' to authenticate with GitHub\n  â€¢ Check if your token has expired\n  â€¢ Verify you're authenticated with the correct GitHub account", operation, err)</span>

        case containsAny(errStr, []string{"rate limit", "rate_limit", "too many requests"}):<span class="cov8" title="1">
                return fmt.Errorf("rate limit exceeded during %s: %w\n\nðŸ’¡ Suggestions:\n  â€¢ Wait a few minutes before trying again\n  â€¢ Use authenticated requests (ensure 'gh auth status' shows logged in)\n  â€¢ Consider reducing the frequency of API calls", operation, err)</span>

        case containsAny(errStr, []string{"500", "502", "503", "Internal Server Error", "Bad Gateway", "Service Unavailable"}):<span class="cov8" title="1">
                return fmt.Errorf("GitHub server error during %s: %w\n\nðŸ’¡ Suggestions:\n  â€¢ This is a temporary GitHub server issue\n  â€¢ Try again in a few minutes\n  â€¢ Check GitHub's status page at https://status.github.com", operation, err)</span>

        case containsAny(errStr, []string{"network", "timeout", "connection"}):<span class="cov8" title="1">
                return fmt.Errorf("network error during %s: %w\n\nðŸ’¡ Suggestions:\n  â€¢ Check your internet connection\n  â€¢ Try again in a moment\n  â€¢ Verify GitHub is accessible from your network", operation, err)</span>

        case containsAny(errStr, []string{"No subschema in oneOf matched", "invalid request"}):<span class="cov8" title="1">
                return fmt.Errorf("invalid request format during %s: %w\n\nðŸ’¡ Suggestions:\n  â€¢ Check the command syntax in --help\n  â€¢ Verify all required arguments are provided\n  â€¢ For line comments, ensure the line exists in the PR diff", operation, err)</span>
        }

        // Default case - provide general guidance
        <span class="cov8" title="1">return fmt.Errorf("error during %s: %w\n\nðŸ’¡ Suggestions:\n  â€¢ Check 'gh comment --help' for correct usage\n  â€¢ Verify PR number and file paths are correct\n  â€¢ Run with --verbose for more details", operation, err)</span>
}

// containsAny checks if a string contains any of the provided substrings (case-insensitive)
func containsAny(str string, substrings []string) bool <span class="cov8" title="1">{
        lowerStr := strings.ToLower(str)
        for _, substr := range substrings </span><span class="cov8" title="1">{
                if strings.Contains(lowerStr, strings.ToLower(substr)) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// formatValidationError creates consistent error messages for validation failures
func formatValidationError(field, value, expected string) error <span class="cov8" title="1">{
        return fmt.Errorf("invalid %s '%s': %s", field, value, expected)
}</span>

// formatNotFoundError creates consistent error messages for missing resources
func formatNotFoundError(resource string, identifier interface{}) error <span class="cov8" title="1">{
        return fmt.Errorf("%s not found: %v", resource, identifier)
}</span>

// parsePositiveInt parses a string to a positive integer with consistent validation
func parsePositiveInt(s, fieldName string) (int, error) <span class="cov8" title="1">{
        val, err := strconv.Atoi(s)
        if err != nil </span><span class="cov8" title="1">{
                return 0, formatValidationError(fieldName, s, "must be a valid integer")
        }</span>
        <span class="cov8" title="1">if val &lt;= 0 </span><span class="cov8" title="1">{
                return 0, formatValidationError(fieldName, s, "must be a positive integer")
        }</span>
        <span class="cov8" title="1">return val, nil</span>
}

// lineRange represents a range of consecutive line numbers for display
type lineRange struct {
        start, end int
}

// groupConsecutiveLines groups consecutive line numbers into ranges for better display
func groupConsecutiveLines(lines []int) []lineRange <span class="cov8" title="1">{
        if len(lines) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var ranges []lineRange
        start := lines[0]
        end := lines[0]

        for i := 1; i &lt; len(lines); i++ </span><span class="cov8" title="1">{
                if lines[i] == end+1 </span><span class="cov8" title="1">{
                        // Consecutive line, extend the range
                        end = lines[i]
                }</span> else<span class="cov8" title="1"> {
                        // Gap found, close current range and start new one
                        ranges = append(ranges, lineRange{start: start, end: end})
                        start = lines[i]
                        end = lines[i]
                }</span>
        }

        // Add the final range
        <span class="cov8" title="1">ranges = append(ranges, lineRange{start: start, end: end})

        return ranges</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package cmd

import (
        "encoding/json"
        "fmt"
        "net/http"
        "net/http/httptest"
        "strconv"
        "strings"
        "sync"
        "time"
)

// MockGitHubServer represents a mock GitHub API server for integration testing
type MockGitHubServer struct {
        server   *httptest.Server
        mu       sync.RWMutex
        comments map[string][]MockComment
        reviews  map[string][]MockReview
        users    map[string]MockUser
}

// MockComment represents a GitHub comment for testing
type MockComment struct {
        ID        int       `json:"id"`
        Body      string    `json:"body"`
        User      MockUser  `json:"user"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
        HTMLURL   string    `json:"html_url"`
        Path      string    `json:"path,omitempty"`
        Line      int       `json:"line,omitempty"`
        StartLine int       `json:"start_line,omitempty"`
}

// MockReview represents a GitHub review for testing
type MockReview struct {
        ID       int           `json:"id"`
        Body     string        `json:"body"`
        User     MockUser      `json:"user"`
        State    string        `json:"state"`
        Comments []MockComment `json:"comments,omitempty"`
}

// MockUser represents a GitHub user for testing
type MockUser struct {
        Login string `json:"login"`
        ID    int    `json:"id"`
}

// MockPRDetails represents PR details for testing
type MockPRDetails struct {
        Number int `json:"number"`
        Head   struct {
                SHA string `json:"sha"`
        } `json:"head"`
}

// NewMockGitHubServer creates a new mock GitHub API server
func NewMockGitHubServer() *MockGitHubServer <span class="cov8" title="1">{
        s := &amp;MockGitHubServer{
                comments: make(map[string][]MockComment),
                reviews:  make(map[string][]MockReview),
                users: map[string]MockUser{
                        "test-user":    {Login: "test-user", ID: 1},
                        "reviewer":     {Login: "reviewer", ID: 2},
                        "senior-dev":   {Login: "senior-dev", ID: 3},
                        "security-bot": {Login: "security-bot", ID: 4},
                },
        }

        mux := http.NewServeMux()

        // GET /repos/{owner}/{repo}/pulls/{pr}/comments - List review comments
        mux.HandleFunc("/repos/", s.handleRepoRequests)

        s.server = httptest.NewServer(mux)
        return s
}</span>

// URL returns the mock server URL
func (s *MockGitHubServer) URL() string <span class="cov8" title="1">{
        return s.server.URL
}</span>

// Close shuts down the mock server
func (s *MockGitHubServer) Close() <span class="cov8" title="1">{
        s.server.Close()
}</span>

// AddComment adds a mock comment to the server state
func (s *MockGitHubServer) AddComment(repo string, pr int, comment MockComment) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        key := fmt.Sprintf("%s/%d", repo, pr)
        if comment.ID == 0 </span><span class="cov8" title="1">{
                comment.ID = len(s.comments[key]) + 1000
        }</span>
        <span class="cov8" title="1">if comment.CreatedAt.IsZero() </span><span class="cov8" title="1">{
                comment.CreatedAt = time.Now()
        }</span>
        <span class="cov8" title="1">if comment.UpdatedAt.IsZero() </span><span class="cov8" title="1">{
                comment.UpdatedAt = comment.CreatedAt
        }</span>
        <span class="cov8" title="1">if comment.HTMLURL == "" </span><span class="cov8" title="1">{
                comment.HTMLURL = fmt.Sprintf("%s/repos/%s/pulls/%d#issuecomment-%d", s.URL(), repo, pr, comment.ID)
        }</span>

        <span class="cov8" title="1">s.comments[key] = append(s.comments[key], comment)</span>
}

// GetComments returns comments for a PR
func (s *MockGitHubServer) GetComments(repo string, pr int) []MockComment <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        key := fmt.Sprintf("%s/%d", repo, pr)
        return s.comments[key]
}</span>

// SetupTestScenario sets up predefined test data
func (s *MockGitHubServer) SetupTestScenario(scenario string) <span class="cov8" title="1">{
        switch scenario </span>{
        case "basic":<span class="cov8" title="1">
                s.AddComment("test-owner/test-repo", 123, MockComment{
                        Body: "This looks good to me!",
                        User: s.users["test-user"],
                })
                s.AddComment("test-owner/test-repo", 123, MockComment{
                        Body: "Please fix the typo in line 42",
                        User: s.users["reviewer"],
                        Path: "src/main.go",
                        Line: 42,
                })</span>
        case "security-review":<span class="cov8" title="1">
                s.AddComment("test-owner/test-repo", 456, MockComment{
                        Body: "Security scan detected potential SQL injection vulnerability",
                        User: s.users["security-bot"],
                        Path: "database.py",
                        Line: 156,
                })
                s.AddComment("test-owner/test-repo", 456, MockComment{
                        Body: "Use crypto.randomBytes(32) instead of Math.random() for token generation",
                        User: s.users["senior-dev"],
                        Path: "auth.go",
                        Line: 67,
                })</span>
        }
}

// handleRepoRequests handles all repository-related API requests
func (s *MockGitHubServer) handleRepoRequests(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        path := strings.TrimPrefix(r.URL.Path, "/repos/")
        parts := strings.Split(path, "/")

        if len(parts) &lt; 2 </span><span class="cov8" title="1">{
                http.Error(w, "Invalid repository path", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">owner, repo := parts[0], parts[1]
        repoKey := fmt.Sprintf("%s/%s", owner, repo)

        // Handle different API endpoints
        if len(parts) &gt;= 4 &amp;&amp; parts[2] == "pulls" </span><span class="cov8" title="1">{
                prStr := parts[3]
                pr, err := strconv.Atoi(prStr)
                if err != nil </span><span class="cov8" title="1">{
                        http.Error(w, "Invalid PR number", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">if len(parts) == 4 </span><span class="cov8" title="1">{
                        // GET /repos/{owner}/{repo}/pulls/{pr} - Get PR details
                        if r.Method == "GET" </span><span class="cov8" title="1">{
                                s.handleGetPRDetails(w, r, repoKey, pr)
                                return
                        }</span>
                }

                <span class="cov8" title="1">if len(parts) &gt;= 5 &amp;&amp; parts[4] == "comments" </span><span class="cov8" title="1">{
                        switch r.Method </span>{
                        case "GET":<span class="cov8" title="1">
                                // GET /repos/{owner}/{repo}/pulls/{pr}/comments - List comments
                                s.handleListComments(w, r, repoKey, pr)</span>
                        case "POST":<span class="cov0" title="0">
                                // POST /repos/{owner}/{repo}/pulls/{pr}/comments - Create comment
                                s.handleCreateComment(w, r, repoKey, pr)</span>
                        }
                }

                <span class="cov8" title="1">if len(parts) &gt;= 5 &amp;&amp; parts[4] == "reviews" </span><span class="cov0" title="0">{
                        if r.Method == "POST" </span><span class="cov0" title="0">{
                                // POST /repos/{owner}/{repo}/pulls/{pr}/reviews - Create review
                                s.handleCreateReview(w, r, repoKey, pr)
                        }</span>
                }
        }

        <span class="cov8" title="1">if len(parts) &gt;= 4 &amp;&amp; parts[2] == "issues" </span><span class="cov8" title="1">{
                prStr := parts[3]
                pr, err := strconv.Atoi(prStr)
                if err != nil </span><span class="cov8" title="1">{
                        http.Error(w, "Invalid issue number", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">if len(parts) &gt;= 5 &amp;&amp; parts[4] == "comments" </span><span class="cov8" title="1">{
                        switch r.Method </span>{
                        case "GET":<span class="cov8" title="1">
                                // GET /repos/{owner}/{repo}/issues/{pr}/comments - List issue comments
                                s.handleListIssueComments(w, r, repoKey, pr)</span>
                        case "POST":<span class="cov0" title="0">
                                // POST /repos/{owner}/{repo}/issues/{pr}/comments - Create issue comment
                                s.handleCreateIssueComment(w, r, repoKey, pr)</span>
                        }
                }
        }
}

// handleGetPRDetails handles GET /repos/{owner}/{repo}/pulls/{pr}
func (s *MockGitHubServer) handleGetPRDetails(w http.ResponseWriter, r *http.Request, repo string, pr int) <span class="cov8" title="1">{
        details := MockPRDetails{
                Number: pr,
        }
        details.Head.SHA = "abc123def456" // Mock commit SHA

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(details)
}</span>

// handleListComments handles GET /repos/{owner}/{repo}/pulls/{pr}/comments
func (s *MockGitHubServer) handleListComments(w http.ResponseWriter, r *http.Request, repo string, pr int) <span class="cov8" title="1">{
        comments := s.GetComments(repo, pr)

        // Filter for review comments only (have path/line)
        var reviewComments []MockComment
        for _, comment := range comments </span><span class="cov8" title="1">{
                if comment.Path != "" </span><span class="cov8" title="1">{
                        reviewComments = append(reviewComments, comment)
                }</span>
        }

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(reviewComments)</span>
}

// handleListIssueComments handles GET /repos/{owner}/{repo}/issues/{pr}/comments
func (s *MockGitHubServer) handleListIssueComments(w http.ResponseWriter, r *http.Request, repo string, pr int) <span class="cov8" title="1">{
        comments := s.GetComments(repo, pr)

        // Filter for issue comments only (no path/line)
        var issueComments []MockComment
        for _, comment := range comments </span><span class="cov8" title="1">{
                if comment.Path == "" </span><span class="cov8" title="1">{
                        issueComments = append(issueComments, comment)
                }</span>
        }

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(issueComments)</span>
}

// handleCreateComment handles POST /repos/{owner}/{repo}/pulls/{pr}/comments
func (s *MockGitHubServer) handleCreateComment(w http.ResponseWriter, r *http.Request, repo string, pr int) <span class="cov0" title="0">{
        var comment MockComment
        if err := json.NewDecoder(r.Body).Decode(&amp;comment); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        // Set defaults
        <span class="cov0" title="0">comment.User = s.users["test-user"] // Default test user
        s.AddComment(repo, pr, comment)

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(comment)</span>
}

// handleCreateIssueComment handles POST /repos/{owner}/{repo}/issues/{pr}/comments
func (s *MockGitHubServer) handleCreateIssueComment(w http.ResponseWriter, r *http.Request, repo string, pr int) <span class="cov0" title="0">{
        var comment MockComment
        if err := json.NewDecoder(r.Body).Decode(&amp;comment); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        // Issue comments don't have path/line
        <span class="cov0" title="0">comment.Path = ""
        comment.Line = 0
        comment.StartLine = 0
        comment.User = s.users["test-user"]

        s.AddComment(repo, pr, comment)

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(comment)</span>
}

// handleCreateReview handles POST /repos/{owner}/{repo}/pulls/{pr}/reviews
func (s *MockGitHubServer) handleCreateReview(w http.ResponseWriter, r *http.Request, repo string, pr int) <span class="cov0" title="0">{
        var review MockReview
        if err := json.NewDecoder(r.Body).Decode(&amp;review); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">s.mu.Lock()
        defer s.mu.Unlock()

        key := fmt.Sprintf("%s/%d", repo, pr)
        review.ID = len(s.reviews[key]) + 2000
        review.User = s.users["test-user"]

        // Add review comments to the comment list
        for _, comment := range review.Comments </span><span class="cov0" title="0">{
                comment.User = s.users["test-user"]
                s.AddComment(repo, pr, comment)
        }</span>

        <span class="cov0" title="0">s.reviews[key] = append(s.reviews[key], review)

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(review)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package cmd

import (
        "fmt"
        "sort"
        "strconv"
        "strings"

        "github.com/MakeNowJust/heredoc"
        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
)

var (
        showCodeContext bool
        linesClient     github.GitHubAPI
)

var linesCmd = &amp;cobra.Command{
        Use:   "lines &lt;pr&gt; &lt;file&gt;",
        Short: "Show commentable lines in a PR file",
        Long: heredoc.Doc(`
                Show which lines in a file can receive comments based on the PR diff.

                This command helps debug failed comment attempts by showing exactly which
                lines are available for commenting. GitHub only allows comments on lines
                that are part of the diff (added, modified, or in context).

                Use this command when you get HTTP 422 errors trying to add line comments.
        `),
        Example: heredoc.Doc(`
                # Show commentable lines in a specific file
                $ gh comment lines 123 src/main.go

                # Show lines with code context
                $ gh comment lines 123 src/main.go --show-code

                # Check if specific line is commentable
                $ gh comment lines 123 src/main.go | grep "^42:"

                # Get line ranges for scripting
                $ gh comment lines 123 src/main.go | grep -o "^[0-9]*" | head -5
        `),
        Args: cobra.ExactArgs(2),
        RunE: runLines,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(linesCmd)
        linesCmd.Flags().BoolVar(&amp;showCodeContext, "show-code", false, "Show actual code content for each line")
}</span>

func runLines(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if linesClient == nil </span><span class="cov8" title="1">{
                client, err := createGitHubClient()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create GitHub client: %w", err)
                }</span>
                <span class="cov8" title="1">linesClient = client</span>
        }

        // Parse PR number
        <span class="cov8" title="1">pr, err := strconv.Atoi(args[0])
        if err != nil </span><span class="cov8" title="1">{
                return formatValidationError("PR number", args[0], "must be a valid integer")
        }</span>

        // Get file path
        <span class="cov8" title="1">filePath := args[1]

        // Get repository context
        repository, err := getCurrentRepo()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Parse owner/repo
        <span class="cov8" title="1">parts := strings.Split(repository, "/")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid repository format: %s (expected owner/repo)", repository)
        }</span>
        <span class="cov8" title="1">owner, repoName := parts[0], parts[1]

        if verbose </span><span class="cov8" title="1">{
                fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("PR: %d\n", pr)
                fmt.Printf("File: %s\n", filePath)
                fmt.Println()
        }</span>

        <span class="cov8" title="1">if dryRun </span><span class="cov8" title="1">{
                fmt.Printf("Would show commentable lines for file %s in PR #%d\n", filePath, pr)
                return nil
        }</span>

        // Fetch PR diff
        <span class="cov8" title="1">diff, err := linesClient.FetchPRDiff(owner, repoName, pr)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to fetch PR diff: %w", err)
        }</span>

        // Find the requested file in the diff
        <span class="cov8" title="1">var targetFile *github.DiffFile
        for i := range diff.Files </span><span class="cov8" title="1">{
                if diff.Files[i].Filename == filePath </span><span class="cov8" title="1">{
                        targetFile = &amp;diff.Files[i]
                        break</span>
                }
        }

        <span class="cov8" title="1">if targetFile == nil </span><span class="cov8" title="1">{
                fmt.Printf("âŒ File '%s' not found in PR #%d diff\n\n", filePath, pr)
                fmt.Println("Available files in this PR:")
                for _, file := range diff.Files </span><span class="cov8" title="1">{
                        fmt.Printf("  â€¢ %s\n", file.Filename)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        // Display commentable lines
        <span class="cov8" title="1">if len(targetFile.Lines) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("âŒ No commentable lines found in %s\n", filePath)
                fmt.Println("This file may not have any changes in this PR.")
                return nil
        }</span>

        <span class="cov8" title="1">fmt.Printf("âœ… Commentable lines in %s (PR #%d):\n\n", filePath, pr)

        // Sort line numbers
        var lineNumbers []int
        for lineNum := range targetFile.Lines </span><span class="cov8" title="1">{
                lineNumbers = append(lineNumbers, lineNum)
        }</span>
        <span class="cov8" title="1">sort.Ints(lineNumbers)

        // Group consecutive lines for better display
        ranges := groupConsecutiveLines(lineNumbers)

        fmt.Printf("ðŸ“ Line ranges available for comments:\n")
        for _, lineRange := range ranges </span><span class="cov8" title="1">{
                if lineRange.start == lineRange.end </span><span class="cov0" title="0">{
                        fmt.Printf("  â€¢ Line %d\n", lineRange.start)
                }</span> else<span class="cov8" title="1"> {
                        fmt.Printf("  â€¢ Lines %d-%d\n", lineRange.start, lineRange.end)
                }</span>
        }

        <span class="cov8" title="1">fmt.Printf("\nðŸ“ Individual lines:\n")
        for _, lineNum := range lineNumbers </span><span class="cov8" title="1">{
                if showCodeContext </span><span class="cov0" title="0">{
                        // In a real implementation, you'd fetch the actual file content
                        // For now, just show the line numbers
                        fmt.Printf("%d: [code content would be shown here]\n", lineNum)
                }</span> else<span class="cov8" title="1"> {
                        fmt.Printf("%d\n", lineNum)
                }</span>
        }

        <span class="cov8" title="1">fmt.Printf("\nðŸ’¡ Usage examples:\n")
        fmt.Printf("  â€¢ Single line:  gh comment add %d %s %d \"Your comment\"\n", pr, filePath, lineNumbers[0])
        if len(lineNumbers) &gt; 1 </span><span class="cov8" title="1">{
                fmt.Printf("  â€¢ Range comment: gh comment add %d %s %d:%d \"Range comment\"\n", pr, filePath, lineNumbers[0], lineNumbers[len(lineNumbers)-1])
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package cmd

import (
        "encoding/json"
        "fmt"
        "os"
        "regexp"
        "strings"
        "time"

        "github.com/MakeNowJust/heredoc"
        "github.com/markusmobius/go-dateparser"
        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
)

var (
        showResolved   bool
        onlyUnresolved bool
        author         string
        quiet          bool
        hideAuthors    bool

        // Advanced filtering flags
        status   string
        since    string
        until    string
        resolved string
        listType string

        // Output format flags
        outputFormat string
        idsOnly      bool

        // Parsed time values
        sinceTime *time.Time
        untilTime *time.Time

        // Client for dependency injection (tests can override)
        listClient github.GitHubAPI
)

var listCmd = &amp;cobra.Command{
        Use:   "list [pr]",
        Short: "List comments with advanced filtering and formatting options",
        Long: heredoc.Doc(`
                List all comments on a pull request with powerful filtering capabilities.

                Comment Types:
                - Issue comments: General PR discussion, appear in main conversation tab
                - Review comments: Line-specific feedback, appear in "Files Changed" tab

                Comments can be filtered by type, author, date range, resolution status, and more.
                Output can be formatted as tables, JSON, or plain text with color coding.
                Perfect for code review workflows, comment analysis, and automation.
        `),
        Example: heredoc.Doc(`
                # Review team analysis and metrics
                $ gh comment list 123 --author "senior-dev*" --status open --since "1 week ago"
                $ gh comment list 123 --type review --author "*@company.com" --since "deployment-date"

                # Security audit and compliance tracking
                $ gh comment list 123 --author "security-team*" --since "2024-01-01" --type review
                $ gh comment list 123 --author "bot*" --since "3 days ago" --quiet

                # Structured output for automation
                $ gh comment list 123 --format json | jq '.comments[].id'
                $ gh comment list 123 --ids-only | xargs -I {} gh comment resolve {}
                $ gh comment list 123 --format json --author "security*" &gt; security-comments.json

                # Code review workflow optimization
                $ gh comment list 123 --status open --since "sprint-start" --author "lead*"
                $ gh comment list 123 --until "release-date" --type issue --status resolved

                # Team communication patterns
                $ gh comment list 123 --author "qa*" --since "last-deployment" --type review
                $ gh comment list 123 --author "*@contractor.com" --status open --since "1 month ago"

                # Blocker identification and resolution tracking
                $ gh comment list 123 --author "architect*" --status open --type review
                $ gh comment list 123 --since "critical-bug-report" --author "oncall*" --status resolved

                # Performance review analysis
                $ gh comment list 123 --author "performance-team" --since "load-test-date" --type review
                $ gh comment list 123 --status open --author "*perf*" --since "1 week ago"

                # Export for further analysis and automation
                $ gh comment list 123 --author "all-reviewers*" --since "quarter-start" --quiet | process-review-data.sh
                $ gh comment list 123 --ids-only --type review --status open | review-metrics.sh
        `),
        Args: cobra.MaximumNArgs(1),
        RunE: runList,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(listCmd)

        // Legacy flags (kept for backward compatibility)
        listCmd.Flags().BoolVar(&amp;showResolved, "resolved", false, "Include resolved comments (legacy, use --status instead)")
        listCmd.Flags().BoolVar(&amp;onlyUnresolved, "unresolved", false, "Show only unresolved comments (legacy, use --status instead)")

        // Enhanced filtering flags
        listCmd.Flags().StringVar(&amp;author, "author", "", "Filter comments by author (supports wildcards: 'user*', '*@company.com')")
        listCmd.Flags().StringVar(&amp;status, "status", "all", "Filter by comment status: open, resolved, all")
        listCmd.Flags().StringVar(&amp;since, "since", "", "Show comments created after date (e.g., '2024-01-01', '1 week ago', '3 days ago')")
        listCmd.Flags().StringVar(&amp;until, "until", "", "Show comments created before date (e.g., '2024-12-31', '1 day ago')")
        listCmd.Flags().StringVar(&amp;resolved, "resolved-status", "", "Filter by resolution status: pending, resolved, dismissed")
        listCmd.Flags().StringVar(&amp;listType, "type", "all", "Filter by comment type: issue, review, all")

        // Display options
        listCmd.Flags().BoolVarP(&amp;quiet, "quiet", "q", false, "Minimal output without URLs and IDs (default shows full context for AI)")
        listCmd.Flags().BoolVar(&amp;hideAuthors, "hide-authors", false, "Hide author names for privacy")

        // Output format options
        listCmd.Flags().StringVar(&amp;outputFormat, "format", "default", "Output format: default, json")
        listCmd.Flags().BoolVar(&amp;idsOnly, "ids-only", false, "Output only comment IDs (one per line)")
}</span>

func runList(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if listClient == nil </span><span class="cov8" title="1">{
                client, err := createGitHubClient()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to initialize GitHub client: %w", err)
                }</span>
                <span class="cov8" title="1">listClient = client</span>
        }

        // Validate and parse filtering flags
        <span class="cov8" title="1">if err := validateAndParseFilters(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">var pr int
        var repository string
        var err error

        // Parse PR argument using centralized function
        if len(args) == 1 </span><span class="cov8" title="1">{
                pr, err = parsePositiveInt(args[0], "PR number")
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                // Get repository for explicitly provided PR
                <span class="cov8" title="1">repository, err = getCurrentRepo()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                // Auto-detect PR and repository using centralized function
                repository, pr, err = getPRContext()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if verbose </span><span class="cov8" title="1">{
                fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("PR: %d\n", pr)
                fmt.Printf("Show resolved: %v\n", showResolved)
                fmt.Printf("Only unresolved: %v\n", onlyUnresolved)
                fmt.Printf("Quiet mode: %v\n", quiet)
                fmt.Printf("Hide authors: %v\n", hideAuthors)
                if author != "" </span><span class="cov8" title="1">{
                        fmt.Printf("Filter by author: %s\n", author)
                }</span>
                <span class="cov8" title="1">fmt.Println()</span>
        }

        // Fetch comments
        <span class="cov8" title="1">comments, err := fetchAllComments(listClient, repository, pr)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Filter comments
        <span class="cov8" title="1">filteredComments := filterComments(comments)

        // Handle different output formats
        if idsOnly </span><span class="cov0" title="0">{
                displayIDsOnly(filteredComments)
        }</span> else<span class="cov8" title="1"> if outputFormat == "json" </span><span class="cov0" title="0">{
                if err := displayCommentsJSON(filteredComments, pr); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to encode JSON output: %w", err)
                }</span>
        } else<span class="cov8" title="1"> {
                displayComments(filteredComments, pr)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

type Comment struct {
        ID        int       `json:"id"`
        Author    string    `json:"author"`
        Body      string    `json:"body"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
        HTMLURL   string    `json:"html_url"`

        // For line-specific comments
        Path      string `json:"path,omitempty"`
        Line      int    `json:"line,omitempty"`
        StartLine int    `json:"start_line,omitempty"`
        DiffHunk  string `json:"diff_hunk,omitempty"`
        CommitID  string `json:"commit_id,omitempty"`

        // Comment type
        Type string `json:"type"` // "issue" or "review"

        // Resolution status (for review comments)
        State string `json:"state,omitempty"` // "pending", "submitted", etc.
}

func fetchAllComments(client github.GitHubAPI, repo string, pr int) ([]Comment, error) <span class="cov8" title="1">{
        // Parse owner/repo
        parts := strings.Split(repo, "/")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid repository format: %s (expected owner/repo)", repo)
        }</span>
        <span class="cov8" title="1">owner, repoName := parts[0], parts[1]

        var allComments []Comment

        // Fetch general PR comments (issue comments)
        issueComments, err := client.ListIssueComments(owner, repoName, pr)
        if err != nil </span><span class="cov8" title="1">{
                return nil, formatActionableError("issue comments fetch", err)
        }</span>

        // Convert issue comments
        <span class="cov8" title="1">for _, comment := range issueComments </span><span class="cov8" title="1">{
                allComments = append(allComments, Comment{
                        ID:        comment.ID,
                        Author:    comment.User.Login,
                        Body:      comment.Body,
                        CreatedAt: comment.CreatedAt,
                        UpdatedAt: comment.UpdatedAt,
                        HTMLURL:   "", // TODO: Add HTMLURL to github.Comment
                        Type:      "issue",
                })
        }</span>

        // Fetch review comments (line-specific)
        <span class="cov8" title="1">reviewComments, err := client.ListReviewComments(owner, repoName, pr)
        if err != nil </span><span class="cov8" title="1">{
                return nil, formatActionableError("review comments fetch", err)
        }</span>

        // Convert review comments
        <span class="cov8" title="1">for _, comment := range reviewComments </span><span class="cov8" title="1">{
                allComments = append(allComments, Comment{
                        ID:        comment.ID,
                        Author:    comment.User.Login,
                        Body:      comment.Body,
                        CreatedAt: comment.CreatedAt,
                        UpdatedAt: comment.UpdatedAt,
                        HTMLURL:   "", // TODO: Add HTMLURL to github.Comment
                        Path:      comment.Path,
                        Line:      comment.Line,
                        CommitID:  comment.CommitID,
                        Type:      "review",
                })
        }</span>

        <span class="cov8" title="1">return allComments, nil</span>
}

func validateAndParseFilters() error <span class="cov8" title="1">{
        // Validate status flag
        validStatuses := []string{"all", "open", "resolved"}
        if status != "" &amp;&amp; !containsString(validStatuses, status) </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid status '%s'. Must be one of: %s", status, strings.Join(validStatuses, ", "))
        }</span>

        // Validate comment type flag
        <span class="cov8" title="1">validTypes := []string{"all", "issue", "review"}
        if listType != "" &amp;&amp; !containsString(validTypes, listType) </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid type '%s'. Must be one of: %s", listType, strings.Join(validTypes, ", "))
        }</span>

        // Validate output format flag
        <span class="cov8" title="1">validFormats := []string{"default", "json"}
        if outputFormat != "" &amp;&amp; !containsString(validFormats, outputFormat) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid format '%s'. Must be one of: %s", outputFormat, strings.Join(validFormats, ", "))
        }</span>

        // Handle conflicting output options
        <span class="cov8" title="1">if idsOnly &amp;&amp; outputFormat == "json" </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot use --ids-only with --format json (use --format json to get structured data including IDs)")
        }</span>

        // Parse since date
        <span class="cov8" title="1">if since != "" </span><span class="cov8" title="1">{
                parsedTime, err := parseFlexibleDate(since)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid since date '%s': %w", since, err)
                }</span>
                <span class="cov8" title="1">sinceTime = &amp;parsedTime</span>
        }

        // Parse until date
        <span class="cov8" title="1">if until != "" </span><span class="cov8" title="1">{
                parsedTime, err := parseFlexibleDate(until)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid until date '%s': %w", until, err)
                }</span>
                <span class="cov8" title="1">untilTime = &amp;parsedTime</span>
        }

        // Validate date range
        <span class="cov8" title="1">if sinceTime != nil &amp;&amp; untilTime != nil &amp;&amp; sinceTime.After(*untilTime) </span><span class="cov8" title="1">{
                return fmt.Errorf("since date (%s) cannot be after until date (%s)", since, until)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func parseFlexibleDate(dateStr string) (time.Time, error) <span class="cov8" title="1">{
        parsed, err := dateparser.Parse(nil, strings.TrimSpace(dateStr))
        if err != nil </span><span class="cov8" title="1">{
                return time.Time{}, err
        }</span>
        <span class="cov8" title="1">return parsed.Time, nil</span>
}

func filterComments(comments []Comment) []Comment <span class="cov8" title="1">{
        var filtered []Comment

        for _, comment := range comments </span><span class="cov8" title="1">{
                // Filter by author (supports wildcards)
                if author != "" &amp;&amp; !matchesAuthorFilter(comment.Author, author) </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Filter by comment type
                <span class="cov8" title="1">if listType != "all" &amp;&amp; comment.Type != listType </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Filter by status (legacy support)
                <span class="cov8" title="1">if showResolved &amp;&amp; onlyUnresolved </span>{<span class="cov0" title="0">
                        // Conflicting flags - show all
                }</span> else<span class="cov8" title="1"> if onlyUnresolved </span><span class="cov0" title="0">{
                        // Only show unresolved comments (this is a placeholder - actual resolution status would come from API)
                        // For now, we'll consider all comments as "open" since we don't have resolution data
                        if status == "resolved" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                } else<span class="cov8" title="1"> if !showResolved </span><span class="cov8" title="1">{
                        // Default behavior - don't show resolved comments
                        if status == "resolved" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                // Filter by new status flag
                <span class="cov8" title="1">if status != "all" </span><span class="cov0" title="0">{
                        // This is a placeholder for actual resolution status filtering
                        // In a real implementation, you'd check comment.ResolvedAt or similar
                        // For now, we'll treat all comments as "open"
                        if status == "resolved" </span><span class="cov0" title="0">{
                                continue</span> // Skip since we don't have resolution data yet
                        }
                }

                // Filter by date range
                <span class="cov8" title="1">if sinceTime != nil &amp;&amp; comment.CreatedAt.Before(*sinceTime) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if untilTime != nil &amp;&amp; comment.CreatedAt.After(*untilTime) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">filtered = append(filtered, comment)</span>
        }

        <span class="cov8" title="1">return filtered</span>
}

func matchesAuthorFilter(author, filter string) bool <span class="cov8" title="1">{
        // Exact match
        if author == filter </span><span class="cov8" title="1">{
                return true
        }</span>

        // Wildcard matching
        <span class="cov8" title="1">if strings.Contains(filter, "*") </span><span class="cov8" title="1">{
                // Convert wildcard pattern to regex
                pattern := strings.ReplaceAll(regexp.QuoteMeta(filter), `\*`, `.*`)
                pattern = "^" + pattern + "$"

                if matched, err := regexp.MatchString(pattern, author); err == nil &amp;&amp; matched </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        // Case-insensitive partial match
        <span class="cov8" title="1">return strings.Contains(strings.ToLower(author), strings.ToLower(filter))</span>
}

func containsString(slice []string, item string) bool <span class="cov8" title="1">{
        for _, s := range slice </span><span class="cov8" title="1">{
                if s == item </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func displayComments(comments []Comment, pr int) <span class="cov8" title="1">{
        if len(comments) == 0 </span><span class="cov8" title="1">{
                fmt.Printf("No comments found on PR #%d\n", pr)
                return
        }</span>

        // Collect unique commit IDs for summary
        <span class="cov8" title="1">commitIDs := make(map[string]bool)
        for _, comment := range comments </span><span class="cov8" title="1">{
                if comment.CommitID != "" </span><span class="cov0" title="0">{
                        commitIDs[comment.CommitID] = true
                }</span>
        }

        <span class="cov8" title="1">fmt.Printf("ðŸ“ Comments on PR #%d (%d total", pr, len(comments))
        if len(commitIDs) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf(", %d commit", len(commitIDs))
                if len(commitIDs) != 1 </span><span class="cov0" title="0">{
                        fmt.Printf("s")
                }</span>
        }
        <span class="cov8" title="1">fmt.Printf(")\n\n")

        // Group comments by type
        var issueComments, reviewComments, lineComments []Comment
        for _, comment := range comments </span><span class="cov8" title="1">{

                if comment.Type == "issue" </span><span class="cov8" title="1">{
                        issueComments = append(issueComments, comment)
                }</span> else<span class="cov0" title="0"> if comment.Type == "review" </span><span class="cov0" title="0">{
                        reviewComments = append(reviewComments, comment)
                }</span> else<span class="cov0" title="0"> {
                        lineComments = append(lineComments, comment)
                }</span>
        }

        // Display general PR comments
        <span class="cov8" title="1">if len(issueComments) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf("ðŸ’¬ General PR Comments (%d)\n", len(issueComments))
                fmt.Println(strings.Repeat("â”€", 50))
                for i, comment := range issueComments </span><span class="cov8" title="1">{
                        displayComment(comment, i+1)
                }</span>
                <span class="cov8" title="1">fmt.Println()</span>
        }

        // Display review-level comments (parent comments that group line-specific ones)
        <span class="cov8" title="1">if len(reviewComments) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("ðŸ“‹ Review Comments (%d)\n", len(reviewComments))
                fmt.Println(strings.Repeat("â”€", 50))
                for i, comment := range reviewComments </span><span class="cov0" title="0">{
                        displayComment(comment, i+1)
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        // Display line-specific comments
        <span class="cov8" title="1">if len(lineComments) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("ðŸ“ Line-Specific Comments (%d)\n", len(lineComments))
                fmt.Println(strings.Repeat("â”€", 50))
                for i, comment := range lineComments </span><span class="cov0" title="0">{
                        displayComment(comment, i+1)
                }</span>
        }
}

func displayComment(comment Comment, index int) <span class="cov8" title="1">{
        // Header with author and timestamp
        timeAgo := formatTimeAgo(comment.CreatedAt)
        if hideAuthors </span><span class="cov8" title="1">{
                fmt.Printf("[%d] ID:%d ðŸ‘¤ [hidden] â€¢ %s", index, comment.ID, timeAgo)
        }</span> else<span class="cov8" title="1"> {
                fmt.Printf("[%d] ID:%d ðŸ‘¤ %s â€¢ %s", index, comment.ID, comment.Author, timeAgo)
        }</span>

        // Show review state for review-level comments
        <span class="cov8" title="1">if comment.Type == "review" &amp;&amp; comment.State != "" </span><span class="cov0" title="0">{
                stateEmoji := "ðŸ“"
                switch comment.State </span>{
                case "approved":<span class="cov0" title="0">
                        stateEmoji = "âœ…"</span>
                case "changes_requested":<span class="cov0" title="0">
                        stateEmoji = "ðŸ”´"</span>
                case "commented":<span class="cov0" title="0">
                        stateEmoji = "ðŸ’¬"</span>
                }
                <span class="cov0" title="0">fmt.Printf(" %s %s", stateEmoji, comment.State)</span>
        }
        <span class="cov8" title="1">fmt.Println()

        // File and line info for line-specific comments
        if comment.Path != "" </span><span class="cov8" title="1">{
                lineInfo := fmt.Sprintf("L%d", comment.Line)
                if comment.StartLine &gt; 0 &amp;&amp; comment.StartLine != comment.Line </span><span class="cov0" title="0">{
                        lineInfo = fmt.Sprintf("L%d-L%d", comment.StartLine, comment.Line)
                }</span>
                <span class="cov8" title="1">fmt.Printf("ðŸ“ %s:%s", comment.Path, lineInfo)

                // Show commit ID for review comments (helps with debugging and understanding)
                if comment.CommitID != "" </span><span class="cov0" title="0">{
                        fmt.Printf(" â€¢ ðŸ“Š %s", comment.CommitID[:8]) // Show first 8 chars of commit SHA
                }</span>
                <span class="cov8" title="1">fmt.Println()

                // Show the actual diff context if available
                if comment.DiffHunk != "" </span><span class="cov0" title="0">{
                        fmt.Printf("ðŸ“ Code Context:\n")
                        displayDiffHunk(comment.DiffHunk)
                }</span>
        }

        // Comment body (truncate if too long)
        <span class="cov8" title="1">body := strings.TrimSpace(comment.Body)
        if len(body) &gt; 200 </span><span class="cov0" title="0">{
                body = body[:197] + "..."
        }</span>

        // Indent the comment body
        <span class="cov8" title="1">lines := strings.Split(body, "\n")
        for _, line := range lines </span><span class="cov8" title="1">{
                fmt.Printf("   %s\n", line)
        }</span>

        // Show URLs by default (AI-friendly), hide only in quiet mode
        <span class="cov8" title="1">if !quiet </span><span class="cov8" title="1">{
                fmt.Printf("   ðŸ”— %s\n", comment.HTMLURL)
        }</span>

        <span class="cov8" title="1">fmt.Println()</span>
}

func formatTimeAgo(t time.Time) string <span class="cov8" title="1">{
        now := time.Now()
        diff := now.Sub(t)

        if diff &lt; time.Minute </span><span class="cov8" title="1">{
                return "just now"
        }</span> else<span class="cov8" title="1"> if diff &lt; time.Hour </span><span class="cov8" title="1">{
                minutes := int(diff.Minutes())
                if minutes == 1 </span><span class="cov8" title="1">{
                        return "1 minute ago"
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%d minutes ago", minutes)</span>
        } else<span class="cov8" title="1"> if diff &lt; 24*time.Hour </span><span class="cov8" title="1">{
                hours := int(diff.Hours())
                if hours == 1 </span><span class="cov8" title="1">{
                        return "1 hour ago"
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%d hours ago", hours)</span>
        } else<span class="cov8" title="1"> {
                days := int(diff.Hours() / 24)
                if days == 1 </span><span class="cov8" title="1">{
                        return "1 day ago"
                }</span> else<span class="cov8" title="1"> if days &lt; 7 </span><span class="cov8" title="1">{
                        return fmt.Sprintf("%d days ago", days)
                }</span> else<span class="cov8" title="1"> {
                        return t.Format("Jan 2, 2006")
                }</span>
        }
}

func displayDiffHunk(diffHunk string) <span class="cov8" title="1">{
        // Split diff hunk into lines
        lines := strings.Split(strings.TrimSpace(diffHunk), "\n")

        for _, line := range lines </span><span class="cov8" title="1">{
                if line == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Color code the diff lines
                <span class="cov8" title="1">if strings.HasPrefix(line, "@@") </span><span class="cov8" title="1">{
                        // Diff header - show line numbers
                        fmt.Printf("   ðŸ”¹ %s\n", line)
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(line, "+") </span><span class="cov8" title="1">{
                        // Added line - green
                        fmt.Printf("   âž• %s\n", line)
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(line, "-") </span><span class="cov8" title="1">{
                        // Removed line - red
                        fmt.Printf("   âž– %s\n", line)
                }</span> else<span class="cov8" title="1"> {
                        // Context line - neutral
                        fmt.Printf("     %s\n", line)
                }</span>
        }
        <span class="cov8" title="1">fmt.Println()</span>
}

// displayIDsOnly outputs only comment IDs, one per line
func displayIDsOnly(comments []Comment) <span class="cov0" title="0">{
        for _, comment := range comments </span><span class="cov0" title="0">{
                fmt.Printf("%d\n", comment.ID)
        }</span>
}

// displayCommentsJSON outputs comments as JSON
func displayCommentsJSON(comments []Comment, pr int) error <span class="cov0" title="0">{
        output := struct {
                PR       int       `json:"pr"`
                Total    int       `json:"total"`
                Comments []Comment `json:"comments"`
        }{
                PR:       pr,
                Total:    len(comments),
                Comments: comments,
        }

        encoder := json.NewEncoder(os.Stdout)
        encoder.SetIndent("", "  ")
        return encoder.Encode(output)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package cmd

import (
        "bytes"
        "embed"
        "fmt"
        "io/fs"
        "strings"

        "github.com/MakeNowJust/heredoc"
        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"
)

var (
        promptCategory string
        listPrompts    bool
)

//go:embed prompts/**/*.md
var promptFiles embed.FS

var promptsCmd = &amp;cobra.Command{
        Use:   "prompts [prompt-name]",
        Short: "Get AI-powered code review prompts and best practices",
        Long: heredoc.Doc(`
                Access a curated collection of professional code review prompts optimized
                for AI assistants like Claude, ChatGPT, and other automated workflows.

                These prompts follow research-backed best practices for effective code
                review communication, including psychological safety principles and
                the CREG emoji system (ðŸ”§ðŸ¤”â™»ï¸ðŸ“ðŸ˜ƒðŸ“Œ).

                Perfect for: Senior developers, code review leads, QA teams, and AI
                assistants who need sophisticated review templates beyond basic feedback.
        `),
        Example: heredoc.Doc(`
                # List all available prompts
                $ gh comment prompts --list

                # Get specific security review prompt
                $ gh comment prompts security-audit

                # List prompts by category
                $ gh comment prompts --category performance --list

                # Get performance optimization prompt
                $ gh comment prompts performance-optimization

                # Security-focused review prompt
                $ gh comment prompts security-comprehensive

                # Architecture review prompt
                $ gh comment prompts architecture-review
        `),
        Args: cobra.MaximumNArgs(1),
        RunE: runPrompts,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(promptsCmd)

        promptsCmd.Flags().StringVar(&amp;promptCategory, "category", "", "Filter prompts by category: security, performance, architecture, quality, ai")
        promptsCmd.Flags().BoolVar(&amp;listPrompts, "list", false, "List available prompts")
}</span>

func runPrompts(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        if listPrompts </span><span class="cov0" title="0">{
                return listAvailablePrompts()
        }</span>

        <span class="cov0" title="0">if len(args) == 0 </span><span class="cov0" title="0">{
                return listAvailablePrompts()
        }</span>

        <span class="cov0" title="0">promptName := args[0]
        prompt, exists := getPrompt(promptName)
        if !exists </span><span class="cov0" title="0">{
                fmt.Printf("âŒ Prompt '%s' not found.\n\n", promptName)
                fmt.Println("Available prompts:")
                return listAvailablePrompts()
        }</span>

        <span class="cov0" title="0">fmt.Printf("ðŸ“‹ **%s**\n\n", prompt.Title)
        fmt.Printf("ðŸŽ¯ **Category**: %s\n", prompt.Category)
        fmt.Printf("â±ï¸  **Estimated Time**: %s\n\n", prompt.EstimatedTime)

        fmt.Println("ðŸ“ **Prompt:**")
        fmt.Println("```")
        fmt.Println(prompt.Content)
        fmt.Println("```")

        if len(prompt.Examples) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("\nðŸ’¡ **Example Usage:**")
                for _, example := range prompt.Examples </span><span class="cov0" title="0">{
                        fmt.Printf("â€¢ %s\n", example)
                }</span>
        }

        <span class="cov0" title="0">if len(prompt.Tags) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\nðŸ·ï¸  **Tags**: %s\n", strings.Join(prompt.Tags, ", "))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type Prompt struct {
        Name          string
        Title         string
        Category      string
        Content       string
        Examples      []string
        Tags          []string
        EstimatedTime string
}

type PromptMetadata struct {
        Name          string   `yaml:"name"`
        Title         string   `yaml:"title"`
        Category      string   `yaml:"category"`
        EstimatedTime string   `yaml:"estimated_time"`
        Tags          []string `yaml:"tags"`
        Examples      []string `yaml:"examples"`
}

func getPrompt(name string) (Prompt, bool) <span class="cov8" title="1">{
        prompts := getAllPrompts()
        prompt, exists := prompts[name]
        return prompt, exists
}</span>

func listAvailablePrompts() error <span class="cov0" title="0">{
        prompts := getAllPrompts()

        if promptCategory != "" </span><span class="cov0" title="0">{
                fmt.Printf("ðŸ“‹ **Code Review Prompts - %s Category**\n\n", strings.Title(promptCategory))
        }</span> else<span class="cov0" title="0"> {
                fmt.Print("ðŸ“‹ **Available Code Review Prompts**\n\n")
        }</span>

        <span class="cov0" title="0">categories := make(map[string][]Prompt)
        for _, prompt := range prompts </span><span class="cov0" title="0">{
                if promptCategory != "" &amp;&amp; prompt.Category != promptCategory </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">categories[prompt.Category] = append(categories[prompt.Category], prompt)</span>
        }

        <span class="cov0" title="0">for category, categoryPrompts := range categories </span><span class="cov0" title="0">{
                fmt.Printf("## %s\n", strings.Title(category))
                for _, prompt := range categoryPrompts </span><span class="cov0" title="0">{
                        fmt.Printf("  **%s** - %s (%s)\n", prompt.Name, prompt.Title, prompt.EstimatedTime)
                        fmt.Printf("    %s\n", strings.Join(prompt.Tags, " â€¢ "))
                }</span>
                <span class="cov0" title="0">fmt.Print("\n")</span>
        }

        <span class="cov0" title="0">fmt.Println("ðŸ’¡ **Usage**: `gh comment prompts &lt;prompt-name&gt;` to get the full prompt")
        return nil</span>
}

func getAllPrompts() map[string]Prompt <span class="cov8" title="1">{
        prompts := make(map[string]Prompt)

        // Walk through all markdown files in the prompts directory
        fs.WalkDir(promptFiles, ".", func(path string, d fs.DirEntry, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Only process .md files
                <span class="cov8" title="1">if !strings.HasSuffix(path, ".md") </span><span class="cov8" title="1">{
                        return nil
                }</span>

                // Read the markdown file
                <span class="cov8" title="1">content, err := promptFiles.ReadFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Parse the markdown file with frontmatter
                <span class="cov8" title="1">prompt, err := parseMarkdownPrompt(content)
                if err != nil </span><span class="cov0" title="0">{
                        // Skip files that can't be parsed, but continue processing others
                        return nil
                }</span>

                <span class="cov8" title="1">prompts[prompt.Name] = prompt
                return nil</span>
        })

        <span class="cov8" title="1">return prompts</span>
}

func parseMarkdownPrompt(content []byte) (Prompt, error) <span class="cov8" title="1">{
        // Split frontmatter and content
        parts := bytes.SplitN(content, []byte("---"), 3)
        if len(parts) &lt; 3 </span><span class="cov0" title="0">{
                return Prompt{}, fmt.Errorf("invalid markdown format: missing frontmatter")
        }</span>

        // Parse YAML frontmatter
        <span class="cov8" title="1">var metadata PromptMetadata
        if err := yaml.Unmarshal(parts[1], &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return Prompt{}, fmt.Errorf("failed to parse frontmatter: %w", err)
        }</span>

        // Extract markdown content (remove leading/trailing whitespace)
        <span class="cov8" title="1">markdownContent := strings.TrimSpace(string(parts[2]))

        return Prompt{
                Name:          metadata.Name,
                Title:         metadata.Title,
                Category:      metadata.Category,
                Content:       markdownContent,
                Examples:      metadata.Examples,
                Tags:          metadata.Tags,
                EstimatedTime: metadata.EstimatedTime,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package cmd

import (
        "fmt"
        "strings"

        "github.com/MakeNowJust/heredoc"
        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
)

var (
        removeReactionFlag bool

        // Client for dependency injection (tests can override)
        reactClient github.GitHubAPI
)

var reactCmd = &amp;cobra.Command{
        Use:   "react &lt;comment-id&gt; &lt;emoji&gt;",
        Short: "Add or remove emoji reactions to comments",
        Long: heredoc.Doc(`
                Add or remove emoji reactions to any comment type.

                Supports both issue comments and review comments automatically.
                Comment type is auto-detected from the comment ID.

                Available reactions: +1, -1, laugh, confused, heart, hooray, rocket, eyes

                Comment IDs can be found in the output of 'gh comment list'.
        `),
        Example: heredoc.Doc(`
                # Add reactions to any comment type
                $ gh comment react 123456 +1
                $ gh comment react 789012 heart
                $ gh comment react 999999 rocket

                # Remove reactions
                $ gh comment react 123456 +1 --remove
                $ gh comment react 789012 heart --remove

                # Works with both issue and review comments automatically
                $ gh comment react 123456 eyes    # Works for issue comments
                $ gh comment react 789012 hooray  # Works for review comments
        `),
        Args: cobra.ExactArgs(2),
        RunE: runReact,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(reactCmd)

        reactCmd.Flags().BoolVar(&amp;removeReactionFlag, "remove", false, "Remove reaction instead of adding it")
}</span>

func runReact(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if reactClient == nil </span><span class="cov8" title="1">{
                client, err := createGitHubClient()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create GitHub client: %w", err)
                }</span>
                <span class="cov8" title="1">reactClient = client</span>
        }

        // Parse comment ID
        <span class="cov8" title="1">commentIDStr := args[0]
        commentID, err := parsePositiveInt(commentIDStr, "comment ID")
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Get reaction emoji
        <span class="cov8" title="1">reaction := args[1]

        // Validate reaction
        if !validateReaction(reaction) </span><span class="cov8" title="1">{
                return formatValidationError("reaction", reaction, "must be one of: +1, -1, laugh, confused, heart, hooray, rocket, eyes")
        }</span>

        // Get repository context
        <span class="cov8" title="1">repository, prNumber, err := getPRContext()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Parse owner/repo
        <span class="cov8" title="1">parts := strings.Split(repository, "/")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid repository format: %s (expected owner/repo)", repository)
        }</span>
        <span class="cov8" title="1">owner, repoName := parts[0], parts[1]

        if verbose </span><span class="cov0" title="0">{
                fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("Comment ID: %d\n", commentID)
                fmt.Printf("Reaction: %s\n", reaction)
                if removeReactionFlag </span><span class="cov0" title="0">{
                        fmt.Printf("Action: Remove reaction\n")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Action: Add reaction\n")
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        <span class="cov8" title="1">if dryRun </span><span class="cov0" title="0">{
                action := "add"
                if removeReactionFlag </span><span class="cov0" title="0">{
                        action = "remove"
                }</span>
                <span class="cov0" title="0">fmt.Printf("Would %s %s reaction %s comment #%d\n", action, reaction,
                        map[bool]string{true: "from", false: "to"}[removeReactionFlag], commentID)
                return nil</span>
        }

        // Perform the reaction action
        <span class="cov8" title="1">if removeReactionFlag </span><span class="cov8" title="1">{
                err = reactClient.RemoveReaction(owner, repoName, commentID, prNumber, reaction)
                if err != nil </span><span class="cov0" title="0">{
                        return formatActionableError("reaction removal", err)
                }</span>
                <span class="cov8" title="1">fmt.Printf("âœ… Removed %s reaction from comment #%d\n", reaction, commentID)</span>
        } else<span class="cov8" title="1"> {
                err = reactClient.AddReaction(owner, repoName, commentID, prNumber, reaction)
                if err != nil </span><span class="cov8" title="1">{
                        return formatActionableError("reaction addition", err)
                }</span>
                <span class="cov8" title="1">fmt.Printf("âœ… Added %s reaction to comment #%d\n", reaction, commentID)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func validateReaction(reaction string) bool <span class="cov8" title="1">{
        validReactions := []string{"+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"}
        for _, valid := range validReactions </span><span class="cov8" title="1">{
                if reaction == valid </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package cmd

import (
        "fmt"
        "strings"

        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
)

var (
        // Client for dependency injection (tests can override)
        resolveClient github.GitHubAPI
)

var resolveCmd = &amp;cobra.Command{
        Use:   "resolve &lt;comment-id&gt;",
        Short: "Resolve a conversation thread",
        Long: `Resolve a conversation thread for a pull request review comment.

This marks the conversation as resolved, indicating that the feedback
has been addressed. Use the comment ID from 'gh comment list' output.

Examples:
  # Resolve a conversation
  gh comment resolve 2246362251

  # Resolve with dry-run
  gh comment resolve --dry-run 2246362251`,
        Args: cobra.ExactArgs(1),
        RunE: runResolve,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(resolveCmd)
}</span>

func runResolve(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if resolveClient == nil </span><span class="cov0" title="0">{
                client, err := createGitHubClient()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create GitHub client: %w", err)
                }</span>
                <span class="cov0" title="0">resolveClient = client</span>
        }

        // Parse comment ID
        <span class="cov8" title="1">commentID, err := parsePositiveInt(args[0], "comment ID")
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Get repository and PR context
        <span class="cov8" title="1">repository, pr, err := getPRContext()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Parse owner/repo
        <span class="cov8" title="1">parts := strings.Split(repository, "/")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid repository format: %s (expected owner/repo)", repository)
        }</span>
        <span class="cov8" title="1">owner, repoName := parts[0], parts[1]

        if verbose </span><span class="cov8" title="1">{
                fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("PR Number: %d\n", pr)
                fmt.Printf("Comment ID: %d\n", commentID)
                fmt.Println()
        }</span>

        <span class="cov8" title="1">if dryRun </span><span class="cov8" title="1">{
                fmt.Printf("Would resolve conversation for comment #%d in PR #%d\n", commentID, pr)
                return nil
        }</span>

        // Find the review thread for this comment
        <span class="cov8" title="1">threadID, err := resolveClient.FindReviewThreadForComment(owner, repoName, pr, commentID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to find review thread for comment: %w", err)
        }</span>

        // Resolve the review thread
        <span class="cov8" title="1">err = resolveClient.ResolveReviewThread(threadID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to resolve conversation: %w", err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("âœ… Resolved conversation for comment #%d\n", commentID)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package cmd

import (
        "fmt"
        "strings"

        "github.com/MakeNowJust/heredoc"
        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
)

var (
        resolveConversationReviewReply bool
        noExpandSuggestionsReviewReply bool

        // Client for dependency injection (tests can override)
        reviewReplyClient github.GitHubAPI
)

var reviewReplyCmd = &amp;cobra.Command{
        Use:   "review-reply &lt;comment-id&gt; [message]",
        Short: "Reply to a review comment with a text message",
        Long: heredoc.Doc(`
                Reply to an existing review comment with a text message.

                This command is specifically for review comment threading - replying to
                line-specific comments that appear in the "Files Changed" tab. Review
                comment threading has limited GitHub API support.

                For general PR discussion, use 'gh comment add' instead.
                For emoji reactions, use 'gh comment react' command.

                Comment IDs can be found in the output of 'gh comment list'.
        `),
        Example: heredoc.Doc(`
                # Reply to review comment with message
                $ gh comment review-reply 789012 "Fixed this issue"

                # Reply and resolve conversation in one operation
                $ gh comment review-reply 789012 "Addressed your feedback" --resolve

                # Just resolve conversation without adding message
                $ gh comment review-reply 789012 --resolve

                # For general PR discussion, use add command instead:
                # $ gh comment add 123 "Thanks for the review!"

                # For emoji reactions, use react command instead:
                # $ gh comment react 789012 +1
        `),
        Args: cobra.RangeArgs(1, 2),
        RunE: runReviewReply,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(reviewReplyCmd)

        reviewReplyCmd.Flags().BoolVar(&amp;resolveConversationReviewReply, "resolve", false, "Resolve the conversation after replying")
        reviewReplyCmd.Flags().BoolVar(&amp;noExpandSuggestionsReviewReply, "no-expand-suggestions", false, "Disable automatic expansion of [SUGGEST:] and &lt;&lt;&lt;SUGGEST&gt;&gt;&gt; syntax")
}</span>

func runReviewReply(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if reviewReplyClient == nil </span><span class="cov0" title="0">{
                client, err := createGitHubClient()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create GitHub client: %w", err)
                }</span>
                <span class="cov0" title="0">reviewReplyClient = client</span>
        }

        // Parse comment ID
        <span class="cov8" title="1">commentIDStr := args[0]
        commentID, err := parsePositiveInt(commentIDStr, "comment ID")
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Get message if provided
        <span class="cov8" title="1">var message string
        if len(args) &gt; 1 </span><span class="cov8" title="1">{
                message = args[1]
        }</span>

        // Validate that we have either message or resolve
        <span class="cov8" title="1">if message == "" &amp;&amp; !resolveConversationReviewReply </span><span class="cov8" title="1">{
                return fmt.Errorf("must provide either a message or --resolve")
        }</span>

        // Get repository context
        <span class="cov8" title="1">repository, prNumber, err := getPRContext()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Parse owner/repo
        <span class="cov8" title="1">parts := strings.Split(repository, "/")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid repository format: %s (expected owner/repo)", repository)
        }</span>
        <span class="cov8" title="1">owner, repoName := parts[0], parts[1]

        if verbose </span><span class="cov0" title="0">{
                fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("Comment ID: %d\n", commentID)
                fmt.Printf("Comment Type: review\n")
                if message != "" </span><span class="cov0" title="0">{
                        fmt.Printf("Message: %s\n", message)
                }</span>
                <span class="cov0" title="0">if resolveConversationReviewReply </span><span class="cov0" title="0">{
                        fmt.Printf("Resolve Conversation: true\n")
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        <span class="cov8" title="1">if dryRun </span><span class="cov0" title="0">{
                fmt.Printf("Would reply to review comment #%d:\n", commentID)
                if message != "" </span><span class="cov0" title="0">{
                        fmt.Printf("Message: %s\n", message)
                }</span>
                <span class="cov0" title="0">if resolveConversationReviewReply </span><span class="cov0" title="0">{
                        fmt.Printf("Resolve Conversation: true\n")
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Handle message reply
        <span class="cov8" title="1">if message != "" </span><span class="cov8" title="1">{
                // Expand suggestions if enabled
                if !noExpandSuggestionsReviewReply </span><span class="cov8" title="1">{
                        message = expandSuggestions(message)
                }</span>

                // Reply to review comment
                <span class="cov8" title="1">_, err = reviewReplyClient.CreateReviewCommentReply(owner, repoName, commentID, message)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create reply: %w", err)
                }</span>
                <span class="cov8" title="1">fmt.Printf("âœ… Replied to review comment #%d: %s\n", commentID, message)</span>
        }

        // Handle resolve conversation
        <span class="cov8" title="1">if resolveConversationReviewReply </span><span class="cov8" title="1">{
                // Find the thread ID for this comment
                threadID, err := reviewReplyClient.FindReviewThreadForComment(owner, repoName, prNumber, commentID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to find review thread: %w", err)
                }</span>

                // Resolve the thread
                <span class="cov8" title="1">err = reviewReplyClient.ResolveReviewThread(threadID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to resolve conversation: %w", err)
                }</span>
                <span class="cov8" title="1">fmt.Printf("âœ… Resolved conversation for review comment #%d\n", commentID)</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package cmd

import (
        "fmt"
        "sort"
        "strconv"
        "strings"

        "github.com/MakeNowJust/heredoc"
        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
)

var (
        // Client for dependency injection (tests can override)
        reviewClient github.GitHubAPI

        // Review-specific flags
        reviewEventFlag    string
        reviewCommentsFlag []string
)

var reviewCmd = &amp;cobra.Command{
        Use:   "review &lt;pr&gt; &lt;body&gt;",
        Short: "Create a code review with line-specific comments",
        Long: heredoc.Doc(`
                Create a code review with multiple line-specific comments attached to code.

                This command creates review comments that appear in the "Files Changed" tab,
                attached to specific lines or ranges. Perfect for comprehensive code reviews
                where you want to comment on multiple code locations and submit a review
                decision (APPROVE/REQUEST_CHANGES/COMMENT) in one operation.

                For general PR discussion comments, use: 'gh comment add'
        `),
        Example: heredoc.Doc(`
                # Security-focused comprehensive review
                $ gh comment review 123 "Security audit complete - critical issues found" \
                  --comment auth.go:67:"Use crypto.randomBytes(32) instead of Math.random() for token generation" \
                  --comment api.js:134:140:"This endpoint lacks rate limiting - vulnerable to DoS attacks" \
                  --comment validation.js:25:"Input sanitization missing - SQL injection risk" \
                  --event REQUEST_CHANGES

                # Performance optimization review
                $ gh comment review 123 "Performance review - optimization opportunities identified" \
                  --comment database.py:89:95:"Extract this N+1 query to a single batch operation" \
                  --comment cache.js:156:"Consider Redis clustering for this high-traffic endpoint" \
                  --comment monitoring.go:78:"Add performance metrics for this critical path" \
                  --event COMMENT

                # Architecture migration approval
                $ gh comment review 123 "Migration to microservices architecture approved" \
                  --comment service-layer.js:45:"Excellent separation of concerns in the new service layer" \
                  --comment api-gateway.go:123:130:"API gateway implementation follows best practices" \
                  --comment docker-compose.yml:67:"Container orchestration setup looks solid" \
                  --event APPROVE

                # Code quality and maintainability review
                $ gh comment review 123 "Code quality review - refactoring needed" \
                  --comment legacy-handler.js:200:250:"This function is doing too much - extract into separate services" \
                  --comment utils.go:45:"Consider using dependency injection pattern here" \
                  --comment test-helpers.js:89:"Add integration tests for this critical business logic" \
                  --event REQUEST_CHANGES
        `),
        Args: cobra.RangeArgs(1, 2),
        RunE: runReview,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(reviewCmd)
        reviewCmd.Flags().StringVar(&amp;reviewEventFlag, "event", "COMMENT", "Review event: APPROVE, REQUEST_CHANGES, or COMMENT")
        reviewCmd.Flags().StringArrayVar(&amp;reviewCommentsFlag, "comment", []string{}, "Add comment in format file:line:message or file:start:end:message (also supports start-end)")
}</span>

func runReview(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if reviewClient == nil </span><span class="cov0" title="0">{
                client, err := createGitHubClient()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create GitHub client: %w", err)
                }</span>
                <span class="cov0" title="0">reviewClient = client</span>
        }

        <span class="cov8" title="1">var pr int
        var body string
        var err error

        // Parse arguments
        if len(args) == 2 </span><span class="cov8" title="1">{
                // PR number and body provided
                pr, err = strconv.Atoi(args[0])
                if err != nil </span><span class="cov8" title="1">{
                        return formatValidationError("PR number", args[0], "must be a valid integer")
                }</span>
                <span class="cov8" title="1">body = args[1]</span>
        } else<span class="cov8" title="1"> if len(args) == 1 </span><span class="cov8" title="1">{
                // Check if it's a PR number or review body
                if prNum, err := strconv.Atoi(args[0]); err == nil </span><span class="cov8" title="1">{
                        // It's a PR number
                        pr = prNum
                }</span> else<span class="cov8" title="1"> {
                        // It's a review body, auto-detect PR
                        _, pr, err = getPRContext()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">body = args[0]</span>
                }
        }

        // Validate event type
        <span class="cov8" title="1">validEvents := []string{"APPROVE", "REQUEST_CHANGES", "COMMENT"}
        isValidEvent := false
        for _, validEvent := range validEvents </span><span class="cov8" title="1">{
                if reviewEventFlag == validEvent </span><span class="cov8" title="1">{
                        isValidEvent = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !isValidEvent </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid event type: %s (must be APPROVE, REQUEST_CHANGES, or COMMENT)", reviewEventFlag)
        }</span>

        // Validate that we have either a body or comments
        <span class="cov8" title="1">if body == "" &amp;&amp; len(reviewCommentsFlag) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("review must have either a body message or comments (use --comment)")
        }</span>

        // Get repository context
        <span class="cov8" title="1">repository, err := getCurrentRepo()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get repository: %w", err)
        }</span>

        // If PR number wasn't parsed from args, try to auto-detect it
        <span class="cov8" title="1">if pr == 0 </span><span class="cov0" title="0">{
                if prNumber &gt; 0 </span><span class="cov0" title="0">{
                        pr = prNumber
                }</span> else<span class="cov0" title="0"> {
                        detectedPR, err := getCurrentPR()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to detect PR number: %w (try specifying --pr)", err)
                        }</span>
                        <span class="cov0" title="0">pr = detectedPR</span>
                }
        }

        // Parse owner/repo
        <span class="cov8" title="1">parts := strings.Split(repository, "/")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid repository format: %s (expected owner/repo)", repository)
        }</span>
        <span class="cov8" title="1">owner, repoName := parts[0], parts[1]

        // Parse and validate review comments first (before dry run)
        var reviewCommentInputs []github.ReviewCommentInput
        for i, commentSpec := range reviewCommentsFlag </span><span class="cov8" title="1">{
                commentInput, err := parseReviewCommentSpec(commentSpec)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid comment %d (%s): %w", i+1, commentSpec, err)
                }</span>

                // Validate line exists in diff if validation is enabled
                <span class="cov8" title="1">if validateDiff </span><span class="cov8" title="1">{
                        if err := validateCommentLine(reviewClient, owner, repoName, pr, commentInput); err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("comment %d validation failed (%s): %w", i+1, commentSpec, err)
                        }</span>
                }

                <span class="cov8" title="1">reviewCommentInputs = append(reviewCommentInputs, commentInput)</span>
        }

        <span class="cov8" title="1">if verbose </span><span class="cov8" title="1">{
                fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("PR: %d\n", pr)
                fmt.Printf("Review body: %s\n", body)
                fmt.Printf("Review event: %s\n", reviewEventFlag)
                fmt.Printf("Comments: %d\n", len(reviewCommentsFlag))
                fmt.Println()
        }</span>

        <span class="cov8" title="1">if dryRun </span><span class="cov8" title="1">{
                fmt.Printf("Would create review on PR #%d:\n", pr)
                fmt.Printf("Body: %s\n", body)
                fmt.Printf("Event: %s\n", reviewEventFlag)
                fmt.Printf("Comments: %d\n", len(reviewCommentsFlag))
                for i, comment := range reviewCommentsFlag </span><span class="cov8" title="1">{
                        fmt.Printf("  %d. %s\n", i+1, comment)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        // Create the review
        <span class="cov8" title="1">review := github.ReviewInput{
                Body:     body,
                Event:    reviewEventFlag,
                Comments: reviewCommentInputs,
        }

        err = reviewClient.CreateReview(owner, repoName, pr, review)
        if err != nil </span><span class="cov0" title="0">{
                return formatActionableError("review creation", err)
        }</span>

        // Display success message
        <span class="cov8" title="1">eventText := ""
        switch reviewEventFlag </span>{
        case "APPROVE":<span class="cov8" title="1">
                eventText = "approved"</span>
        case "REQUEST_CHANGES":<span class="cov8" title="1">
                eventText = "requested changes"</span>
        case "COMMENT":<span class="cov8" title="1">
                eventText = "commented on"</span>
        }

        <span class="cov8" title="1">fmt.Printf("âœ… Successfully created review and %s PR #%d", eventText, pr)
        if len(reviewCommentInputs) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf(" with %d comments", len(reviewCommentInputs))
        }</span>
        <span class="cov8" title="1">fmt.Println()

        return nil</span>
}

// parseReviewCommentSpec parses a comment specification in the format:
// file:line:message or file:start:end:message
func parseReviewCommentSpec(spec string) (github.ReviewCommentInput, error) <span class="cov8" title="1">{
        // Handle quoted messages properly
        var filePath, lineSpec, message string

        // Check if message is quoted
        if strings.Contains(spec, ":'") &amp;&amp; strings.HasSuffix(spec, "'") </span><span class="cov0" title="0">{
                // Message is quoted with single quotes
                quoteIndex := strings.Index(spec, ":'")
                message = spec[quoteIndex+2 : len(spec)-1] // Remove :' and trailing '
                fileAndLine := spec[:quoteIndex]

                // Split file and line
                lastColonIndex := strings.LastIndex(fileAndLine, ":")
                if lastColonIndex == -1 </span><span class="cov0" title="0">{
                        return github.ReviewCommentInput{}, fmt.Errorf("format must be file:line:message or file:start:end:message")
                }</span>
                <span class="cov0" title="0">filePath = fileAndLine[:lastColonIndex]
                lineSpec = fileAndLine[lastColonIndex+1:]</span>
        } else<span class="cov8" title="1"> if strings.Contains(spec, ":\"") &amp;&amp; strings.HasSuffix(spec, "\"") </span><span class="cov0" title="0">{
                // Message is quoted with double quotes
                quoteIndex := strings.Index(spec, ":\"")
                message = spec[quoteIndex+2 : len(spec)-1] // Remove :" and trailing "
                fileAndLine := spec[:quoteIndex]

                // Split file and line
                lastColonIndex := strings.LastIndex(fileAndLine, ":")
                if lastColonIndex == -1 </span><span class="cov0" title="0">{
                        return github.ReviewCommentInput{}, fmt.Errorf("format must be file:line:message or file:start:end:message")
                }</span>
                <span class="cov0" title="0">filePath = fileAndLine[:lastColonIndex]
                lineSpec = fileAndLine[lastColonIndex+1:]</span>
        } else<span class="cov8" title="1"> {
                // Message is not quoted, use the old logic
                // Try to parse as range format first
                colonCount := strings.Count(spec, ":")
                if colonCount &gt;= 3 </span><span class="cov8" title="1">{
                        // Try file:start:end:message format
                        parts := strings.SplitN(spec, ":", 4)
                        if len(parts) == 4 </span><span class="cov8" title="1">{
                                // Check if parts[1] and parts[2] are both numbers
                                if _, err1 := strconv.Atoi(parts[1]); err1 == nil </span><span class="cov8" title="1">{
                                        if _, err2 := strconv.Atoi(parts[2]); err2 == nil </span><span class="cov8" title="1">{
                                                // Valid range format
                                                filePath = parts[0]
                                                lineSpec = parts[1] + ":" + parts[2]
                                                message = parts[3]
                                        }</span>
                                }
                        }
                }

                // If not range format, try simple format
                <span class="cov8" title="1">if filePath == "" </span><span class="cov8" title="1">{
                        parts := strings.SplitN(spec, ":", 3)
                        if len(parts) &lt; 3 </span><span class="cov8" title="1">{
                                return github.ReviewCommentInput{}, fmt.Errorf("format must be file:line:message or file:start:end:message")
                        }</span>
                        <span class="cov8" title="1">filePath = parts[0]
                        lineSpec = parts[1]
                        message = strings.Join(parts[2:], ":")</span>
                }
        }

        <span class="cov8" title="1">if filePath == "" </span><span class="cov8" title="1">{
                return github.ReviewCommentInput{}, fmt.Errorf("file path cannot be empty")
        }</span>
        <span class="cov8" title="1">if message == "" </span><span class="cov8" title="1">{
                return github.ReviewCommentInput{}, fmt.Errorf("message cannot be empty")
        }</span>

        <span class="cov8" title="1">comment := github.ReviewCommentInput{
                Body: expandSuggestions(message),
                Path: filePath,
                Side: "RIGHT", // Default to RIGHT side (additions/new lines)
        }

        // Parse line specification (single line or range)
        if strings.Contains(lineSpec, "-") || strings.Contains(lineSpec, ":") </span><span class="cov8" title="1">{
                // Range format: start-end or start:end
                var rangeParts []string
                if strings.Contains(lineSpec, "-") </span><span class="cov8" title="1">{
                        rangeParts = strings.Split(lineSpec, "-")
                }</span> else<span class="cov8" title="1"> {
                        rangeParts = strings.Split(lineSpec, ":")
                }</span>
                <span class="cov8" title="1">if len(rangeParts) != 2 </span><span class="cov8" title="1">{
                        return github.ReviewCommentInput{}, fmt.Errorf("range format must be start-end or start:end")
                }</span>

                <span class="cov8" title="1">startLine, err := strconv.Atoi(strings.TrimSpace(rangeParts[0]))
                if err != nil </span><span class="cov8" title="1">{
                        return github.ReviewCommentInput{}, fmt.Errorf("invalid start line: %w", err)
                }</span>

                <span class="cov8" title="1">endLine, err := strconv.Atoi(strings.TrimSpace(rangeParts[1]))
                if err != nil </span><span class="cov8" title="1">{
                        return github.ReviewCommentInput{}, fmt.Errorf("invalid end line: %w", err)
                }</span>

                <span class="cov8" title="1">if startLine &lt;= 0 || endLine &lt;= 0 </span><span class="cov8" title="1">{
                        return github.ReviewCommentInput{}, fmt.Errorf("line numbers must be positive")
                }</span>

                <span class="cov8" title="1">if startLine &gt; endLine </span><span class="cov8" title="1">{
                        return github.ReviewCommentInput{}, fmt.Errorf("start line (%d) cannot be greater than end line (%d)", startLine, endLine)
                }</span>

                <span class="cov8" title="1">comment.StartLine = startLine
                comment.Line = endLine</span>
        } else<span class="cov8" title="1"> {
                // Single line format
                line, err := strconv.Atoi(lineSpec)
                if err != nil </span><span class="cov8" title="1">{
                        return github.ReviewCommentInput{}, fmt.Errorf("invalid line number: %w", err)
                }</span>

                <span class="cov8" title="1">if line &lt;= 0 </span><span class="cov8" title="1">{
                        return github.ReviewCommentInput{}, fmt.Errorf("line number must be positive")
                }</span>

                <span class="cov8" title="1">comment.Line = line</span>
        }

        <span class="cov8" title="1">return comment, nil</span>
}

// validateCommentLine validates that the line(s) specified in a review comment exist in the PR diff
func validateCommentLine(client github.GitHubAPI, owner, repo string, pr int, comment github.ReviewCommentInput) error <span class="cov8" title="1">{
        // Fetch PR diff
        diff, err := client.FetchPRDiff(owner, repo, pr)
        if err != nil </span><span class="cov0" title="0">{
                // If we can't fetch the diff, skip validation rather than blocking the comment
                if verbose </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: Could not fetch PR diff for validation: %v\n", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Find the requested file in the diff
        <span class="cov8" title="1">var targetFile *github.DiffFile
        for i := range diff.Files </span><span class="cov8" title="1">{
                if diff.Files[i].Filename == comment.Path </span><span class="cov8" title="1">{
                        targetFile = &amp;diff.Files[i]
                        break</span>
                }
        }

        <span class="cov8" title="1">if targetFile == nil </span><span class="cov8" title="1">{
                // Build helpful error message with available files
                var availableFiles []string
                for _, file := range diff.Files </span><span class="cov8" title="1">{
                        availableFiles = append(availableFiles, file.Filename)
                }</span>

                <span class="cov8" title="1">errorMsg := fmt.Sprintf("file '%s' not found in PR #%d diff", comment.Path, pr)
                if len(availableFiles) &gt; 0 </span><span class="cov8" title="1">{
                        errorMsg += "\n\nðŸ’¡ Available files in this PR:\n"
                        for _, filename := range availableFiles </span><span class="cov8" title="1">{
                                errorMsg += fmt.Sprintf("  â€¢ %s\n", filename)
                        }</span>
                        <span class="cov8" title="1">errorMsg += fmt.Sprintf("\nTip: Use 'gh comment lines %d &lt;file&gt;' to see commentable lines", pr)</span>
                }
                <span class="cov8" title="1">return fmt.Errorf("%s", errorMsg)</span>
        }

        // Validate line numbers exist in the diff
        <span class="cov8" title="1">var linesToCheck []int
        if comment.StartLine &gt; 0 </span><span class="cov8" title="1">{
                // Range comment: check all lines from StartLine to Line
                for line := comment.StartLine; line &lt;= comment.Line; line++ </span><span class="cov8" title="1">{
                        linesToCheck = append(linesToCheck, line)
                }</span>
        } else<span class="cov8" title="1"> {
                // Single line comment
                linesToCheck = []int{comment.Line}
        }</span>

        <span class="cov8" title="1">var invalidLines []int
        for _, line := range linesToCheck </span><span class="cov8" title="1">{
                if !targetFile.Lines[line] </span><span class="cov8" title="1">{
                        invalidLines = append(invalidLines, line)
                }</span>
        }

        <span class="cov8" title="1">if len(invalidLines) &gt; 0 </span><span class="cov8" title="1">{
                // Build helpful error message with available lines
                var availableLines []int
                for lineNum := range targetFile.Lines </span><span class="cov8" title="1">{
                        availableLines = append(availableLines, lineNum)
                }</span>

                // Sort available lines for better display
                <span class="cov8" title="1">sort.Ints(availableLines)

                // Group consecutive lines for cleaner display
                ranges := groupConsecutiveLines(availableLines)

                var rangeStrings []string
                for _, r := range ranges </span><span class="cov8" title="1">{
                        if r.start == r.end </span><span class="cov0" title="0">{
                                rangeStrings = append(rangeStrings, fmt.Sprintf("%d", r.start))
                        }</span> else<span class="cov8" title="1"> {
                                rangeStrings = append(rangeStrings, fmt.Sprintf("%d-%d", r.start, r.end))
                        }</span>
                }

                <span class="cov8" title="1">errorMsg := fmt.Sprintf("line(s) %v do not exist in diff for file '%s'", invalidLines, comment.Path)
                if len(availableLines) &gt; 0 </span><span class="cov8" title="1">{
                        errorMsg += fmt.Sprintf("\n\nðŸ’¡ Available lines for comments: %s", strings.Join(rangeStrings, ", "))
                        errorMsg += fmt.Sprintf("\n\nTip: Use 'gh comment lines %d %s' to see detailed line information", pr, comment.Path)
                }</span> else<span class="cov0" title="0"> {
                        errorMsg += fmt.Sprintf("\n\nðŸ’¡ No commentable lines found in '%s' - file may not have changes in this PR", comment.Path)
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("%s", errorMsg)</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package cmd

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/MakeNowJust/heredoc"
        "github.com/cli/go-gh/v2"
        "github.com/spf13/cobra"
)

var (
        // Global flags
        prNumber     int
        repo         string
        validateDiff bool
        dryRun       bool
        verbose      bool
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &amp;cobra.Command{
        Use:   "gh-comment",
        Short: "Strategic GitHub PR commenting and review management",
        Long: heredoc.Doc(`
                gh-comment provides professional-grade tools for GitHub pull request
                comment management, systematic code reviews, and review process automation.

                Designed for developers, code review leads, and teams who need sophisticated
                comment workflows beyond GitHub's web interface capabilities.

                Comment Types:
                â€¢ Issue comments: General PR discussion, appear in main conversation tab
                â€¢ Review comments: Line-specific feedback, appear in "Files Changed" tab

                Strategic GitHub PR Commenting - Beyond the Web Interface:

                gh-comment is designed for professional code review workflows that require:
                â€¢ Systematic line-by-line code analysis with context
                â€¢ Bulk comment operations for comprehensive reviews
                â€¢ Advanced filtering for comment analysis and metrics
                â€¢ Automation integration for CI/CD review processes
                â€¢ Data export for review process optimization

                Perfect for: Senior developers, code review leads, QA teams, and DevOps engineers
                who need sophisticated comment management beyond GitHub's web interface.
        `),
        Example: heredoc.Doc(`
                Commands:
                  add                     Add general PR discussion comments
                  close-pending-review    Submit GUI-created pending reviews
                  edit                    Modify existing comments
                  list                    List and filter comments with advanced options
                  react                   Add or remove emoji reactions to comments
                  reply                   Reply to comments with text messages
                  resolve                 Resolve conversation threads
                  review                  Create line-specific code reviews
                  help                    Help about any command

                Global Flags:
                  -p, --pr int        PR number (auto-detect from branch if omitted)
                  -R, --repo string   Repository (owner/repo format)
                      --dry-run       Show what would be commented without executing
                  -v, --verbose       Show detailed API interactions
                      --validate      Validate line exists in diff before commenting (default true)

                Filtering Flags (list command):
                      --author string     Filter by author (supports wildcards: 'user*')
                      --since string      Show comments after date ('2024-01-01', '1 week ago')
                      --until string      Show comments before date
                      --status string     Filter by status: open, resolved, all
                      --type string       Filter by type: issue, review, all
                  -q, --quiet            Minimal output for scripts

                Review Flags:
                      --event string      Review event: APPROVE, REQUEST_CHANGES, COMMENT
                      --comment strings   Add comments: file:line:message

                Examples:
                # Basic Operations
                $ gh comment list 123                           List all comments on PR #123
                $ gh comment add 123 "Looks good overall!"     Add general discussion comment

                # Issue Comments (General PR Discussion)
                $ gh comment add 123 "LGTM! Just waiting for CI to pass"
                $ gh comment add 123 "Thanks for addressing the security concerns"
                $ gh comment reply 12345 "Good point, I'll make those changes"

                # Review Comments (Line-Specific Code Feedback)
                $ gh comment review 123 "Code review complete" \
                  --comment src/api.js:42:"Add rate limiting middleware" \
                  --comment auth.go:15:25:"Refactor for OAuth2 compliance" \
                  --event REQUEST_CHANGES

                # Advanced Filtering (Power User Features)
                $ gh comment list 123 --author "senior-dev*" --status open --since "1 week ago"
                $ gh comment list 123 --type review --author "*@company.com" --since "deployment-date"
                $ gh comment list 123 --status resolved --until "2024-01-01" --quiet

                # Review Workflows (Professional Code Review)
                $ gh comment review 123 "Migration review complete" \
                  --comment src/api.js:42:"Add rate limiting middleware" \
                  --comment src/auth.js:15:20:"Update to OAuth2 flow" \
                  --comment tests/api_test.go:100:"Add edge case tests" \
                  --event REQUEST_CHANGES

                $ gh comment add-review 123 "Security audit findings" \
                  --comment auth.go:67:"Use crypto.randomBytes(32) for tokens" \
                  --comment api.js:134:140:"Extract business logic to service layer"

                # Batch Operations (Systematic Reviews)
                $ gh comment batch 123 review-config.yaml
                $ gh comment batch 456 security-checklist.yaml --dry-run
                $ gh comment batch 789 bulk-comments.yaml --verbose

                # Conversation Management
                $ gh comment reply 2246362251 "Fixed in commit abc123" --resolve
                $ gh comment react 3141344022 +1
                $ gh comment react 2246362251 rocket
                $ gh comment react 3141344022 heart --remove
                $ gh comment resolve --thread 2246362251 --reason "Addressed in latest commit"

                # Data Export &amp; Analysis (Automation)
                $ gh comment list 123 --quiet | grep "ðŸ‘¤" | cut -d' ' -f2 | sort | uniq -c
                $ gh comment list 123 --since "2024-01-01" --quiet | tee q1-review-data.txt
                $ gh comment list 123 --author "qa-team*" --quiet | analyze-feedback.py

                # Automation &amp; CI Integration
                $ gh comment add 123 src/security.js 67 "[SUGGEST: use crypto.randomBytes(32)]"
                $ for file in $(git diff --name-only); do gh comment add 123 "$file" 1 "Auto-generated security scan results"; done
                $ gh comment list --since "deployment-date" --type review --status open | review-blocker-analysis.sh

                # Advanced Comment Management
                $ gh comment edit 2246362251 "Updated: This rate limiting logic handles concurrent requests properly"
                $ gh comment list 123 --author "bot*" --quiet | grep "ID:" | cut -d':' -f2 | xargs -I {} gh comment resolve {}
                $ gh comment add 123 performance.js 89:95 "Consider caching this expensive calculation"
        `),
        Version: "1.0.0",
}

// Execute adds all child commands to the root command and sets flags appropriately.
func Execute() error <span class="cov8" title="1">{
        return rootCmd.Execute()
}</span>

func init() <span class="cov8" title="1">{
        // Global flags
        rootCmd.PersistentFlags().IntVarP(&amp;prNumber, "pr", "p", 0, "PR number (auto-detect from branch if omitted)")
        rootCmd.PersistentFlags().StringVarP(&amp;repo, "repo", "R", "", "Repository (owner/repo format)")

        rootCmd.PersistentFlags().BoolVar(&amp;validateDiff, "validate", true, "Validate line exists in diff before commenting")
        rootCmd.PersistentFlags().BoolVar(&amp;dryRun, "dry-run", false, "Show what would be commented without executing")
        rootCmd.PersistentFlags().BoolVarP(&amp;verbose, "verbose", "v", false, "Show detailed API interactions")
}</span>

// Helper function to get current repository if not specified
func getCurrentRepo() (string, error) <span class="cov8" title="1">{
        if repo != "" </span><span class="cov8" title="1">{
                return repo, nil
        }</span>

        // Use gh CLI to get current repository
        <span class="cov0" title="0">stdout, _, err := gh.Exec("repo", "view", "--json", "nameWithOwner", "-q", ".nameWithOwner")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get current repository: %w", err)
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(stdout.String()), nil</span>
}

// Helper function to get current PR number if not specified
func getCurrentPR() (int, error) <span class="cov8" title="1">{
        if prNumber != 0 </span><span class="cov8" title="1">{
                return prNumber, nil
        }</span>

        // Use gh CLI to get PR for current branch
        <span class="cov0" title="0">stdout, _, err := gh.Exec("pr", "view", "--json", "number", "-q", ".number")
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get current PR: %w (try specifying --pr)", err)
        }</span>

        <span class="cov0" title="0">prStr := strings.TrimSpace(stdout.String())
        pr, err := strconv.Atoi(prStr)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid PR number: %s", prStr)
        }</span>

        <span class="cov0" title="0">return pr, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package cmd

import (
        "regexp"
        "strings"
)

// expandSuggestions processes inline suggestion syntax and converts to GitHub markdown
func expandSuggestions(message string) string <span class="cov8" title="1">{
        // First handle multi-line suggestions: &lt;&lt;&lt;SUGGEST\ncode\nSUGGEST&gt;&gt;&gt;
        message = expandMultilineSuggestions(message)

        // Then handle inline suggestions: [SUGGEST: code]
        message = expandInlineSuggestions(message)

        return message
}</span>

// expandInlineSuggestions handles [SUGGEST: code] syntax
func expandInlineSuggestions(message string) string <span class="cov8" title="1">{
        // Use a more sophisticated approach to handle nested brackets
        result := message
        for </span><span class="cov8" title="1">{
                start := strings.Index(result, "[SUGGEST:")
                if start == -1 </span><span class="cov8" title="1">{
                        break</span> // No more suggestions found
                }

                // Find the matching closing bracket by counting bracket depth
                <span class="cov8" title="1">bracketCount := 0
                suggestStart := start + len("[SUGGEST:")
                end := -1

                for i := suggestStart; i &lt; len(result); i++ </span><span class="cov8" title="1">{
                        char := result[i]
                        if char == '[' </span><span class="cov8" title="1">{
                                bracketCount++
                        }</span> else<span class="cov8" title="1"> if char == ']' </span><span class="cov8" title="1">{
                                if bracketCount == 0 </span><span class="cov8" title="1">{
                                        end = i
                                        break</span>
                                }
                                <span class="cov8" title="1">bracketCount--</span>
                        }
                }

                <span class="cov8" title="1">if end == -1 </span><span class="cov8" title="1">{
                        break</span> // No matching closing bracket found
                }

                // Extract the code part and trim whitespace
                <span class="cov8" title="1">code := strings.TrimSpace(result[suggestStart:end])

                // Replace the [SUGGEST: code] with GitHub suggestion syntax
                replacement := "\n\n```suggestion\n" + code + "\n```\n\n"

                // Replace this occurrence and continue searching
                result = result[:start] + replacement + result[end+1:]</span>
        }

        <span class="cov8" title="1">return result</span>
}

// expandMultilineSuggestions handles &lt;&lt;&lt;SUGGEST\ncode\nSUGGEST&gt;&gt;&gt; syntax
func expandMultilineSuggestions(message string) string <span class="cov8" title="1">{
        // Regex to match &lt;&lt;&lt;SUGGEST...code...SUGGEST&gt;&gt;&gt; blocks (with flexible whitespace)
        re := regexp.MustCompile(`(?s)&lt;&lt;&lt;SUGGEST\s*\n(.*?)\nSUGGEST&gt;&gt;&gt;`)

        return re.ReplaceAllStringFunc(message, func(match string) string </span><span class="cov8" title="1">{
                // Extract the code part
                submatches := re.FindStringSubmatch(match)
                if len(submatches) &lt; 2 </span><span class="cov0" title="0">{
                        return match // Return original if parsing fails
                }</span>

                <span class="cov8" title="1">code := strings.TrimSpace(submatches[1])
                return "\n\n```suggestion\n" + code + "\n```\n\n"</span>
        })
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
