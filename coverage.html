
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/silouanwright/gh-comment/cmd/add.go (66.2%)</option>
				
				<option value="file1">github.com/silouanwright/gh-comment/cmd/batch.go (82.2%)</option>
				
				<option value="file2">github.com/silouanwright/gh-comment/cmd/client_helper.go (100.0%)</option>
				
				<option value="file3">github.com/silouanwright/gh-comment/cmd/close-pending-review.go (90.4%)</option>
				
				<option value="file4">github.com/silouanwright/gh-comment/cmd/colors.go (96.9%)</option>
				
				<option value="file5">github.com/silouanwright/gh-comment/cmd/config.go (91.0%)</option>
				
				<option value="file6">github.com/silouanwright/gh-comment/cmd/config_command.go (88.3%)</option>
				
				<option value="file7">github.com/silouanwright/gh-comment/cmd/edit.go (80.5%)</option>
				
				<option value="file8">github.com/silouanwright/gh-comment/cmd/export.go (84.9%)</option>
				
				<option value="file9">github.com/silouanwright/gh-comment/cmd/helpers.go (88.2%)</option>
				
				<option value="file10">github.com/silouanwright/gh-comment/cmd/integration_testing.go (65.0%)</option>
				
				<option value="file11">github.com/silouanwright/gh-comment/cmd/lines.go (89.2%)</option>
				
				<option value="file12">github.com/silouanwright/gh-comment/cmd/list.go (88.9%)</option>
				
				<option value="file13">github.com/silouanwright/gh-comment/cmd/prompts.go (92.9%)</option>
				
				<option value="file14">github.com/silouanwright/gh-comment/cmd/react.go (68.0%)</option>
				
				<option value="file15">github.com/silouanwright/gh-comment/cmd/resolve.go (84.4%)</option>
				
				<option value="file16">github.com/silouanwright/gh-comment/cmd/review-reply.go (59.0%)</option>
				
				<option value="file17">github.com/silouanwright/gh-comment/cmd/review.go (81.7%)</option>
				
				<option value="file18">github.com/silouanwright/gh-comment/cmd/root.go (76.2%)</option>
				
				<option value="file19">github.com/silouanwright/gh-comment/cmd/suggestions.go (98.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "fmt"
        "strings"

        "github.com/MakeNowJust/heredoc"
        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
)

var (
        messages            []string
        noExpandSuggestions bool

        // Client for dependency injection (tests can override)
        addClient github.GitHubAPI
)

var addCmd = &amp;cobra.Command{
        Use:   "add [pr] &lt;comment&gt;",
        Short: "Add a general discussion comment to a pull request",
        Long: heredoc.Doc(`
                Add a general discussion comment to a pull request conversation.

                This command creates issue-style comments that appear in the main PR conversation,
                not attached to specific code lines. These comments support threaded replies
                and are perfect for general discussion, approval, or high-level feedback.

                For line-specific code review comments, use: 'gh comment review'

                The comment message supports GitHub markdown formatting and can include
                code suggestions using the [SUGGEST: code] syntax. Use offset syntax
                [SUGGEST:+N: code] for lines below or [SUGGEST:-N: code] for lines above.
        `),
        Example: heredoc.Doc(`
                # General PR discussion comments
                $ gh comment add 123 "LGTM! Just a few minor suggestions below"
                $ gh comment add 123 "Thanks for addressing the security concerns"
                $ gh comment add 123 "This looks great - ready to merge after CI passes"

                # Multi-line comments with --message flags
                $ gh comment add 123 -m "Overall this is excellent work!" -m "The architecture is clean and the tests are comprehensive"

                # Auto-detect PR from current branch
                $ gh comment add "Looks good to merge!"

                # Approval with context
                $ gh comment add 123 "Approved! The performance improvements in this PR will make a huge difference"

                # Request for changes with discussion
                $ gh comment add 123 "Could you address the failing tests? Otherwise looks good to go"

                # Comments with suggestion syntax (auto-expands to GitHub suggestion blocks)
                $ gh comment add 123 "Consider using async/await: [SUGGEST: const result = await fetchData();]"
                $ gh comment add 123 "Add error handling above: [SUGGEST:-1: try {]"
                $ gh comment add 123 "Add timeout below: [SUGGEST:+2: const timeout = 5000;]"
        `),
        Args: cobra.RangeArgs(1, 2),
        RunE: runAdd,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(addCmd)
        addCmd.Flags().StringArrayVarP(&amp;messages, "message", "m", []string{}, "Add message (can be used multiple times for multi-line comments) (default: empty)")
        addCmd.Flags().BoolVar(&amp;noExpandSuggestions, "no-expand-suggestions", false, "Disable automatic expansion of [SUGGEST:] and &lt;&lt;&lt;SUGGEST&gt;&gt;&gt; syntax (default: false)")
}</span>

func runAdd(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if addClient == nil </span><span class="cov0" title="0">{
                client, err := createGitHubClient()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to initialize GitHub client: %w", err)
                }</span>
                <span class="cov0" title="0">addClient = client</span>
        }

        <span class="cov8" title="1">var pr int
        var repository string
        var comment string
        var err error

        // Parse arguments for general PR comments
        if len(messages) &gt; 0 </span><span class="cov8" title="1">{
                // Using --message flags
                if len(args) == 1 </span><span class="cov8" title="1">{
                        // PR provided + --message flags
                        pr, err = parsePositiveInt(args[0], "PR number")
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        // Get repository for explicitly provided PR
                        <span class="cov8" title="1">repository, err = getCurrentRepo()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Validate repository name
                        <span class="cov8" title="1">if err := validateRepositoryName(repository); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov8" title="1"> if len(args) == 0 </span><span class="cov0" title="0">{
                        // Auto-detect PR + --message flags using centralized function
                        repository, pr, err = getPRContext()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Validate repository name
                        <span class="cov0" title="0">if err := validateRepositoryName(repository); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov8" title="1"> {
                        return fmt.Errorf("invalid arguments when using --message flags: expected [pr] or no args")
                }</span>
                <span class="cov8" title="1">comment = strings.Join(messages, "\n")</span>
        } else<span class="cov8" title="1"> if len(args) == 2 </span><span class="cov8" title="1">{
                // PR number provided + comment
                pr, err = parsePositiveInt(args[0], "PR number")
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">comment = args[1]
                // Get repository for explicitly provided PR
                repository, err = getCurrentRepo()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Validate repository name
                <span class="cov8" title="1">if err := validateRepositoryName(repository); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> if len(args) == 1 </span><span class="cov8" title="1">{
                // Auto-detect PR from current branch + comment using centralized function
                repository, pr, err = getPRContext()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Validate repository name
                <span class="cov8" title="1">if err := validateRepositoryName(repository); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">comment = args[0]</span>
        } else<span class="cov8" title="1"> {
                return fmt.Errorf("invalid arguments. Use: gh comment add [pr] &lt;comment&gt; OR gh comment add [pr] --message \"line1\" --message \"line2\"")
        }</span>

        // Validate comment
        <span class="cov8" title="1">if strings.TrimSpace(comment) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("comment cannot be empty")
        }</span>

        // Validate comment body length
        <span class="cov8" title="1">if err := validateCommentBody(comment); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Expand suggestion syntax to GitHub markdown (unless disabled)
        <span class="cov8" title="1">var transformedComment string
        if noExpandSuggestions </span><span class="cov0" title="0">{
                transformedComment = comment
        }</span> else<span class="cov8" title="1"> {
                transformedComment = expandSuggestions(comment)
        }</span>

        <span class="cov8" title="1">if verbose </span><span class="cov0" title="0">{
                fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("PR: %d\n", pr)
                fmt.Printf("Comment type: General discussion\n")
                fmt.Printf("Original comment: %s\n", comment)
                fmt.Printf("Transformed comment: %s\n", transformedComment)
        }</span>

        <span class="cov8" title="1">if dryRun </span><span class="cov0" title="0">{
                fmt.Printf("Would add general comment to PR #%d:\n%s\n", pr, transformedComment)
                return nil
        }</span>

        // Parse owner/repo
        <span class="cov8" title="1">parts := strings.Split(repository, "/")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid repository format: %s (expected owner/repo)", repository)
        }</span>
        <span class="cov8" title="1">owner, repoName := parts[0], parts[1]

        // Create general issue comment (not review comment)
        createdComment, err := addClient.CreateIssueComment(owner, repoName, pr, transformedComment)
        if err != nil </span><span class="cov0" title="0">{
                return formatActionableError("comment creation", err)
        }</span>

        // Success message
        <span class="cov8" title="1">fmt.Printf("✓ Added comment to PR #%d", pr)
        if createdComment != nil &amp;&amp; createdComment.ID != 0 </span><span class="cov8" title="1">{
                fmt.Printf(" (ID: %d)", createdComment.ID)
        }</span>
        <span class="cov8" title="1">fmt.Println()

        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "fmt"
        "io/ioutil"
        "strconv"
        "strings"

        "github.com/MakeNowJust/heredoc"
        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"
)

var (
        // Client for dependency injection (tests can override)
        batchClient github.GitHubAPI
)

// BatchConfig represents the structure of a batch comment configuration file
type BatchConfig struct {
        PR       int             `yaml:"pr,omitempty"`
        Repo     string          `yaml:"repo,omitempty"`
        Review   *ReviewConfig   `yaml:"review,omitempty"`
        Comments []CommentConfig `yaml:"comments,omitempty"`
}

// ReviewConfig represents review-level configuration
type ReviewConfig struct {
        Body  string `yaml:"body,omitempty"`
        Event string `yaml:"event,omitempty"` // APPROVE, REQUEST_CHANGES, COMMENT
}

// CommentConfig represents individual comment configuration
type CommentConfig struct {
        File    string `yaml:"file"`
        Line    int    `yaml:"line,omitempty"`
        Range   string `yaml:"range,omitempty"` // e.g., "10-15"
        Message string `yaml:"message"`
        Type    string `yaml:"type,omitempty"` // "review" or "issue", defaults to "review"
}

var batchCmd = &amp;cobra.Command{
        Use:   "batch &lt;pr&gt; &lt;config-file&gt;",
        Short: "Process multiple comments from a YAML configuration file",
        Long: heredoc.Doc(`
                Process multiple comments, reactions, and reviews from a YAML configuration file.

                This is ideal for bulk operations, automated workflows, or complex review
                scenarios. The config file can specify mixed comment types, create reviews
                with multiple comments, and set up entire review workflows.

                YAML Configuration:
                - Review level: Use 'body' field for review summary
                - Individual comments: Use 'message' field for comment text
                - PR can be specified in file or via command line (CLI takes precedence)
        `),
        Example: heredoc.Doc(`
                # Process comments from config
                $ gh comment batch 123 review-config.yaml

                # Validate config without executing
                $ gh comment batch 123 review-config.yaml --dry-run

                # Use verbose output
                $ gh comment batch 123 review-config.yaml --verbose
        `),
        Args: cobra.ExactArgs(2),
        RunE: runBatch,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(batchCmd)
}</span>

func runBatch(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if batchClient == nil </span><span class="cov0" title="0">{
                client, err := createGitHubClient()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create GitHub client: %w", err)
                }</span>
                <span class="cov0" title="0">batchClient = client</span>
        }

        // Validate and prepare batch configuration
        <span class="cov8" title="1">owner, repoName, pr, config, configFile, err := validateBatchConfig(args)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Handle verbose output and dry run
        <span class="cov8" title="1">isDryRun := processBatchItems(config, configFile, pr)
        if isDryRun </span><span class="cov8" title="1">{
                return nil // Dry run completed successfully
        }</span>

        // Execute the batch processing
        <span class="cov8" title="1">return handleBatchResults(batchClient, owner, repoName, pr, config)</span>
}

// validateBatchConfig handles parsing, validation, and setup of batch configuration
func validateBatchConfig(args []string) (owner, repoName string, pr int, config *BatchConfig, configFile string, err error) <span class="cov8" title="1">{
        // Parse PR number
        prArg := args[0]
        pr, err = strconv.Atoi(prArg)
        if err != nil </span><span class="cov8" title="1">{
                return "", "", 0, nil, "", formatValidationError("PR number", prArg, "must be a valid integer")
        }</span>

        // Read and parse configuration file
        <span class="cov8" title="1">configFile = args[1]
        config, err = readBatchConfig(configFile)
        if err != nil </span><span class="cov8" title="1">{
                return "", "", 0, nil, "", fmt.Errorf("failed to read config file: %w", err)
        }</span>

        // Override PR and repo from config if specified
        <span class="cov8" title="1">if config.PR != 0 </span><span class="cov8" title="1">{
                pr = config.PR
        }</span>

        <span class="cov8" title="1">repository := repo
        if config.Repo != "" </span><span class="cov8" title="1">{
                repository = config.Repo
        }</span>

        // Get repository and PR context if not specified
        <span class="cov8" title="1">if repository == "" </span><span class="cov0" title="0">{
                repository, pr, err = getPRContext()
                if err != nil </span><span class="cov0" title="0">{
                        return "", "", 0, nil, "", err
                }</span>
        }

        // Validate repository name
        <span class="cov8" title="1">if err := validateRepositoryName(repository); err != nil </span><span class="cov8" title="1">{
                return "", "", 0, nil, "", err
        }</span>

        // Parse owner/repo
        <span class="cov8" title="1">parts := strings.Split(repository, "/")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return "", "", 0, nil, "", fmt.Errorf("invalid repository format: %s (expected owner/repo)", repository)
        }</span>
        <span class="cov8" title="1">owner, repoName = parts[0], parts[1]

        return owner, repoName, pr, config, configFile, nil</span>
}

// processBatchItems handles verbose output and dry run logic
// Returns true if this is a dry run (caller should exit), false otherwise
func processBatchItems(config *BatchConfig, configFile string, pr int) bool <span class="cov8" title="1">{
        if verbose </span><span class="cov8" title="1">{
                repository := repo
                if config.Repo != "" </span><span class="cov0" title="0">{
                        repository = config.Repo
                }</span>
                <span class="cov8" title="1">fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("PR: %d\n", pr)
                fmt.Printf("Config file: %s\n", configFile)
                fmt.Printf("Comments to process: %d\n", len(config.Comments))
                if config.Review != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Review event: %s\n", config.Review.Event)
                }</span>
                <span class="cov8" title="1">fmt.Println()</span>
        }

        <span class="cov8" title="1">if dryRun </span><span class="cov8" title="1">{
                fmt.Printf("Would process %d comments from %s on PR #%d:\n", len(config.Comments), configFile, pr)
                for i, comment := range config.Comments </span><span class="cov8" title="1">{
                        fmt.Printf("  %d. %s:%s - %s\n", i+1, comment.File, formatLineOrRange(comment), truncateMessage(comment.Message, MessageTruncateLength))
                }</span>
                <span class="cov8" title="1">if config.Review != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Would create review with event: %s\n", config.Review.Event)
                }</span>
                <span class="cov8" title="1">return true</span> // Indicate dry run was performed
        }

        <span class="cov8" title="1">return false</span>
}

// handleBatchResults executes the final batch processing
func handleBatchResults(client github.GitHubAPI, owner, repoName string, pr int, config *BatchConfig) error <span class="cov8" title="1">{
        return processBatchComments(client, owner, repoName, pr, config)
}</span>

func readBatchConfig(configFile string) (*BatchConfig, error) <span class="cov8" title="1">{
        // Read file
        data, err := ioutil.ReadFile(configFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read file %s: %w", configFile, err)
        }</span>

        // Parse YAML
        <span class="cov8" title="1">var config BatchConfig
        err = yaml.Unmarshal(data, &amp;config)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse YAML: %w", err)
        }</span>

        // Validate configuration
        <span class="cov8" title="1">if len(config.Comments) == 0 &amp;&amp; config.Review == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("configuration must contain either comments or review")
        }</span>

        // Validate comments
        <span class="cov8" title="1">for i, comment := range config.Comments </span><span class="cov8" title="1">{
                if comment.Message == "" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("comment %d: message is required", i+1)
                }</span>

                // Determine comment type (default to review)
                <span class="cov8" title="1">commentType := comment.Type
                if commentType == "" </span><span class="cov8" title="1">{
                        commentType = "review"
                }</span>

                // Validate based on comment type
                <span class="cov8" title="1">if commentType == "review" </span><span class="cov8" title="1">{
                        // Review comments require file and line/range
                        if comment.File == "" </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("comment %d: file is required for review comments", i+1)
                        }</span>
                        <span class="cov8" title="1">if comment.Line == 0 &amp;&amp; comment.Range == "" </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("comment %d: either line or range is required for review comments", i+1)
                        }</span>
                        <span class="cov8" title="1">if comment.Line != 0 &amp;&amp; comment.Range != "" </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("comment %d: cannot specify both line and range", i+1)
                        }</span>
                } else<span class="cov8" title="1"> if commentType == "issue" </span>{<span class="cov8" title="1">
                        // Issue comments don't require file or line
                        // They're general PR discussion comments
                }</span> else<span class="cov8" title="1"> {
                        return nil, fmt.Errorf("comment %d: type must be 'review' or 'issue'", i+1)
                }</span>
        }

        // Validate review if present
        <span class="cov8" title="1">if config.Review != nil </span><span class="cov8" title="1">{
                if config.Review.Event != "" </span><span class="cov8" title="1">{
                        validEvents := []string{"APPROVE", "REQUEST_CHANGES", "COMMENT"}
                        isValid := false
                        for _, validEvent := range validEvents </span><span class="cov8" title="1">{
                                if config.Review.Event == validEvent </span><span class="cov8" title="1">{
                                        isValid = true
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if !isValid </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("review event must be one of: %s", strings.Join(validEvents, ", "))
                        }</span>
                }
        }

        <span class="cov8" title="1">return &amp;config, nil</span>
}

func processBatchComments(client github.GitHubAPI, owner, repo string, pr int, config *BatchConfig) error <span class="cov8" title="1">{
        // If we have a review configuration, create the review with comments
        if config.Review != nil </span><span class="cov8" title="1">{
                return processAsReview(client, owner, repo, pr, config)
        }</span>

        // Otherwise, process comments individually
        <span class="cov8" title="1">return processIndividualComments(client, owner, repo, pr, config.Comments)</span>
}

func processAsReview(client github.GitHubAPI, owner, repo string, pr int, config *BatchConfig) error <span class="cov8" title="1">{
        // Validate and prepare review comments
        reviewComments, err := validateReviewComments(client, owner, repo, pr, config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Build the review input structure
        <span class="cov8" title="1">reviewInput := buildReviewInput(config, reviewComments)

        // Submit the review and handle results
        return submitReviewWithComments(client, owner, repo, pr, reviewInput, len(reviewComments))</span>
}

// validateReviewComments validates review body and converts comments to review comment format
func validateReviewComments(client github.GitHubAPI, owner, repo string, pr int, config *BatchConfig) ([]github.ReviewCommentInput, error) <span class="cov8" title="1">{
        // Validate review body if present
        if config.Review != nil &amp;&amp; config.Review.Body != "" </span><span class="cov8" title="1">{
                if err := validateCommentBody(config.Review.Body); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("review body validation failed: %w", err)
                }</span>
        }

        // Convert comments to review comment format
        <span class="cov8" title="1">var reviewComments []github.ReviewCommentInput

        for _, comment := range config.Comments </span><span class="cov8" title="1">{
                // Validate comment message
                if err := validateCommentBody(comment.Message); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("comment validation failed: %w", err)
                }</span>

                // Validate file path if present
                <span class="cov8" title="1">if comment.File != "" </span><span class="cov8" title="1">{
                        if err := validateFilePath(comment.File); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("file path validation failed: %w", err)
                        }</span>
                }

                <span class="cov8" title="1">if comment.Type == "issue" </span><span class="cov8" title="1">{
                        // Issue comments can't be part of a review, process separately
                        if verbose </span><span class="cov0" title="0">{
                                fmt.Printf("Processing issue comment separately: %s:%s\n", comment.File, formatLineOrRange(comment))
                        }</span>
                        <span class="cov8" title="1">_, err := client.CreateIssueComment(owner, repo, pr, comment.Message)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to create issue comment: %w", err)
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                // Note: GitHub automatically uses the latest commit SHA for review comments

                // Create review comment input
                <span class="cov8" title="1">reviewComment := github.ReviewCommentInput{
                        Body: expandSuggestions(comment.Message),
                        Path: comment.File,
                        Side: "RIGHT", // Default to RIGHT side (additions/new lines)
                }

                // Set line or range
                if comment.Range != "" </span><span class="cov0" title="0">{
                        startLine, endLine, err := parseRange(comment.Range)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid range %s: %w", comment.Range, err)
                        }</span>
                        <span class="cov0" title="0">reviewComment.StartLine = startLine
                        reviewComment.Line = endLine</span>
                } else<span class="cov8" title="1"> {
                        reviewComment.Line = comment.Line
                }</span>

                // Validate line exists in diff if validation is enabled
                <span class="cov8" title="1">if validateDiff </span><span class="cov0" title="0">{
                        if err := validateCommentLine(client, owner, repo, pr, reviewComment); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("review comment validation failed: %w", err)
                        }</span>
                }

                <span class="cov8" title="1">reviewComments = append(reviewComments, reviewComment)</span>
        }

        <span class="cov8" title="1">return reviewComments, nil</span>
}

// buildReviewInput creates the ReviewInput structure with default values
func buildReviewInput(config *BatchConfig, reviewComments []github.ReviewCommentInput) github.ReviewInput <span class="cov8" title="1">{
        reviewInput := github.ReviewInput{
                Body:     config.Review.Body,
                Event:    config.Review.Event,
                Comments: reviewComments,
        }

        if reviewInput.Event == "" </span><span class="cov0" title="0">{
                reviewInput.Event = "COMMENT"
        }</span>

        <span class="cov8" title="1">return reviewInput</span>
}

// submitReviewWithComments submits the review and handles success reporting
func submitReviewWithComments(client github.GitHubAPI, owner, repo string, pr int, reviewInput github.ReviewInput, commentCount int) error <span class="cov8" title="1">{
        err := client.CreateReview(owner, repo, pr, reviewInput)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create review: %w", err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("%s\n", ColorizeSuccess(fmt.Sprintf("Successfully created review with %d comments", commentCount)))
        return nil</span>
}

func processIndividualComments(client github.GitHubAPI, owner, repo string, pr int, comments []CommentConfig) error <span class="cov8" title="1">{
        successCount := 0

        for i, comment := range comments </span><span class="cov8" title="1">{
                // Validate comment message
                if err := validateCommentBody(comment.Message); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("comment %d validation failed: %w", i+1, err)
                }</span>

                // Validate file path if present
                <span class="cov8" title="1">if comment.File != "" </span><span class="cov8" title="1">{
                        if err := validateFilePath(comment.File); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("comment %d file path validation failed: %w", i+1, err)
                        }</span>
                }

                <span class="cov8" title="1">if verbose </span><span class="cov8" title="1">{
                        fmt.Printf("Processing comment %d/%d: %s:%s\n", i+1, len(comments), comment.File, formatLineOrRange(comment))
                }</span>

                <span class="cov8" title="1">commentType := comment.Type
                if commentType == "" </span><span class="cov8" title="1">{
                        commentType = "review" // Default to review comments
                }</span>

                <span class="cov8" title="1">var err error
                if commentType == "issue" </span><span class="cov0" title="0">{
                        _, err = client.CreateIssueComment(owner, repo, pr, expandSuggestions(comment.Message))
                }</span> else<span class="cov8" title="1"> {
                        // For review comments, we need the commit SHA
                        // Note: GitHub automatically uses the latest commit SHA for review comments

                        reviewComment := github.ReviewCommentInput{
                                Body: expandSuggestions(comment.Message),
                                Path: comment.File,
                                Side: "RIGHT", // Default to RIGHT side (additions/new lines)
                        }

                        // Set line or range
                        if comment.Range != "" </span><span class="cov8" title="1">{
                                startLine, endLine, err := parseRange(comment.Range)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("invalid range %s: %w", comment.Range, err)
                                }</span>
                                <span class="cov8" title="1">reviewComment.StartLine = startLine
                                reviewComment.Line = endLine</span>
                        } else<span class="cov8" title="1"> {
                                reviewComment.Line = comment.Line
                        }</span>

                        // Validate line exists in diff if validation is enabled
                        <span class="cov8" title="1">if validateDiff </span><span class="cov0" title="0">{
                                if err := validateCommentLine(client, owner, repo, pr, reviewComment); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("comment %d validation failed: %w", i+1, err)
                                }</span>
                        }

                        <span class="cov8" title="1">err = client.AddReviewComment(owner, repo, pr, reviewComment)</span>
                }

                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create comment %d: %w", i+1, err)
                }</span>

                <span class="cov8" title="1">successCount++</span>
        }

        <span class="cov8" title="1">fmt.Printf("%s\n", ColorizeSuccess(fmt.Sprintf("Successfully created %d comments", successCount)))
        return nil</span>
}

// Helper functions
func formatLineOrRange(comment CommentConfig) string <span class="cov8" title="1">{
        if comment.Range != "" </span><span class="cov8" title="1">{
                return comment.Range
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%d", comment.Line)</span>
}

func truncateMessage(message string, maxLen int) string <span class="cov8" title="1">{
        if len(message) &lt;= maxLen </span><span class="cov8" title="1">{
                return message
        }</span>
        <span class="cov8" title="1">return message[:maxLen-TruncationReserve] + TruncationSuffix</span>
}

func parseRange(rangeStr string) (startLine, endLine int, err error) <span class="cov8" title="1">{
        parts := strings.Split(rangeStr, "-")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return 0, 0, fmt.Errorf("range must be in format 'start-end'")
        }</span>

        <span class="cov8" title="1">startLine, err = strconv.Atoi(strings.TrimSpace(parts[0]))
        if err != nil </span><span class="cov8" title="1">{
                return 0, 0, fmt.Errorf("invalid start line: %w", err)
        }</span>

        <span class="cov8" title="1">endLine, err = strconv.Atoi(strings.TrimSpace(parts[1]))
        if err != nil </span><span class="cov8" title="1">{
                return 0, 0, fmt.Errorf("invalid end line: %w", err)
        }</span>

        <span class="cov8" title="1">if startLine &lt;= 0 || endLine &lt;= 0 </span><span class="cov8" title="1">{
                return 0, 0, fmt.Errorf("line numbers must be positive")
        }</span>

        <span class="cov8" title="1">if startLine &gt; endLine </span><span class="cov8" title="1">{
                return 0, 0, fmt.Errorf("start line (%d) cannot be greater than end line (%d)", startLine, endLine)
        }</span>

        <span class="cov8" title="1">return startLine, endLine, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cmd

import (
        "os"

        "github.com/silouanwright/gh-comment/internal/github"
)

// createGitHubClient creates the appropriate GitHub client based on environment
func createGitHubClient() (github.GitHubAPI, error) <span class="cov8" title="1">{
        // Check if we're in a test environment with mock server
        if mockURL := os.Getenv("MOCK_SERVER_URL"); mockURL != "" </span><span class="cov8" title="1">{
                return github.NewTestClient()
        }</span>

        // Use real client for production
        <span class="cov8" title="1">return github.NewRealClient()</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package cmd

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/MakeNowJust/heredoc"
        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
)

var (
        closePendingEvent  string
        closePendingBody   string
        closePendingClient github.GitHubAPI
)

var closePendingReviewCmd = &amp;cobra.Command{
        Use:   "close-pending-review [pr] [body]",
        Short: "Close/submit a pending review created in GitHub's web interface",
        Long: heredoc.Doc(`
                Close and submit a pending review that was created in GitHub's web interface.

                IMPORTANT: This command only works with pending reviews created through GitHub's
                web interface. The GitHub API cannot create pending reviews - only the web UI can.

                This command finds your existing pending review on the PR and submits it with
                the specified event type (APPROVE, REQUEST_CHANGES, or COMMENT) and optional
                summary body.

                Once submitted, the pending review becomes visible to others and you can create
                new reviews.

                Note: This does NOT work with reviews created via 'gh comment review' commands,
                as those create submitted reviews immediately.
        `),
        Example: heredoc.Doc(`
                # Submit GUI-created pending review with approval
                $ gh comment close-pending-review 123 "LGTM! Great work" --event APPROVE

                # Submit with change requests
                $ gh comment close-pending-review 123 "Please address the comments" --event REQUEST_CHANGES

                # Submit as general comment
                $ gh comment close-pending-review 123 "Thanks for the updates" --event COMMENT

                # Submit with minimal body (auto-detect PR)
                $ gh comment close-pending-review "Looks good" --event APPROVE
        `),
        Args: cobra.RangeArgs(0, 2),
        RunE: runClosePendingReview,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(closePendingReviewCmd)
        closePendingReviewCmd.Flags().StringVar(&amp;closePendingEvent, "event", "COMMENT", "Review event (APPROVE|REQUEST_CHANGES|COMMENT) (default: COMMENT)")
        closePendingReviewCmd.Flags().StringVar(&amp;closePendingBody, "body", "", "Review summary body (default: empty)")
}</span>

func runClosePendingReview(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if closePendingClient == nil </span><span class="cov0" title="0">{
                client, err := createGitHubClient()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create GitHub client: %w", err)
                }</span>
                <span class="cov0" title="0">closePendingClient = client</span>
        }

        <span class="cov8" title="1">var pr int
        var body string
        var err error

        // Parse arguments
        if len(args) == 2 </span><span class="cov8" title="1">{
                // PR number and body provided
                pr, err = strconv.Atoi(args[0])
                if err != nil </span><span class="cov8" title="1">{
                        return formatValidationError("PR number", args[0], "must be a valid integer")
                }</span>
                <span class="cov8" title="1">body = args[1]</span>
        } else<span class="cov8" title="1"> if len(args) == 1 </span><span class="cov8" title="1">{
                // Check if it's a PR number or review body
                if prNum, err := strconv.Atoi(args[0]); err == nil </span><span class="cov8" title="1">{
                        // It's a PR number
                        pr = prNum
                }</span> else<span class="cov8" title="1"> {
                        // It's a review body, auto-detect PR
                        _, prNum, err := getPRContext()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">pr = prNum
                        body = args[0]</span>
                }
        } else<span class="cov8" title="1"> {
                // Auto-detect PR
                _, prNum, err := getPRContext()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">pr = prNum</span>
        }

        // Use --body flag if provided, otherwise use positional arg
        <span class="cov8" title="1">if closePendingBody != "" </span><span class="cov8" title="1">{
                body = closePendingBody
        }</span>

        // Validate event type
        <span class="cov8" title="1">validEvents := []string{"APPROVE", "REQUEST_CHANGES", "COMMENT"}
        isValidEvent := false
        for _, validEvent := range validEvents </span><span class="cov8" title="1">{
                if closePendingEvent == validEvent </span><span class="cov8" title="1">{
                        isValidEvent = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !isValidEvent </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid event type: %s (must be APPROVE, REQUEST_CHANGES, or COMMENT)", closePendingEvent)
        }</span>

        // Get repository and PR context
        <span class="cov8" title="1">repository, pr, err := getPRContext()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Parse owner/repo
        <span class="cov8" title="1">parts := strings.Split(repository, "/")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid repository format: %s (expected owner/repo)", repository)
        }</span>
        <span class="cov8" title="1">owner, repoName := parts[0], parts[1]

        if verbose </span><span class="cov8" title="1">{
                fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("PR: %d\n", pr)
                fmt.Printf("Review body: %s\n", body)
                fmt.Printf("Review event: %s\n", closePendingEvent)
                fmt.Println()
        }</span>

        <span class="cov8" title="1">if dryRun </span><span class="cov8" title="1">{
                fmt.Printf("Would close pending review on PR #%d:\n", pr)
                fmt.Printf("Body: %s\n", body)
                fmt.Printf("Event: %s\n", closePendingEvent)
                return nil
        }</span>

        // Find the pending review
        <span class="cov8" title="1">reviewID, err := closePendingClient.FindPendingReview(owner, repoName, pr)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to find pending review: %w", err)
        }</span>

        <span class="cov8" title="1">if reviewID == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("no pending review found on PR #%d\n\nNote: This command only works with pending reviews created in GitHub's web interface.\nUse 'gh comment review' to create and submit reviews via CLI.", pr)
        }</span>

        <span class="cov8" title="1">if verbose </span><span class="cov8" title="1">{
                fmt.Printf("Found pending review ID: %d\n", reviewID)
        }</span>

        // Submit the review
        <span class="cov8" title="1">err = closePendingClient.SubmitReview(owner, repoName, pr, reviewID, body, closePendingEvent)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to submit review: %w", err)
        }</span>

        // Display success message
        <span class="cov8" title="1">eventText := ""
        switch closePendingEvent </span>{
        case "APPROVE":<span class="cov8" title="1">
                eventText = "approved"</span>
        case "REQUEST_CHANGES":<span class="cov8" title="1">
                eventText = "requested changes"</span>
        case "COMMENT":<span class="cov8" title="1">
                eventText = "commented"</span>
        }

        <span class="cov8" title="1">fmt.Printf("✅ Successfully submitted pending review and %s PR #%d\n", eventText, pr)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package cmd

import (
        "fmt"
        "github.com/fatih/color"
        "os"
)

var (
        // Color settings
        colorEnabled = true

        // Test override for terminal detection (used in testing)
        testTerminalOverride *bool

        // Color definitions for different types of output
        ColorCommentID     *color.Color
        ColorAuthor        *color.Color
        ColorTimestamp     *color.Color
        ColorFilePath      *color.Color
        ColorLineNumber    *color.Color
        ColorURL           *color.Color
        ColorSuccess       *color.Color
        ColorError         *color.Color
        ColorWarning       *color.Color
        ColorHeader        *color.Color
        ColorReviewState   *color.Color
        ColorCommitSHA     *color.Color
        ColorIssueComment  *color.Color
        ColorReviewComment *color.Color
)

// InitColors initializes color settings and creates color functions
func InitColors() <span class="cov8" title="1">{
        // Detect if colors should be enabled
        colorEnabled = ShouldUseColor()

        if colorEnabled </span><span class="cov8" title="1">{
                // Enable colors globally
                color.NoColor = false

                // Comment-related colors
                ColorCommentID = color.New(color.FgCyan, color.Bold)
                ColorAuthor = color.New(color.FgGreen, color.Bold)
                ColorTimestamp = color.New(color.FgBlue)
                ColorFilePath = color.New(color.FgYellow)
                ColorLineNumber = color.New(color.FgYellow, color.Bold)
                ColorURL = color.New(color.FgBlue, color.Underline)

                // Status colors
                ColorSuccess = color.New(color.FgGreen, color.Bold)
                ColorError = color.New(color.FgRed, color.Bold)
                ColorWarning = color.New(color.FgYellow, color.Bold)

                // Section headers
                ColorHeader = color.New(color.FgMagenta, color.Bold)
                ColorReviewState = color.New(color.FgCyan)
                ColorCommitSHA = color.New(color.FgBlue)

                // Comment type colors
                ColorIssueComment = color.New(color.FgGreen)
                ColorReviewComment = color.New(color.FgYellow)
        }</span> else<span class="cov8" title="1"> {
                // Create disabled color functions that just return the text as-is
                ColorCommentID = color.New()
                ColorAuthor = color.New()
                ColorTimestamp = color.New()
                ColorFilePath = color.New()
                ColorLineNumber = color.New()
                ColorURL = color.New()
                ColorSuccess = color.New()
                ColorError = color.New()
                ColorWarning = color.New()
                ColorHeader = color.New()
                ColorReviewState = color.New()
                ColorCommitSHA = color.New()
                ColorIssueComment = color.New()
                ColorReviewComment = color.New()

                // Disable all colors
                color.NoColor = true
        }</span>
}

// ShouldUseColor determines if colors should be used based on environment and flags
func ShouldUseColor() bool <span class="cov8" title="1">{
        // Check if --no-color flag was set
        if noColor </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check if output is being piped or redirected
        <span class="cov8" title="1">if !isTerminal() </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check NO_COLOR environment variable (http://no-color.org/)
        <span class="cov8" title="1">if os.Getenv("NO_COLOR") != "" </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check TERM environment variable
        <span class="cov8" title="1">term := os.Getenv("TERM")
        if term == "dumb" || term == "" </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

// isTerminal checks if output is going to a terminal
func isTerminal() bool <span class="cov8" title="1">{
        // Use test override if set (for testing purposes)
        if testTerminalOverride != nil </span><span class="cov8" title="1">{
                return *testTerminalOverride
        }</span>

        <span class="cov8" title="1">fileInfo, _ := os.Stdout.Stat()
        return (fileInfo.Mode() &amp; os.ModeCharDevice) != 0</span>
}

// DisableColors forcibly disables all colors (useful for testing)
func DisableColors() <span class="cov8" title="1">{
        colorEnabled = false
        color.NoColor = true
        InitColors()
}</span>

// EnableColors forcibly enables colors (useful for testing)
func EnableColors() <span class="cov8" title="1">{
        colorEnabled = true
        color.NoColor = false
        noColor = false // Reset the flag too

        // Force initialize colors without checking ShouldUseColor()
        // Comment-related colors
        ColorCommentID = color.New(color.FgCyan, color.Bold)
        ColorAuthor = color.New(color.FgGreen, color.Bold)
        ColorTimestamp = color.New(color.FgBlue)
        ColorFilePath = color.New(color.FgYellow)
        ColorLineNumber = color.New(color.FgYellow, color.Bold)
        ColorURL = color.New(color.FgBlue, color.Underline)

        // Status colors
        ColorSuccess = color.New(color.FgGreen, color.Bold)
        ColorError = color.New(color.FgRed, color.Bold)
        ColorWarning = color.New(color.FgYellow, color.Bold)

        // Section headers
        ColorHeader = color.New(color.FgMagenta, color.Bold)
        ColorReviewState = color.New(color.FgCyan)
        ColorCommitSHA = color.New(color.FgBlue)

        // Comment type colors
        ColorIssueComment = color.New(color.FgGreen)
        ColorReviewComment = color.New(color.FgYellow)
}</span>

// Helper functions for common color patterns

// ColorizeCommentType returns colored text based on comment type
func ColorizeCommentType(commentType string) string <span class="cov8" title="1">{
        switch commentType </span>{
        case "issue":<span class="cov8" title="1">
                if ColorIssueComment != nil </span><span class="cov8" title="1">{
                        return ColorIssueComment.Sprintf("💬 General PR Comments")
                }</span>
                <span class="cov8" title="1">return "💬 General PR Comments"</span>
        case "review":<span class="cov8" title="1">
                if ColorReviewComment != nil </span><span class="cov8" title="1">{
                        return ColorReviewComment.Sprintf("📋 Review Comments")
                }</span>
                <span class="cov8" title="1">return "📋 Review Comments"</span>
        default:<span class="cov8" title="1">
                return commentType</span>
        }
}

// ColorizeReviewState returns colored text based on review state
func ColorizeReviewState(state string) string <span class="cov8" title="1">{
        switch state </span>{
        case "approved":<span class="cov8" title="1">
                if ColorSuccess != nil </span><span class="cov8" title="1">{
                        return ColorSuccess.Sprintf("✅ %s", state)
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("✅ %s", state)</span>
        case "changes_requested":<span class="cov8" title="1">
                if ColorError != nil </span><span class="cov8" title="1">{
                        return ColorError.Sprintf("🔴 %s", state)
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("🔴 %s", state)</span>
        case "commented":<span class="cov8" title="1">
                if ColorReviewState != nil </span><span class="cov8" title="1">{
                        return ColorReviewState.Sprintf("💬 %s", state)
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("💬 %s", state)</span>
        default:<span class="cov8" title="1">
                if ColorReviewState != nil </span><span class="cov8" title="1">{
                        return ColorReviewState.Sprintf("📝 %s", state)
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("📝 %s", state)</span>
        }
}

// ColorizeSuccess returns green colored success text
func ColorizeSuccess(text string) string <span class="cov8" title="1">{
        if ColorSuccess == nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("✅ %s", text)
        }</span>
        <span class="cov8" title="1">return ColorSuccess.Sprintf("✅ %s", text)</span>
}

// ColorizeError returns red colored error text
func ColorizeError(text string) string <span class="cov8" title="1">{
        if ColorError == nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("❌ %s", text)
        }</span>
        <span class="cov8" title="1">return ColorError.Sprintf("❌ %s", text)</span>
}

// ColorizeWarning returns yellow colored warning text
func ColorizeWarning(text string) string <span class="cov8" title="1">{
        if ColorWarning == nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("⚠️ %s", text)
        }</span>
        <span class="cov8" title="1">return ColorWarning.Sprintf("⚠️ %s", text)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package cmd

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"

        "gopkg.in/yaml.v3"
)

// Config represents the complete configuration structure
type Config struct {
        Defaults    DefaultsConfig       `yaml:"defaults" json:"defaults"`
        Behavior    BehaviorConfig       `yaml:"behavior" json:"behavior"`
        Display     DisplayConfig        `yaml:"display" json:"display"`
        Filters     FiltersConfig        `yaml:"filters" json:"filters"`
        Review      ReviewDefaultsConfig `yaml:"review" json:"review"`
        API         APIConfig            `yaml:"api" json:"api"`
        Suggestions SuggestionsConfig    `yaml:"suggestions" json:"suggestions"`
        Aliases     map[string]string    `yaml:"aliases" json:"aliases"`
        Templates   TemplatesConfig      `yaml:"templates" json:"templates"`
}

// DefaultsConfig holds default values for common flags
type DefaultsConfig struct {
        Repository string `yaml:"repository" json:"repository"`
        Author     string `yaml:"author" json:"author"`
        PR         int    `yaml:"pr" json:"pr"`
}

// BehaviorConfig holds default behavior settings
type BehaviorConfig struct {
        DryRun              bool `yaml:"dry_run" json:"dry_run"`
        Verbose             bool `yaml:"verbose" json:"verbose"`
        Validate            bool `yaml:"validate" json:"validate"`
        NoExpandSuggestions bool `yaml:"no_expand_suggestions" json:"no_expand_suggestions"`
}

// DisplayConfig holds display preference settings
type DisplayConfig struct {
        Format string `yaml:"format" json:"format"`
        Color  string `yaml:"color" json:"color"`
        Quiet  bool   `yaml:"quiet" json:"quiet"`
}

// FiltersConfig holds default filter settings
type FiltersConfig struct {
        Status string `yaml:"status" json:"status"`
        Type   string `yaml:"type" json:"type"`
        Since  string `yaml:"since" json:"since"`
        Until  string `yaml:"until" json:"until"`
}

// ReviewDefaultsConfig holds review-specific settings
type ReviewDefaultsConfig struct {
        Event string `yaml:"event" json:"event"`
}

// APIConfig holds API-related settings
type APIConfig struct {
        Timeout         int `yaml:"timeout" json:"timeout"`
        RetryCount      int `yaml:"retry_count" json:"retry_count"`
        RateLimitBuffer int `yaml:"rate_limit_buffer" json:"rate_limit_buffer"`
}

// SuggestionsConfig holds suggestion syntax settings
type SuggestionsConfig struct {
        ExpandByDefault bool `yaml:"expand_by_default" json:"expand_by_default"`
        MaxOffset       int  `yaml:"max_offset" json:"max_offset"`
}

// TemplatesConfig holds template settings
type TemplatesConfig struct {
        DefaultReviewBody      string `yaml:"default_review_body" json:"default_review_body"`
        DefaultApprovalMessage string `yaml:"default_approval_message" json:"default_approval_message"`
}

// NewDefaultConfig returns a configuration with sensible defaults
func NewDefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                Defaults: DefaultsConfig{
                        Repository: "",
                        Author:     "",
                        PR:         0,
                },
                Behavior: BehaviorConfig{
                        DryRun:              false,
                        Verbose:             false,
                        Validate:            true,
                        NoExpandSuggestions: false,
                },
                Display: DisplayConfig{
                        Format: "table",
                        Color:  "auto",
                        Quiet:  false,
                },
                Filters: FiltersConfig{
                        Status: "all",
                        Type:   "all",
                        Since:  "",
                        Until:  "",
                },
                Review: ReviewDefaultsConfig{
                        Event: "COMMENT",
                },
                API: APIConfig{
                        Timeout:         30,
                        RetryCount:      3,
                        RateLimitBuffer: 10,
                },
                Suggestions: SuggestionsConfig{
                        ExpandByDefault: true,
                        MaxOffset:       999,
                },
                Aliases: make(map[string]string),
                Templates: TemplatesConfig{
                        DefaultReviewBody:      "Code review complete",
                        DefaultApprovalMessage: "LGTM! Ready to merge",
                },
        }
}</span>

// LoadConfig loads configuration from various sources in priority order
func LoadConfig(configPath string) (*Config, error) <span class="cov8" title="1">{
        config := NewDefaultConfig()

        // Find config file if not explicitly provided
        if configPath == "" </span><span class="cov8" title="1">{
                var err error
                configPath, err = findConfigFile()
                if err != nil </span><span class="cov0" title="0">{
                        // No config file found, use defaults
                        return config, nil
                }</span>
        }

        // Load and parse config file
        <span class="cov8" title="1">if configPath != "" </span><span class="cov8" title="1">{
                err := loadConfigFile(config, configPath)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to load config file %s: %w", configPath, err)
                }</span>
        }

        // Apply environment variable overrides
        <span class="cov8" title="1">applyEnvironmentOverrides(config)

        // Validate configuration
        err := validateConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        <span class="cov8" title="1">return config, nil</span>
}

// findConfigFile searches for config files in priority order
func findConfigFile() (string, error) <span class="cov8" title="1">{
        // Search locations in priority order
        searchPaths := []string{
                ".gh-comment.yaml",
                ".gh-comment.yml",
                ".gh-comment.json",
        }

        // Add repository root if in git repo
        if gitRoot := findGitRoot(); gitRoot != "" </span><span class="cov8" title="1">{
                for _, name := range []string{".gh-comment.yaml", ".gh-comment.yml", ".gh-comment.json"} </span><span class="cov8" title="1">{
                        searchPaths = append(searchPaths, filepath.Join(gitRoot, name))
                }</span>
        }

        // Add user config locations
        <span class="cov8" title="1">if homeDir, err := os.UserHomeDir(); err == nil </span><span class="cov8" title="1">{
                searchPaths = append(searchPaths,
                        filepath.Join(homeDir, ".config", "gh-comment", "config.yaml"),
                        filepath.Join(homeDir, ".config", "gh-comment", "config.yml"),
                        filepath.Join(homeDir, ".config", "gh-comment", "config.json"),
                        filepath.Join(homeDir, ".gh-comment.yaml"),
                        filepath.Join(homeDir, ".gh-comment.yml"),
                        filepath.Join(homeDir, ".gh-comment.json"),
                )
        }</span>

        // Find first existing file
        <span class="cov8" title="1">for _, path := range searchPaths </span><span class="cov8" title="1">{
                if _, err := os.Stat(path); err == nil </span><span class="cov8" title="1">{
                        return path, nil
                }</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("no config file found")</span>
}

// findGitRoot finds the root of the current git repository
func findGitRoot() string <span class="cov8" title="1">{
        currentDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                gitDir := filepath.Join(currentDir, ".git")
                if _, err := os.Stat(gitDir); err == nil </span><span class="cov8" title="1">{
                        return currentDir
                }</span>

                <span class="cov8" title="1">parentDir := filepath.Dir(currentDir)
                if parentDir == currentDir </span><span class="cov8" title="1">{
                        // Reached filesystem root
                        break</span>
                }
                <span class="cov8" title="1">currentDir = parentDir</span>
        }

        <span class="cov8" title="1">return ""</span>
}

// loadConfigFile loads and parses a configuration file
func loadConfigFile(config *Config, path string) error <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read config file: %w", err)
        }</span>

        // Determine format by extension
        <span class="cov8" title="1">ext := strings.ToLower(filepath.Ext(path))
        switch ext </span>{
        case ".yaml", ".yml":<span class="cov8" title="1">
                err = yaml.Unmarshal(data, config)</span>
        case ".json":<span class="cov8" title="1">
                err = json.Unmarshal(data, config)</span>
        default:<span class="cov0" title="0">
                // Try YAML first, then JSON
                err = yaml.Unmarshal(data, config)
                if err != nil </span><span class="cov0" title="0">{
                        err = json.Unmarshal(data, config)
                }</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to parse config file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// applyEnvironmentOverrides applies environment variable overrides
func applyEnvironmentOverrides(config *Config) <span class="cov8" title="1">{
        if val := os.Getenv("GH_COMMENT_REPO"); val != "" </span><span class="cov8" title="1">{
                config.Defaults.Repository = val
        }</span>
        <span class="cov8" title="1">if val := os.Getenv("GH_COMMENT_AUTHOR"); val != "" </span><span class="cov8" title="1">{
                config.Defaults.Author = val
        }</span>
        <span class="cov8" title="1">if val := os.Getenv("GH_COMMENT_DRY_RUN"); val != "" </span><span class="cov8" title="1">{
                config.Behavior.DryRun = parseBool(val)
        }</span>
        <span class="cov8" title="1">if val := os.Getenv("GH_COMMENT_VERBOSE"); val != "" </span><span class="cov8" title="1">{
                config.Behavior.Verbose = parseBool(val)
        }</span>
        <span class="cov8" title="1">if val := os.Getenv("GH_COMMENT_FORMAT"); val != "" </span><span class="cov8" title="1">{
                config.Display.Format = val
        }</span>
        <span class="cov8" title="1">if val := os.Getenv("GH_COMMENT_COLOR"); val != "" </span><span class="cov8" title="1">{
                config.Display.Color = val
        }</span>
}

// parseBool parses a string as a boolean (true/false, yes/no, 1/0)
func parseBool(s string) bool <span class="cov8" title="1">{
        s = strings.ToLower(strings.TrimSpace(s))
        return s == "true" || s == "yes" || s == "1" || s == "on"
}</span>

// validateConfig validates the configuration values
func validateConfig(config *Config) error <span class="cov8" title="1">{
        // Validate repository format
        if config.Defaults.Repository != "" </span><span class="cov8" title="1">{
                if !isValidRepoFormat(config.Defaults.Repository) </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid repository format: %s (must be owner/repo)", config.Defaults.Repository)
                }</span>
        }

        // Validate enum values
        <span class="cov8" title="1">validFormats := map[string]bool{"table": true, "json": true, "quiet": true}
        if !validFormats[config.Display.Format] </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid display format: %s (must be table, json, or quiet)", config.Display.Format)
        }</span>

        <span class="cov8" title="1">validColors := map[string]bool{"auto": true, "always": true, "never": true}
        if !validColors[config.Display.Color] </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid color setting: %s (must be auto, always, or never)", config.Display.Color)
        }</span>

        <span class="cov8" title="1">validStatuses := map[string]bool{"all": true, "open": true, "resolved": true}
        if !validStatuses[config.Filters.Status] </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid status filter: %s (must be all, open, or resolved)", config.Filters.Status)
        }</span>

        <span class="cov8" title="1">validTypes := map[string]bool{"all": true, "issue": true, "review": true}
        if !validTypes[config.Filters.Type] </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid type filter: %s (must be all, issue, or review)", config.Filters.Type)
        }</span>

        <span class="cov8" title="1">validEvents := map[string]bool{"APPROVE": true, "REQUEST_CHANGES": true, "COMMENT": true}
        if !validEvents[config.Review.Event] </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid review event: %s (must be APPROVE, REQUEST_CHANGES, or COMMENT)", config.Review.Event)
        }</span>

        // Validate numeric ranges
        <span class="cov8" title="1">if config.API.Timeout &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("API timeout must be positive: %d", config.API.Timeout)
        }</span>
        <span class="cov8" title="1">if config.API.RetryCount &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("retry count must be non-negative: %d", config.API.RetryCount)
        }</span>
        <span class="cov8" title="1">if config.Suggestions.MaxOffset &lt;= 0 || config.Suggestions.MaxOffset &gt; 9999 </span><span class="cov8" title="1">{
                return fmt.Errorf("max offset must be between 1 and 9999: %d", config.Suggestions.MaxOffset)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// isValidRepoFormat validates repository format (owner/repo)
func isValidRepoFormat(repo string) bool <span class="cov8" title="1">{
        // Must be owner/repo format
        pattern := regexp.MustCompile(`^[a-zA-Z0-9._-]+/[a-zA-Z0-9._-]+$`)
        return pattern.MatchString(repo)
}</span>

// Global config instance
var globalConfig *Config

// GetConfig returns the global configuration instance
func GetConfig() *Config <span class="cov8" title="1">{
        if globalConfig == nil </span><span class="cov8" title="1">{
                // Load default config if none loaded
                globalConfig = NewDefaultConfig()
        }</span>
        <span class="cov8" title="1">return globalConfig</span>
}

// LoadGlobalConfig loads the global configuration
func LoadGlobalConfig(configPath string) error <span class="cov8" title="1">{
        config, err := LoadConfig(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">globalConfig = config
        return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package cmd

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"

        "github.com/MakeNowJust/heredoc"
        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"
)

var (
        configFormat  string
        globalFlag    bool
        showSource    bool
        showEffective bool
)

// configCmd represents the config command
var configCmd = &amp;cobra.Command{
        Use:   "config",
        Short: "Manage configuration files",
        Long: heredoc.Doc(`
                Manage gh-comment configuration files and settings.

                Configuration files are searched in this order:
                1. --config flag specified file
                2. .gh-comment.yaml in current directory
                3. .gh-comment.yaml in repository root
                4. ~/.config/gh-comment/config.yaml (user config)
                5. ~/.gh-comment.yaml (legacy user config)
        `),
        Example: heredoc.Doc(`
                # Generate a new config file
                $ gh comment config init
                $ gh comment config init --global --format json

                # Show current configuration
                $ gh comment config show
                $ gh comment config show --source
                $ gh comment config show --effective

                # Validate configuration
                $ gh comment config validate
                $ gh comment config validate ~/.gh-comment.yaml
        `),
}

// configInitCmd initializes a new config file
var configInitCmd = &amp;cobra.Command{
        Use:   "init",
        Short: "Generate a default configuration file",
        Long: heredoc.Doc(`
                Generate a default configuration file with common settings.

                By default, creates .gh-comment.yaml in the current directory.
                Use --global to create a user-wide config file.
        `),
        Example: heredoc.Doc(`
                # Create local config file
                $ gh comment config init

                # Create global user config file
                $ gh comment config init --global

                # Create config in JSON format
                $ gh comment config init --format json
        `),
        RunE: runConfigInit,
}

// configShowCmd shows current configuration
var configShowCmd = &amp;cobra.Command{
        Use:   "show",
        Short: "Show current configuration",
        Long: heredoc.Doc(`
                Show the current configuration, including merged values from all sources.

                Use --source to show which file each setting comes from.
                Use --effective to show only the final merged configuration.
        `),
        Example: heredoc.Doc(`
                # Show current config
                $ gh comment config show

                # Show config with source information
                $ gh comment config show --source

                # Show only effective (merged) config
                $ gh comment config show --effective
        `),
        RunE: runConfigShow,
}

// configValidateCmd validates configuration files
var configValidateCmd = &amp;cobra.Command{
        Use:   "validate [config-file]",
        Short: "Validate configuration file",
        Long: heredoc.Doc(`
                Validate a configuration file for syntax and semantic errors.

                If no file is specified, validates the current effective configuration.
        `),
        Example: heredoc.Doc(`
                # Validate current config
                $ gh comment config validate

                # Validate specific file
                $ gh comment config validate ~/.gh-comment.yaml
                $ gh comment config validate .gh-comment.json
        `),
        Args: cobra.MaximumNArgs(1),
        RunE: runConfigValidate,
}

func init() <span class="cov8" title="1">{
        // Add subcommands
        configCmd.AddCommand(configInitCmd)
        configCmd.AddCommand(configShowCmd)
        configCmd.AddCommand(configValidateCmd)

        // Init command flags
        configInitCmd.Flags().StringVar(&amp;configFormat, "format", "yaml", "Config file format (yaml or json)")
        configInitCmd.Flags().BoolVar(&amp;globalFlag, "global", false, "Create global user config file")

        // Show command flags
        configShowCmd.Flags().BoolVar(&amp;showSource, "source", false, "Show which file each setting comes from")
        configShowCmd.Flags().BoolVar(&amp;showEffective, "effective", false, "Show only effective (merged) configuration")

        // Add to root command
        rootCmd.AddCommand(configCmd)
}</span>

func runConfigInit(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        config := NewDefaultConfig()

        // Determine output file path
        var outputPath string
        if globalFlag </span><span class="cov8" title="1">{
                homeDir, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get user home directory: %w", err)
                }</span>

                <span class="cov8" title="1">configDir := filepath.Join(homeDir, ".config", "gh-comment")
                err = os.MkdirAll(configDir, 0755)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create config directory: %w", err)
                }</span>

                <span class="cov8" title="1">ext := "yaml"
                if configFormat == "json" </span><span class="cov0" title="0">{
                        ext = "json"
                }</span>
                <span class="cov8" title="1">outputPath = filepath.Join(configDir, "config."+ext)</span>
        } else<span class="cov8" title="1"> {
                ext := "yaml"
                if configFormat == "json" </span><span class="cov8" title="1">{
                        ext = "json"
                }</span>
                <span class="cov8" title="1">outputPath = ".gh-comment." + ext</span>
        }

        // Check if file already exists
        <span class="cov8" title="1">if _, err := os.Stat(outputPath); err == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("config file already exists: %s", outputPath)
        }</span>

        // Generate config content
        <span class="cov8" title="1">var content []byte
        var err error

        if configFormat == "json" </span><span class="cov8" title="1">{
                content, err = json.MarshalIndent(config, "", "  ")
        }</span> else<span class="cov8" title="1"> {
                content, err = yaml.Marshal(config)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        // Write config file
        <span class="cov8" title="1">err = os.WriteFile(outputPath, content, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("✅ Created config file: %s\n", outputPath)
        return nil</span>
}

func runConfigShow(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        if showEffective </span><span class="cov8" title="1">{
                // Show only the effective merged config
                config := GetConfig()
                content, err := yaml.Marshal(config)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal config: %w", err)
                }</span>
                <span class="cov8" title="1">fmt.Print(string(content))
                return nil</span>
        }

        <span class="cov8" title="1">if showSource </span><span class="cov8" title="1">{
                // Show config with source information
                fmt.Println("# Configuration sources (in priority order):")
                fmt.Println("# 1. Command-line flags (highest priority)")
                fmt.Println("# 2. Environment variables")
                fmt.Println("# 3. Configuration files")
                fmt.Println("# 4. Built-in defaults (lowest priority)")
                fmt.Println()

                // Find and show config file sources
                configPath, _ := findConfigFile()
                if configPath != "" </span><span class="cov8" title="1">{
                        fmt.Printf("# Active config file: %s\n", configPath)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("# No config file found - using defaults")
                }</span>
                <span class="cov8" title="1">fmt.Println()</span>
        }

        // Show current effective config
        <span class="cov8" title="1">config := GetConfig()
        content, err := yaml.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>
        <span class="cov8" title="1">fmt.Print(string(content))
        return nil</span>
}

func runConfigValidate(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        var configPath string
        if len(args) &gt; 0 </span><span class="cov8" title="1">{
                configPath = args[0]
        }</span>

        // Load and validate config
        <span class="cov8" title="1">config, err := LoadConfig(configPath)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("❌ Configuration validation failed: %w", err)
        }</span>

        // Show which file was validated
        <span class="cov8" title="1">if configPath != "" </span><span class="cov8" title="1">{
                fmt.Printf("✅ Configuration file is valid: %s\n", configPath)
        }</span> else<span class="cov8" title="1"> {
                // Show which files were found and merged
                foundPath, _ := findConfigFile()
                if foundPath != "" </span><span class="cov8" title="1">{
                        fmt.Printf("✅ Configuration is valid: %s\n", foundPath)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("✅ Using default configuration (no config file found)")
                }</span>
        }

        // Show any warnings
        <span class="cov8" title="1">showConfigWarnings(config)

        return nil</span>
}

func showConfigWarnings(config *Config) <span class="cov8" title="1">{
        // Handle nil config gracefully
        if config == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">warnings := []string{}

        // Check for potentially problematic values
        if config.API.Timeout &gt; 300 </span><span class="cov0" title="0">{
                warnings = append(warnings, fmt.Sprintf("Large API timeout: %d seconds", config.API.Timeout))
        }</span>
        <span class="cov8" title="1">if config.API.RetryCount &gt; 10 </span><span class="cov0" title="0">{
                warnings = append(warnings, fmt.Sprintf("High retry count: %d", config.API.RetryCount))
        }</span>
        <span class="cov8" title="1">if config.Suggestions.MaxOffset &gt; 100 </span><span class="cov8" title="1">{
                warnings = append(warnings, fmt.Sprintf("Large max offset: %d", config.Suggestions.MaxOffset))
        }</span>

        // Check repository format if set
        <span class="cov8" title="1">if config.Defaults.Repository != "" &amp;&amp; !isValidRepoFormat(config.Defaults.Repository) </span><span class="cov8" title="1">{
                warnings = append(warnings, fmt.Sprintf("Invalid repository format: %s", config.Defaults.Repository))
        }</span>

        <span class="cov8" title="1">if len(warnings) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Println("\n⚠️  Warnings:")
                for _, warning := range warnings </span><span class="cov8" title="1">{
                        fmt.Printf("  • %s\n", warning)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package cmd

import (
        "fmt"
        "strings"

        "github.com/MakeNowJust/heredoc"
        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
)

var (
        editMessages []string

        // Client for dependency injection (tests can override)
        editClient github.GitHubAPI
)

var editCmd = &amp;cobra.Command{
        Use:   "edit &lt;comment-id&gt; [message]",
        Short: "Edit an existing comment on a PR",
        Long: heredoc.Doc(`
                Edit an existing comment on a pull request.

                You can edit with a new message using either positional argument or --message flags.
                Use the comment ID from the URL shown in 'gh comment list' output.

                Common use cases:
                - Fix typos in comments: "Fixed typo in previous comment"
                - Add more context: "Adding more details about the implementation"
                - Refine AI-generated comments: "Updating comment based on new analysis"
                - Correct mistakes: "Correcting the suggested approach"
        `),
        Example: heredoc.Doc(`
                # Edit with new message
                $ gh comment edit 2246362251 "Updated comment with better explanation"

                # Edit with multi-line content using --message flags (AI-friendly)
                $ gh comment edit 2246362251 --message "First paragraph" --message "Second paragraph"

                # Edit with multi-line content (shell native)
                $ gh comment edit 2246362251 "Line 1
                Line 2
                Line 3"
        `),
        Args: cobra.RangeArgs(1, 2),
        RunE: runEdit,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(editCmd)
        editCmd.Flags().StringArrayVarP(&amp;editMessages, "message", "m", []string{}, "Edit message (can be used multiple times for multi-line comments)")
}</span>

func runEdit(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if editClient == nil </span><span class="cov0" title="0">{
                client, err := createGitHubClient()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create GitHub client: %w", err)
                }</span>
                <span class="cov0" title="0">editClient = client</span>
        }

        // Parse comment ID
        <span class="cov8" title="1">commentID, err := parsePositiveInt(args[0], "comment ID")
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">var message string

        // Handle message from positional arg or --message flags
        if len(args) == 2 </span><span class="cov8" title="1">{
                message = args[1]
        }</span> else<span class="cov8" title="1"> if len(editMessages) &gt; 0 </span><span class="cov8" title="1">{
                message = strings.Join(editMessages, "\n")
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("must provide either a message argument or --message flags")
        }</span>

        // Validate comment body length
        <span class="cov8" title="1">if err := validateCommentBody(message); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get repository context
        <span class="cov8" title="1">repository, prNumber, err := getPRContext()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate repository name
        <span class="cov8" title="1">if err := validateRepositoryName(repository); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Parse owner/repo
        <span class="cov8" title="1">parts := strings.Split(repository, "/")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid repository format: %s (expected owner/repo)", repository)
        }</span>
        <span class="cov8" title="1">owner, repoName := parts[0], parts[1]

        if verbose </span><span class="cov8" title="1">{
                fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("Comment ID: %d\n", commentID)
                fmt.Printf("New message: %s\n", message)
                fmt.Println()
        }</span>

        <span class="cov8" title="1">if dryRun </span><span class="cov8" title="1">{
                fmt.Printf("Would edit comment #%d:\n", commentID)
                fmt.Printf("New message: %s\n", message)
                return nil
        }</span>

        // Edit the comment using the client
        <span class="cov8" title="1">err = editClient.EditComment(owner, repoName, commentID, prNumber, message)
        if err != nil </span><span class="cov0" title="0">{
                return formatActionableError("comment editing", err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("%s\n", ColorizeSuccess(fmt.Sprintf("Edited comment #%d", commentID)))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package cmd

import (
        "encoding/csv"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "strconv"
        "strings"
        "time"

        "github.com/MakeNowJust/heredoc"
        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
)

var (
        exportFormat    string
        exportOutput    string
        exportInclude   []string
        includeResolved bool

        // Client for dependency injection (tests can override)
        exportClient github.GitHubAPI
)

var exportCmd = &amp;cobra.Command{
        Use:   "export &lt;pr&gt;",
        Short: "Export PR comments to various formats",
        Long: heredoc.Doc(`
                Export PR comments to JSON, CSV, Markdown, or HTML format.

                This command fetches all comments from a PR (both issue and review comments)
                and exports them in the specified format. You can filter which fields to
                include and save to a file or output to stdout.

                Supported formats:
                - json: Machine-readable JSON format
                - csv: Spreadsheet-compatible CSV format
                - markdown: Documentation-friendly Markdown format
                - html: Presentation-ready HTML format
        `),
        Example: heredoc.Doc(`
                # Export to JSON (default)
                $ gh comment export 123

                # Export to CSV file
                $ gh comment export 123 --format csv --output comments.csv

                # Export only specific fields to JSON
                $ gh comment export 123 --include id,author,body

                # Export to Markdown including resolved comments
                $ gh comment export 123 --format markdown --include-resolved

                # Export to HTML for presentation
                $ gh comment export 123 --format html --output pr-123-review.html

                # Export with auto-detected PR
                $ gh comment export --format csv
        `),
        Args: cobra.MaximumNArgs(1),
        RunE: runExport,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(exportCmd)
        exportCmd.Flags().StringVarP(&amp;exportFormat, "format", "f", "json", "Export format (json|csv|markdown|html) (default: json)")
        exportCmd.Flags().StringVarP(&amp;exportOutput, "output", "o", "", "Output file (default: stdout)")
        exportCmd.Flags().StringSliceVar(&amp;exportInclude, "include", []string{}, "Fields to include (default: all)")
        exportCmd.Flags().BoolVar(&amp;includeResolved, "include-resolved", false, "Include resolved comments (default: false)")
}</span>

type ExportComment struct {
        ID        int       `json:"id"`
        Type      string    `json:"type"`
        Author    string    `json:"author"`
        Body      string    `json:"body"`
        File      string    `json:"file,omitempty"`
        Line      int       `json:"line,omitempty"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at,omitempty"`
        URL       string    `json:"url"`
        DiffHunk  string    `json:"diff_hunk,omitempty"`
        CommitID  string    `json:"commit_id,omitempty"`
        InReplyTo int       `json:"in_reply_to,omitempty"`
        Resolved  bool      `json:"resolved,omitempty"`
}

func runExport(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if exportClient == nil </span><span class="cov0" title="0">{
                client, err := createGitHubClient()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create GitHub client: %w", err)
                }</span>
                <span class="cov0" title="0">exportClient = client</span>
        }

        <span class="cov8" title="1">var pr int
        var err error

        // Parse PR number
        if len(args) == 1 </span><span class="cov8" title="1">{
                pr, err = parsePositiveInt(args[0], "PR number")
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                // Auto-detect PR
                _, pr, err = getPRContext()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Get repository
        <span class="cov8" title="1">repository, err := getCurrentRepo()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate repository name
        <span class="cov8" title="1">if err := validateRepositoryName(repository); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Parse owner/repo
        <span class="cov8" title="1">parts := strings.Split(repository, "/")
        owner, repoName := parts[0], parts[1]

        // Validate format
        validFormats := []string{"json", "csv", "markdown", "html"}
        isValidFormat := false
        for _, valid := range validFormats </span><span class="cov8" title="1">{
                if exportFormat == valid </span><span class="cov8" title="1">{
                        isValidFormat = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !isValidFormat </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid format: %s (must be json, csv, markdown, or html)", exportFormat)
        }</span>

        <span class="cov8" title="1">if verbose </span><span class="cov0" title="0">{
                fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("PR: %d\n", pr)
                fmt.Printf("Format: %s\n", exportFormat)
                if exportOutput != "" </span><span class="cov0" title="0">{
                        fmt.Printf("Output: %s\n", exportOutput)
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        // Fetch all comments
        <span class="cov8" title="1">comments, err := fetchAllCommentsForExport(exportClient, owner, repoName, pr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to fetch comments: %w", err)
        }</span>

        // Filter resolved comments if needed
        <span class="cov8" title="1">if !includeResolved </span><span class="cov8" title="1">{
                var filtered []ExportComment
                for _, comment := range comments </span><span class="cov8" title="1">{
                        if !comment.Resolved </span><span class="cov8" title="1">{
                                filtered = append(filtered, comment)
                        }</span>
                }
                <span class="cov8" title="1">comments = filtered</span>
        }

        // Setup output writer
        <span class="cov8" title="1">var writer io.Writer
        if exportOutput != "" </span><span class="cov0" title="0">{
                file, err := os.Create(exportOutput)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create output file: %w", err)
                }</span>
                <span class="cov0" title="0">defer file.Close()
                writer = file</span>
        } else<span class="cov8" title="1"> {
                writer = os.Stdout
        }</span>

        // Export based on format
        <span class="cov8" title="1">switch exportFormat </span>{
        case "json":<span class="cov8" title="1">
                return exportJSON(writer, comments)</span>
        case "csv":<span class="cov8" title="1">
                return exportCSV(writer, comments)</span>
        case "markdown":<span class="cov8" title="1">
                return exportMarkdown(writer, comments, repository, pr)</span>
        case "html":<span class="cov8" title="1">
                return exportHTML(writer, comments, repository, pr)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func fetchAllCommentsForExport(client github.GitHubAPI, owner, repo string, pr int) ([]ExportComment, error) <span class="cov8" title="1">{
        var allComments []ExportComment

        // Fetch issue comments
        issueComments, err := client.ListIssueComments(owner, repo, pr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch issue comments: %w", err)
        }</span>

        <span class="cov8" title="1">for _, comment := range issueComments </span><span class="cov8" title="1">{
                allComments = append(allComments, ExportComment{
                        ID:        comment.ID,
                        Type:      "issue",
                        Author:    comment.User.Login,
                        Body:      comment.Body,
                        CreatedAt: comment.CreatedAt,
                        UpdatedAt: comment.UpdatedAt,
                        URL:       fmt.Sprintf("https://github.com/%s/%s/issues/%d#issuecomment-%d", owner, repo, pr, comment.ID),
                })
        }</span>

        // Fetch review comments
        <span class="cov8" title="1">reviewComments, err := client.ListReviewComments(owner, repo, pr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch review comments: %w", err)
        }</span>

        <span class="cov8" title="1">for _, comment := range reviewComments </span><span class="cov8" title="1">{
                allComments = append(allComments, ExportComment{
                        ID:        comment.ID,
                        Type:      "review",
                        Author:    comment.User.Login,
                        Body:      comment.Body,
                        File:      comment.Path,
                        Line:      comment.Line,
                        CreatedAt: comment.CreatedAt,
                        UpdatedAt: comment.UpdatedAt,
                        URL:       fmt.Sprintf("https://github.com/%s/%s/pull/%d#discussion_r%d", owner, repo, pr, comment.ID),
                        CommitID:  comment.CommitID,
                        // Note: DiffHunk, InReplyTo, and Resolved are not available in the current Comment struct
                        // These would need to be fetched separately if needed
                })
        }</span>

        <span class="cov8" title="1">return allComments, nil</span>
}

func exportJSON(w io.Writer, comments []ExportComment) error <span class="cov8" title="1">{
        encoder := json.NewEncoder(w)
        encoder.SetIndent("", "  ")

        // If specific fields requested, filter them
        if len(exportInclude) &gt; 0 </span><span class="cov8" title="1">{
                var filtered []map[string]interface{}
                for _, comment := range comments </span><span class="cov8" title="1">{
                        item := make(map[string]interface{})
                        for _, field := range exportInclude </span><span class="cov8" title="1">{
                                switch field </span>{
                                case "id":<span class="cov8" title="1">
                                        item["id"] = comment.ID</span>
                                case "type":<span class="cov8" title="1">
                                        item["type"] = comment.Type</span>
                                case "author":<span class="cov8" title="1">
                                        item["author"] = comment.Author</span>
                                case "body":<span class="cov8" title="1">
                                        item["body"] = comment.Body</span>
                                case "file":<span class="cov8" title="1">
                                        if comment.File != "" </span><span class="cov8" title="1">{
                                                item["file"] = comment.File
                                        }</span>
                                case "line":<span class="cov8" title="1">
                                        if comment.Line != 0 </span><span class="cov8" title="1">{
                                                item["line"] = comment.Line
                                        }</span>
                                case "created_at":<span class="cov8" title="1">
                                        item["created_at"] = comment.CreatedAt</span>
                                case "updated_at":<span class="cov8" title="1">
                                        item["updated_at"] = comment.UpdatedAt</span>
                                case "url":<span class="cov8" title="1">
                                        item["url"] = comment.URL</span>
                                case "diff_hunk":<span class="cov8" title="1">
                                        if comment.DiffHunk != "" </span><span class="cov8" title="1">{
                                                item["diff_hunk"] = comment.DiffHunk
                                        }</span>
                                case "commit_id":<span class="cov8" title="1">
                                        if comment.CommitID != "" </span><span class="cov0" title="0">{
                                                item["commit_id"] = comment.CommitID
                                        }</span>
                                case "in_reply_to":<span class="cov8" title="1">
                                        if comment.InReplyTo != 0 </span><span class="cov0" title="0">{
                                                item["in_reply_to"] = comment.InReplyTo
                                        }</span>
                                case "resolved":<span class="cov8" title="1">
                                        item["resolved"] = comment.Resolved</span>
                                }
                        }
                        <span class="cov8" title="1">filtered = append(filtered, item)</span>
                }
                <span class="cov8" title="1">return encoder.Encode(filtered)</span>
        }

        <span class="cov8" title="1">return encoder.Encode(comments)</span>
}

func exportCSV(w io.Writer, comments []ExportComment) error <span class="cov8" title="1">{
        csvWriter := csv.NewWriter(w)
        defer csvWriter.Flush()

        // Define headers
        headers := []string{"ID", "Type", "Author", "Body", "File", "Line", "Created At", "Updated At", "URL", "Resolved"}
        if len(exportInclude) &gt; 0 </span><span class="cov0" title="0">{
                headers = exportInclude
        }</span>

        // Write headers
        <span class="cov8" title="1">if err := csvWriter.Write(headers); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write data
        <span class="cov8" title="1">for _, comment := range comments </span><span class="cov8" title="1">{
                var row []string
                for _, header := range headers </span><span class="cov8" title="1">{
                        switch strings.ToLower(header) </span>{
                        case "id":<span class="cov8" title="1">
                                row = append(row, strconv.Itoa(comment.ID))</span>
                        case "type":<span class="cov8" title="1">
                                row = append(row, comment.Type)</span>
                        case "author":<span class="cov8" title="1">
                                row = append(row, comment.Author)</span>
                        case "body":<span class="cov8" title="1">
                                // Escape newlines in CSV
                                body := strings.ReplaceAll(comment.Body, "\n", "\\n")
                                row = append(row, body)</span>
                        case "file":<span class="cov8" title="1">
                                row = append(row, comment.File)</span>
                        case "line":<span class="cov8" title="1">
                                if comment.Line != 0 </span><span class="cov8" title="1">{
                                        row = append(row, strconv.Itoa(comment.Line))
                                }</span> else<span class="cov8" title="1"> {
                                        row = append(row, "")
                                }</span>
                        case "created at", "created_at":<span class="cov8" title="1">
                                row = append(row, comment.CreatedAt.Format(time.RFC3339))</span>
                        case "updated at", "updated_at":<span class="cov8" title="1">
                                if !comment.UpdatedAt.IsZero() </span><span class="cov0" title="0">{
                                        row = append(row, comment.UpdatedAt.Format(time.RFC3339))
                                }</span> else<span class="cov8" title="1"> {
                                        row = append(row, "")
                                }</span>
                        case "url":<span class="cov8" title="1">
                                row = append(row, comment.URL)</span>
                        case "resolved":<span class="cov8" title="1">
                                row = append(row, strconv.FormatBool(comment.Resolved))</span>
                        default:<span class="cov0" title="0">
                                row = append(row, "")</span>
                        }
                }
                <span class="cov8" title="1">if err := csvWriter.Write(row); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func exportMarkdown(w io.Writer, comments []ExportComment, repo string, pr int) error <span class="cov8" title="1">{
        fmt.Fprintf(w, "# PR Comments Export\n\n")
        fmt.Fprintf(w, "**Repository:** %s  \n", repo)
        fmt.Fprintf(w, "**PR:** #%d  \n", pr)
        fmt.Fprintf(w, "**Total Comments:** %d  \n", len(comments))
        fmt.Fprintf(w, "**Exported:** %s  \n\n", time.Now().Format("2006-01-02 15:04:05"))

        // Group by type
        var issueComments, reviewComments []ExportComment
        for _, comment := range comments </span><span class="cov8" title="1">{
                if comment.Type == "issue" </span><span class="cov8" title="1">{
                        issueComments = append(issueComments, comment)
                }</span> else<span class="cov8" title="1"> {
                        reviewComments = append(reviewComments, comment)
                }</span>
        }

        // Export issue comments
        <span class="cov8" title="1">if len(issueComments) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "## General PR Comments (%d)\n\n", len(issueComments))
                for _, comment := range issueComments </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "### Comment #%d\n", comment.ID)
                        fmt.Fprintf(w, "**Author:** @%s  \n", comment.Author)
                        fmt.Fprintf(w, "**Created:** %s  \n", comment.CreatedAt.Format("2006-01-02 15:04"))
                        fmt.Fprintf(w, "\n%s\n\n", comment.Body)
                        fmt.Fprintln(w, "---")
                }</span>
        }

        // Export review comments
        <span class="cov8" title="1">if len(reviewComments) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(w, "## Review Comments (%d)\n\n", len(reviewComments))
                for _, comment := range reviewComments </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "### Comment #%d\n", comment.ID)
                        fmt.Fprintf(w, "**Author:** @%s  \n", comment.Author)
                        fmt.Fprintf(w, "**File:** `%s:%d`  \n", comment.File, comment.Line)
                        fmt.Fprintf(w, "**Created:** %s  \n", comment.CreatedAt.Format("2006-01-02 15:04"))
                        if comment.Resolved </span><span class="cov8" title="1">{
                                fmt.Fprintln(w, "**Status:** ✅ Resolved")
                        }</span>
                        <span class="cov8" title="1">fmt.Fprintf(w, "\n%s\n\n", comment.Body)
                        if comment.DiffHunk != "" </span><span class="cov8" title="1">{
                                fmt.Fprintln(w, "```diff")
                                fmt.Fprintln(w, comment.DiffHunk)
                                fmt.Fprintln(w, "```")
                        }</span>
                        <span class="cov8" title="1">fmt.Fprintln(w, "---")</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func exportHTML(w io.Writer, comments []ExportComment, repo string, pr int) error <span class="cov8" title="1">{
        html := fmt.Sprintf(`&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;PR #%d Comments - %s&lt;/title&gt;
    &lt;style&gt;
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif; margin: 20px; line-height: 1.6; }
        h1, h2, h3 { color: #24292e; }
        .comment { background: #f6f8fa; border: 1px solid #d1d5da; border-radius: 6px; padding: 16px; margin-bottom: 16px; }
        .comment-header { margin-bottom: 8px; }
        .author { font-weight: bold; color: #0366d6; }
        .timestamp { color: #586069; font-size: 14px; }
        .file-info { background: #f1f8ff; padding: 4px 8px; border-radius: 3px; font-family: monospace; font-size: 12px; }
        .body { margin-top: 8px; }
        .diff { background: #fafbfc; border: 1px solid #e1e4e8; border-radius: 3px; padding: 8px; margin-top: 8px; overflow-x: auto; }
        pre { margin: 0; font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace; font-size: 12px; }
        .resolved { color: #28a745; font-size: 14px; }
        .stats { background: #f6f8fa; padding: 12px; border-radius: 6px; margin-bottom: 20px; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;PR #%d Comments Export&lt;/h1&gt;
    &lt;div class="stats"&gt;
        &lt;strong&gt;Repository:&lt;/strong&gt; %s&lt;br&gt;
        &lt;strong&gt;Total Comments:&lt;/strong&gt; %d&lt;br&gt;
        &lt;strong&gt;Exported:&lt;/strong&gt; %s
    &lt;/div&gt;
`, pr, repo, pr, repo, len(comments), time.Now().Format("2006-01-02 15:04:05"))

        // Group by type
        var issueComments, reviewComments []ExportComment
        for _, comment := range comments </span><span class="cov8" title="1">{
                if comment.Type == "issue" </span><span class="cov8" title="1">{
                        issueComments = append(issueComments, comment)
                }</span> else<span class="cov8" title="1"> {
                        reviewComments = append(reviewComments, comment)
                }</span>
        }

        // Export issue comments
        <span class="cov8" title="1">if len(issueComments) &gt; 0 </span><span class="cov8" title="1">{
                html += fmt.Sprintf("\n    &lt;h2&gt;General PR Comments (%d)&lt;/h2&gt;\n", len(issueComments))
                for _, comment := range issueComments </span><span class="cov8" title="1">{
                        html += fmt.Sprintf(`    &lt;div class="comment"&gt;
        &lt;div class="comment-header"&gt;
            &lt;span class="author"&gt;@%s&lt;/span&gt;
            &lt;span class="timestamp"&gt;%s&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class="body"&gt;%s&lt;/div&gt;
    &lt;/div&gt;
`, comment.Author, comment.CreatedAt.Format("Jan 2, 2006 15:04"), strings.ReplaceAll(comment.Body, "\n", "&lt;br&gt;"))
                }</span>
        }

        // Export review comments
        <span class="cov8" title="1">if len(reviewComments) &gt; 0 </span><span class="cov8" title="1">{
                html += fmt.Sprintf("\n    &lt;h2&gt;Review Comments (%d)&lt;/h2&gt;\n", len(reviewComments))
                for _, comment := range reviewComments </span><span class="cov8" title="1">{
                        resolvedTag := ""
                        if comment.Resolved </span><span class="cov8" title="1">{
                                resolvedTag = ` &lt;span class="resolved"&gt;✅ Resolved&lt;/span&gt;`
                        }</span>

                        <span class="cov8" title="1">diffSection := ""
                        if comment.DiffHunk != "" </span><span class="cov8" title="1">{
                                diffSection = fmt.Sprintf(`        &lt;div class="diff"&gt;&lt;pre&gt;%s&lt;/pre&gt;&lt;/div&gt;`, comment.DiffHunk)
                        }</span>

                        <span class="cov8" title="1">html += fmt.Sprintf(`    &lt;div class="comment"&gt;
        &lt;div class="comment-header"&gt;
            &lt;span class="author"&gt;@%s&lt;/span&gt;
            &lt;span class="file-info"&gt;%s:%d&lt;/span&gt;
            &lt;span class="timestamp"&gt;%s&lt;/span&gt;%s
        &lt;/div&gt;
        &lt;div class="body"&gt;%s&lt;/div&gt;
%s
    &lt;/div&gt;
`, comment.Author, comment.File, comment.Line, comment.CreatedAt.Format("Jan 2, 2006 15:04"),
                                resolvedTag, strings.ReplaceAll(comment.Body, "\n", "&lt;br&gt;"), diffSection)</span>
                }
        }

        <span class="cov8" title="1">html += "\n&lt;/body&gt;\n&lt;/html&gt;"

        _, err := fmt.Fprint(w, html)
        return err</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package cmd

import (
        "fmt"
        "strconv"
        "strings"
)

// Constants for API limits and defaults
const (
        MaxGraphQLResults = 100
        MaxCommentLength  = 65536 // GitHub's actual limit for comment body
        MaxFilePathLength = 4096  // Reasonable file path limit
        MaxAuthorLength   = 39    // GitHub username max length
        MaxRepoNameLength = 100   // GitHub repository name max length
        MaxBranchLength   = 255   // Git branch name max length
        DefaultPageSize   = 30

        // Display constants
        MaxDisplayBodyLength   = 200 // Max length for comment body display
        TruncationSuffix       = "..."
        TruncationReserve      = 3    // Length of "..."
        SeparatorLength        = 50   // Length of separator lines
        MessageTruncateLength  = 50   // Length for message truncation in batch dry-run
        CommitSHADisplayLength = 8    // Number of characters to show from commit SHA
        DefaultBufferSize      = 4096 // Default buffer size for I/O operations
)

// getPRContext gets the repository and PR number, handling both flag and auto-detection
func getPRContext() (repo string, pr int, err error) <span class="cov8" title="1">{
        repo, err = getCurrentRepo()
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, fmt.Errorf("failed to get repository: %w", err)
        }</span>

        <span class="cov8" title="1">if prNumber &gt; 0 </span><span class="cov8" title="1">{
                pr = prNumber
        }</span> else<span class="cov8" title="1"> {
                pr, err = getCurrentPR()
                if err != nil </span><span class="cov8" title="1">{
                        return "", 0, fmt.Errorf("failed to detect PR number: %w (try specifying --pr)", err)
                }</span>
        }

        <span class="cov8" title="1">return repo, pr, nil</span>
}

// formatAPIError creates consistent error messages for API failures
func formatAPIError(operation, endpoint string, err error) error <span class="cov8" title="1">{
        return fmt.Errorf("GitHub API error during %s: %w", operation, err)
}</span>

// formatActionableError creates user-friendly error messages with actionable suggestions
func formatActionableError(operation string, err error) error <span class="cov8" title="1">{
        errStr := err.Error()

        // Handle common GitHub API error patterns
        switch </span>{
        case containsAny(errStr, []string{"422", "Unprocessable Entity", "validation failed"}):<span class="cov8" title="1">
                return fmt.Errorf("validation error during %s: %w\n\n💡 Suggestions:\n  • Check if the line number exists in the PR diff\n  • Use 'gh comment lines &lt;pr&gt; &lt;file&gt;' to see commentable lines\n  • Verify the file path is correct in the PR\n  • For line-specific comments, ensure the line was modified in this PR", operation, err)</span>

        case containsAny(errStr, []string{"404", "Not Found"}):<span class="cov8" title="1">
                return fmt.Errorf("resource not found during %s: %w\n\n💡 Suggestions:\n  • Verify the PR number exists and is accessible\n  • Check if the comment ID is valid\n  • Ensure you have permission to access this repository", operation, err)</span>

        case containsAny(errStr, []string{"403", "Forbidden", "Resource not accessible by integration"}):<span class="cov8" title="1">
                return fmt.Errorf("permission denied during %s: %w\n\n💡 Suggestions:\n  • Check if you have write access to the repository\n  • Verify your GitHub authentication with 'gh auth status'\n  • You cannot approve your own PR or comment on private repos without access\n  • For organization repos, check if your token has the required scopes", operation, err)</span>

        case containsAny(errStr, []string{"401", "Unauthorized", "Bad credentials"}):<span class="cov8" title="1">
                return fmt.Errorf("authentication failed during %s: %w\n\n💡 Suggestions:\n  • Run 'gh auth login' to authenticate with GitHub\n  • Check if your token has expired with 'gh auth status'\n  • Verify you're authenticated with the correct GitHub account\n  • For personal access tokens, ensure they haven't been revoked", operation, err)</span>

        case containsAny(errStr, []string{"rate limit", "rate_limit", "too many requests", "API rate limit exceeded"}):<span class="cov8" title="1">
                return fmt.Errorf("rate limit exceeded during %s: %w\n\n💡 Suggestions:\n  • Wait until your rate limit resets (check headers or try in 1 hour)\n  • Use authenticated requests (ensure 'gh auth status' shows logged in)\n  • Consider reducing the frequency of API calls\n  • Check current rate limit: gh api rate_limit", operation, err)</span>

        case containsAny(errStr, []string{"500", "502", "503", "504", "Internal Server Error", "Bad Gateway", "Service Unavailable", "Gateway Timeout"}):<span class="cov8" title="1">
                return fmt.Errorf("GitHub server error during %s: %w\n\n💡 Suggestions:\n  • This is a temporary GitHub server issue\n  • Try again in a few minutes with exponential backoff\n  • Check GitHub's status page at https://status.github.com\n  • For 504 errors, try smaller batch sizes if applicable", operation, err)</span>

        case containsAny(errStr, []string{"timeout", "context deadline exceeded", "request timeout"}):<span class="cov8" title="1">
                return fmt.Errorf("network timeout during %s: %w\n\n💡 Suggestions:\n  • Check your internet connection stability\n  • Try again with a more stable network connection\n  • For large operations, consider breaking them into smaller chunks\n  • Increase timeout settings if configurable", operation, err)</span>

        case containsAny(errStr, []string{"connection refused", "connection reset", "network unreachable"}):<span class="cov0" title="0">
                return fmt.Errorf("network connection error during %s: %w\n\n💡 Suggestions:\n  • Check your internet connection\n  • Verify GitHub is accessible from your network\n  • Check if you're behind a corporate firewall\n  • Try using a different network or VPN", operation, err)</span>

        case containsAny(errStr, []string{"GraphQL", "Field", "doesn't exist", "Unknown field", "syntax error"}):<span class="cov0" title="0">
                return fmt.Errorf("GraphQL API error during %s: %w\n\n💡 Suggestions:\n  • This is likely a bug in the tool's GraphQL queries\n  • Try using the REST API fallback if available\n  • Update to the latest version of the tool\n  • Report this issue to the tool maintainers", operation, err)</span>

        case containsAny(errStr, []string{"secondary rate limit", "abuse detection"}):<span class="cov0" title="0">
                return fmt.Errorf("GitHub abuse detection triggered during %s: %w\n\n💡 Suggestions:\n  • You're making requests too rapidly\n  • Wait at least 1 minute before retrying\n  • Implement delays between requests\n  • Reduce concurrent operations", operation, err)</span>

        case containsAny(errStr, []string{"repository archived", "read-only", "archived"}):<span class="cov0" title="0">
                return fmt.Errorf("repository is archived during %s: %w\n\n💡 Suggestions:\n  • You cannot modify archived repositories\n  • Ask the repository owner to unarchive it\n  • Fork the repository if you need to make changes", operation, err)</span>

        case containsAny(errStr, []string{"token does not have", "insufficient scope", "scope"}):<span class="cov0" title="0">
                return fmt.Errorf("insufficient token permissions during %s: %w\n\n💡 Suggestions:\n  • Your token lacks required scopes for this operation\n  • Re-authenticate with 'gh auth login' with broader scopes\n  • For personal access tokens, check required scopes in GitHub settings\n  • Ensure token has 'repo' scope for private repositories", operation, err)</span>

        case containsAny(errStr, []string{"branch protection", "required status checks", "protected branch"}):<span class="cov0" title="0">
                return fmt.Errorf("branch protection rules violated during %s: %w\n\n💡 Suggestions:\n  • The target branch has protection rules enabled\n  • Required status checks may need to pass first\n  • Ask a repository administrator for required permissions\n  • Check branch protection settings in repository settings", operation, err)</span>

        case containsAny(errStr, []string{"pull request closed", "issue closed", "locked conversation"}):<span class="cov0" title="0">
                return fmt.Errorf("target is closed or locked during %s: %w\n\n💡 Suggestions:\n  • You cannot comment on closed/locked issues or PRs\n  • Ask a maintainer to reopen if necessary\n  • Create a new issue or PR if appropriate", operation, err)</span>

        case containsAny(errStr, []string{"No subschema in oneOf matched", "invalid request", "malformed"}):<span class="cov8" title="1">
                return fmt.Errorf("invalid request format during %s: %w\n\n💡 Suggestions:\n  • Check the command syntax in --help\n  • Verify all required arguments are provided\n  • For line comments, ensure the line exists in the PR diff\n  • Check for special characters that need escaping", operation, err)</span>

        case containsAny(errStr, []string{"review already submitted", "duplicate"}):<span class="cov0" title="0">
                return fmt.Errorf("duplicate operation during %s: %w\n\n💡 Suggestions:\n  • This review or comment already exists\n  • Use 'gh comment list' to check existing comments\n  • Use edit operations to modify existing content\n  • Dismiss existing reviews before submitting new ones", operation, err)</span>
        }

        // Default case - provide general guidance
        <span class="cov8" title="1">return fmt.Errorf("error during %s: %w\n\n💡 Suggestions:\n  • Check 'gh comment --help' for correct usage\n  • Verify PR number and file paths are correct\n  • Run with --verbose for more details\n  • Check GitHub's API status at https://status.github.com", operation, err)</span>
}

// containsAny checks if a string contains any of the provided substrings (case-insensitive)
func containsAny(str string, substrings []string) bool <span class="cov8" title="1">{
        lowerStr := strings.ToLower(str)
        for _, substr := range substrings </span><span class="cov8" title="1">{
                if strings.Contains(lowerStr, strings.ToLower(substr)) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// formatValidationError creates consistent error messages for validation failures
func formatValidationError(field, value, expected string) error <span class="cov8" title="1">{
        return fmt.Errorf("invalid %s '%s': %s", field, value, expected)
}</span>

// formatNotFoundError creates consistent error messages for missing resources
func formatNotFoundError(resource string, identifier interface{}) error <span class="cov8" title="1">{
        return fmt.Errorf("%s not found: %v", resource, identifier)
}</span>

// parsePositiveInt parses a string to a positive integer with consistent validation
func parsePositiveInt(s, fieldName string) (int, error) <span class="cov8" title="1">{
        val, err := strconv.Atoi(s)
        if err != nil </span><span class="cov8" title="1">{
                return 0, formatValidationError(fieldName, s, "must be a valid integer")
        }</span>
        <span class="cov8" title="1">if val &lt;= 0 </span><span class="cov8" title="1">{
                return 0, formatValidationError(fieldName, s, "must be a positive integer")
        }</span>
        <span class="cov8" title="1">return val, nil</span>
}

// validateCommentBody validates comment body length and content
func validateCommentBody(body string) error <span class="cov8" title="1">{
        if len(body) &gt; MaxCommentLength </span><span class="cov8" title="1">{
                return fmt.Errorf("comment too long: %d characters (maximum %d allowed)", len(body), MaxCommentLength)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validateFilePath validates file path length and format to prevent directory traversal
func validateFilePath(path string) error <span class="cov8" title="1">{
        if len(path) &gt; MaxFilePathLength </span><span class="cov8" title="1">{
                return fmt.Errorf("file path too long: %d characters (maximum %d allowed)", len(path), MaxFilePathLength)
        }</span>

        // Check for directory traversal attempts
        <span class="cov8" title="1">if strings.Contains(path, "..") </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid file path: directory traversal not allowed")
        }</span>

        // Check for absolute paths (should be relative to repo root)
        <span class="cov8" title="1">if strings.HasPrefix(path, "/") </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid file path: absolute paths not allowed, use relative paths from repository root")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateRepositoryName validates GitHub repository name format
func validateRepositoryName(repo string) error <span class="cov8" title="1">{
        if len(repo) &gt; MaxRepoNameLength </span><span class="cov8" title="1">{
                return fmt.Errorf("repository name too long: %d characters (maximum %d allowed)", len(repo), MaxRepoNameLength)
        }</span>

        // Check for basic owner/repo format
        <span class="cov8" title="1">parts := strings.Split(repo, "/")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid repository format: must be 'owner/repo'")
        }</span>

        <span class="cov8" title="1">owner, repoName := parts[0], parts[1]
        if len(owner) == 0 || len(repoName) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid repository format: owner and repository name cannot be empty")
        }</span>

        <span class="cov8" title="1">if len(owner) &gt; MaxAuthorLength </span><span class="cov8" title="1">{
                return fmt.Errorf("repository owner too long: %d characters (maximum %d allowed)", len(owner), MaxAuthorLength)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// lineRange represents a range of consecutive line numbers for display
type lineRange struct {
        start, end int
}

// groupConsecutiveLines groups consecutive line numbers into ranges for better display
func groupConsecutiveLines(lines []int) []lineRange <span class="cov8" title="1">{
        if len(lines) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var ranges []lineRange
        start := lines[0]
        end := lines[0]

        for i := 1; i &lt; len(lines); i++ </span><span class="cov8" title="1">{
                if lines[i] == end+1 </span><span class="cov8" title="1">{
                        // Consecutive line, extend the range
                        end = lines[i]
                }</span> else<span class="cov8" title="1"> {
                        // Gap found, close current range and start new one
                        ranges = append(ranges, lineRange{start: start, end: end})
                        start = lines[i]
                        end = lines[i]
                }</span>
        }

        // Add the final range
        <span class="cov8" title="1">ranges = append(ranges, lineRange{start: start, end: end})

        return ranges</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package cmd

import (
        "encoding/json"
        "fmt"
        "net/http"
        "net/http/httptest"
        "strconv"
        "strings"
        "sync"
        "time"
)

// MockGitHubServer represents a mock GitHub API server for integration testing
type MockGitHubServer struct {
        server   *httptest.Server
        mu       sync.RWMutex
        comments map[string][]MockComment
        reviews  map[string][]MockReview
        users    map[string]MockUser
}

// MockComment represents a GitHub comment for testing
type MockComment struct {
        ID        int       `json:"id"`
        Body      string    `json:"body"`
        User      MockUser  `json:"user"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
        HTMLURL   string    `json:"html_url"`
        Path      string    `json:"path,omitempty"`
        Line      int       `json:"line,omitempty"`
        StartLine int       `json:"start_line,omitempty"`
}

// MockReview represents a GitHub review for testing
type MockReview struct {
        ID       int           `json:"id"`
        Body     string        `json:"body"`
        User     MockUser      `json:"user"`
        State    string        `json:"state"`
        Comments []MockComment `json:"comments,omitempty"`
}

// MockUser represents a GitHub user for testing
type MockUser struct {
        Login string `json:"login"`
        ID    int    `json:"id"`
}

// MockPRDetails represents PR details for testing
type MockPRDetails struct {
        Number int `json:"number"`
        Head   struct {
                SHA string `json:"sha"`
        } `json:"head"`
}

// NewMockGitHubServer creates a new mock GitHub API server
func NewMockGitHubServer() *MockGitHubServer <span class="cov8" title="1">{
        s := &amp;MockGitHubServer{
                comments: make(map[string][]MockComment),
                reviews:  make(map[string][]MockReview),
                users: map[string]MockUser{
                        "test-user":    {Login: "test-user", ID: 1},
                        "reviewer":     {Login: "reviewer", ID: 2},
                        "senior-dev":   {Login: "senior-dev", ID: 3},
                        "security-bot": {Login: "security-bot", ID: 4},
                },
        }

        mux := http.NewServeMux()

        // GET /repos/{owner}/{repo}/pulls/{pr}/comments - List review comments
        mux.HandleFunc("/repos/", s.handleRepoRequests)

        s.server = httptest.NewServer(mux)
        return s
}</span>

// URL returns the mock server URL
func (s *MockGitHubServer) URL() string <span class="cov8" title="1">{
        return s.server.URL
}</span>

// Close shuts down the mock server
func (s *MockGitHubServer) Close() <span class="cov8" title="1">{
        s.server.Close()
}</span>

// AddComment adds a mock comment to the server state
func (s *MockGitHubServer) AddComment(repo string, pr int, comment MockComment) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        key := fmt.Sprintf("%s/%d", repo, pr)
        if comment.ID == 0 </span><span class="cov8" title="1">{
                comment.ID = len(s.comments[key]) + 1000
        }</span>
        <span class="cov8" title="1">if comment.CreatedAt.IsZero() </span><span class="cov8" title="1">{
                comment.CreatedAt = time.Now()
        }</span>
        <span class="cov8" title="1">if comment.UpdatedAt.IsZero() </span><span class="cov8" title="1">{
                comment.UpdatedAt = comment.CreatedAt
        }</span>
        <span class="cov8" title="1">if comment.HTMLURL == "" </span><span class="cov8" title="1">{
                comment.HTMLURL = fmt.Sprintf("%s/repos/%s/pulls/%d#issuecomment-%d", s.URL(), repo, pr, comment.ID)
        }</span>

        <span class="cov8" title="1">s.comments[key] = append(s.comments[key], comment)</span>
}

// GetComments returns comments for a PR
func (s *MockGitHubServer) GetComments(repo string, pr int) []MockComment <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        key := fmt.Sprintf("%s/%d", repo, pr)
        return s.comments[key]
}</span>

// SetupTestScenario sets up predefined test data
func (s *MockGitHubServer) SetupTestScenario(scenario string) <span class="cov8" title="1">{
        switch scenario </span>{
        case "basic":<span class="cov8" title="1">
                s.AddComment("test-owner/test-repo", 123, MockComment{
                        Body: "This looks good to me!",
                        User: s.users["test-user"],
                })
                s.AddComment("test-owner/test-repo", 123, MockComment{
                        Body: "Please fix the typo in line 42",
                        User: s.users["reviewer"],
                        Path: "src/main.go",
                        Line: 42,
                })</span>
        case "security-review":<span class="cov8" title="1">
                s.AddComment("test-owner/test-repo", 456, MockComment{
                        Body: "Security scan detected potential SQL injection vulnerability",
                        User: s.users["security-bot"],
                        Path: "database.py",
                        Line: 156,
                })
                s.AddComment("test-owner/test-repo", 456, MockComment{
                        Body: "Use crypto.randomBytes(32) instead of Math.random() for token generation",
                        User: s.users["senior-dev"],
                        Path: "auth.go",
                        Line: 67,
                })</span>
        }
}

// handleRepoRequests handles all repository-related API requests
func (s *MockGitHubServer) handleRepoRequests(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        path := strings.TrimPrefix(r.URL.Path, "/repos/")
        parts := strings.Split(path, "/")

        if len(parts) &lt; 2 </span><span class="cov8" title="1">{
                http.Error(w, "Invalid repository path", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">owner, repo := parts[0], parts[1]
        repoKey := fmt.Sprintf("%s/%s", owner, repo)

        // Handle different API endpoints
        if len(parts) &gt;= 4 &amp;&amp; parts[2] == "pulls" </span><span class="cov8" title="1">{
                prStr := parts[3]
                pr, err := strconv.Atoi(prStr)
                if err != nil </span><span class="cov8" title="1">{
                        http.Error(w, "Invalid PR number", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">if len(parts) == 4 </span><span class="cov8" title="1">{
                        // GET /repos/{owner}/{repo}/pulls/{pr} - Get PR details
                        if r.Method == "GET" </span><span class="cov8" title="1">{
                                s.handleGetPRDetails(w, r, repoKey, pr)
                                return
                        }</span>
                }

                <span class="cov8" title="1">if len(parts) &gt;= 5 &amp;&amp; parts[4] == "comments" </span><span class="cov8" title="1">{
                        switch r.Method </span>{
                        case "GET":<span class="cov8" title="1">
                                // GET /repos/{owner}/{repo}/pulls/{pr}/comments - List comments
                                s.handleListComments(w, r, repoKey, pr)</span>
                        case "POST":<span class="cov0" title="0">
                                // POST /repos/{owner}/{repo}/pulls/{pr}/comments - Create comment
                                s.handleCreateComment(w, r, repoKey, pr)</span>
                        }
                }

                <span class="cov8" title="1">if len(parts) &gt;= 5 &amp;&amp; parts[4] == "reviews" </span><span class="cov0" title="0">{
                        if r.Method == "POST" </span><span class="cov0" title="0">{
                                // POST /repos/{owner}/{repo}/pulls/{pr}/reviews - Create review
                                s.handleCreateReview(w, r, repoKey, pr)
                        }</span>
                }
        }

        <span class="cov8" title="1">if len(parts) &gt;= 4 &amp;&amp; parts[2] == "issues" </span><span class="cov8" title="1">{
                prStr := parts[3]
                pr, err := strconv.Atoi(prStr)
                if err != nil </span><span class="cov8" title="1">{
                        http.Error(w, "Invalid issue number", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">if len(parts) &gt;= 5 &amp;&amp; parts[4] == "comments" </span><span class="cov8" title="1">{
                        switch r.Method </span>{
                        case "GET":<span class="cov8" title="1">
                                // GET /repos/{owner}/{repo}/issues/{pr}/comments - List issue comments
                                s.handleListIssueComments(w, r, repoKey, pr)</span>
                        case "POST":<span class="cov0" title="0">
                                // POST /repos/{owner}/{repo}/issues/{pr}/comments - Create issue comment
                                s.handleCreateIssueComment(w, r, repoKey, pr)</span>
                        }
                }
        }
}

// handleGetPRDetails handles GET /repos/{owner}/{repo}/pulls/{pr}
func (s *MockGitHubServer) handleGetPRDetails(w http.ResponseWriter, r *http.Request, repo string, pr int) <span class="cov8" title="1">{
        details := MockPRDetails{
                Number: pr,
        }
        details.Head.SHA = "abc123def456" // Mock commit SHA

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(details)
}</span>

// handleListComments handles GET /repos/{owner}/{repo}/pulls/{pr}/comments
func (s *MockGitHubServer) handleListComments(w http.ResponseWriter, r *http.Request, repo string, pr int) <span class="cov8" title="1">{
        comments := s.GetComments(repo, pr)

        // Filter for review comments only (have path/line)
        var reviewComments []MockComment
        for _, comment := range comments </span><span class="cov8" title="1">{
                if comment.Path != "" </span><span class="cov8" title="1">{
                        reviewComments = append(reviewComments, comment)
                }</span>
        }

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(reviewComments)</span>
}

// handleListIssueComments handles GET /repos/{owner}/{repo}/issues/{pr}/comments
func (s *MockGitHubServer) handleListIssueComments(w http.ResponseWriter, r *http.Request, repo string, pr int) <span class="cov8" title="1">{
        comments := s.GetComments(repo, pr)

        // Filter for issue comments only (no path/line)
        var issueComments []MockComment
        for _, comment := range comments </span><span class="cov8" title="1">{
                if comment.Path == "" </span><span class="cov8" title="1">{
                        issueComments = append(issueComments, comment)
                }</span>
        }

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(issueComments)</span>
}

// handleCreateComment handles POST /repos/{owner}/{repo}/pulls/{pr}/comments
func (s *MockGitHubServer) handleCreateComment(w http.ResponseWriter, r *http.Request, repo string, pr int) <span class="cov0" title="0">{
        var comment MockComment
        if err := json.NewDecoder(r.Body).Decode(&amp;comment); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        // Set defaults
        <span class="cov0" title="0">comment.User = s.users["test-user"] // Default test user
        s.AddComment(repo, pr, comment)

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(comment)</span>
}

// handleCreateIssueComment handles POST /repos/{owner}/{repo}/issues/{pr}/comments
func (s *MockGitHubServer) handleCreateIssueComment(w http.ResponseWriter, r *http.Request, repo string, pr int) <span class="cov0" title="0">{
        var comment MockComment
        if err := json.NewDecoder(r.Body).Decode(&amp;comment); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        // Issue comments don't have path/line
        <span class="cov0" title="0">comment.Path = ""
        comment.Line = 0
        comment.StartLine = 0
        comment.User = s.users["test-user"]

        s.AddComment(repo, pr, comment)

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(comment)</span>
}

// handleCreateReview handles POST /repos/{owner}/{repo}/pulls/{pr}/reviews
func (s *MockGitHubServer) handleCreateReview(w http.ResponseWriter, r *http.Request, repo string, pr int) <span class="cov0" title="0">{
        var review MockReview
        if err := json.NewDecoder(r.Body).Decode(&amp;review); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">s.mu.Lock()
        defer s.mu.Unlock()

        key := fmt.Sprintf("%s/%d", repo, pr)
        review.ID = len(s.reviews[key]) + 2000
        review.User = s.users["test-user"]

        // Add review comments to the comment list
        for _, comment := range review.Comments </span><span class="cov0" title="0">{
                comment.User = s.users["test-user"]
                s.AddComment(repo, pr, comment)
        }</span>

        <span class="cov0" title="0">s.reviews[key] = append(s.reviews[key], review)

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(review)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package cmd

import (
        "fmt"
        "sort"
        "strconv"
        "strings"

        "github.com/MakeNowJust/heredoc"
        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
)

var (
        showCodeContext bool
        linesClient     github.GitHubAPI
)

var linesCmd = &amp;cobra.Command{
        Use:   "lines &lt;pr&gt; &lt;file&gt;",
        Short: "Show commentable lines in a PR file",
        Long: heredoc.Doc(`
                Show which lines in a file can receive comments based on the PR diff.

                This command helps debug failed comment attempts by showing exactly which
                lines are available for commenting. GitHub only allows comments on lines
                that are part of the diff (added, modified, or in context).

                Note: Newly added files may not show commentable lines due to GitHub API
                limitations. If no lines are shown, try commenting on any line directly.

                Use this command when you get HTTP 422 errors trying to add line comments.
        `),
        Example: heredoc.Doc(`
                # Show commentable lines in a specific file
                $ gh comment lines 123 src/main.go

                # Show lines with code context
                $ gh comment lines 123 src/main.go --show-code

                # Check if specific line is commentable
                $ gh comment lines 123 src/main.go | grep "^42:"

                # Get line ranges for scripting
                $ gh comment lines 123 src/main.go | grep -o "^[0-9]*" | head -5
        `),
        Args: cobra.ExactArgs(2),
        RunE: runLines,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(linesCmd)
        linesCmd.Flags().BoolVar(&amp;showCodeContext, "show-code", false, "Show actual code content for each line")
}</span>

func runLines(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if linesClient == nil </span><span class="cov8" title="1">{
                client, err := createGitHubClient()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create GitHub client: %w", err)
                }</span>
                <span class="cov8" title="1">linesClient = client</span>
        }

        // Parse PR number
        <span class="cov8" title="1">pr, err := strconv.Atoi(args[0])
        if err != nil </span><span class="cov8" title="1">{
                return formatValidationError("PR number", args[0], "must be a valid integer")
        }</span>

        // Get file path
        <span class="cov8" title="1">filePath := args[1]

        // Get repository context
        repository, err := getCurrentRepo()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Parse owner/repo
        <span class="cov8" title="1">parts := strings.Split(repository, "/")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid repository format: %s (expected owner/repo)", repository)
        }</span>
        <span class="cov8" title="1">owner, repoName := parts[0], parts[1]

        if verbose </span><span class="cov8" title="1">{
                fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("PR: %d\n", pr)
                fmt.Printf("File: %s\n", filePath)
                fmt.Println()
        }</span>

        <span class="cov8" title="1">if dryRun </span><span class="cov8" title="1">{
                fmt.Printf("Would show commentable lines for file %s in PR #%d\n", filePath, pr)
                return nil
        }</span>

        // Fetch PR diff
        <span class="cov8" title="1">diff, err := linesClient.FetchPRDiff(owner, repoName, pr)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to fetch PR diff: %w", err)
        }</span>

        // Find the requested file in the diff
        <span class="cov8" title="1">var targetFile *github.DiffFile
        for i := range diff.Files </span><span class="cov8" title="1">{
                if diff.Files[i].Filename == filePath </span><span class="cov8" title="1">{
                        targetFile = &amp;diff.Files[i]
                        break</span>
                }
        }

        <span class="cov8" title="1">if targetFile == nil </span><span class="cov8" title="1">{
                fmt.Printf("❌ File '%s' not found in PR #%d diff\n\n", filePath, pr)
                fmt.Println("Available files in this PR:")
                for _, file := range diff.Files </span><span class="cov8" title="1">{
                        fmt.Printf("  • %s\n", file.Filename)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        // Display commentable lines
        <span class="cov8" title="1">if len(targetFile.Lines) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("❌ No commentable lines found in %s\n", filePath)
                fmt.Println("This file may not have any changes in this PR.")
                return nil
        }</span>

        <span class="cov8" title="1">fmt.Printf("✅ Commentable lines in %s (PR #%d):\n\n", filePath, pr)

        // Sort line numbers
        var lineNumbers []int
        for lineNum := range targetFile.Lines </span><span class="cov8" title="1">{
                lineNumbers = append(lineNumbers, lineNum)
        }</span>
        <span class="cov8" title="1">sort.Ints(lineNumbers)

        // Group consecutive lines for better display
        ranges := groupConsecutiveLines(lineNumbers)

        fmt.Printf("📍 Line ranges available for comments:\n")
        for _, lineRange := range ranges </span><span class="cov8" title="1">{
                if lineRange.start == lineRange.end </span><span class="cov0" title="0">{
                        fmt.Printf("  • Line %d\n", lineRange.start)
                }</span> else<span class="cov8" title="1"> {
                        fmt.Printf("  • Lines %d-%d\n", lineRange.start, lineRange.end)
                }</span>
        }

        <span class="cov8" title="1">fmt.Printf("\n📝 Individual lines:\n")
        for _, lineNum := range lineNumbers </span><span class="cov8" title="1">{
                if showCodeContext </span><span class="cov0" title="0">{
                        // In a real implementation, you'd fetch the actual file content
                        // For now, just show the line numbers
                        fmt.Printf("%d: [code content would be shown here]\n", lineNum)
                }</span> else<span class="cov8" title="1"> {
                        fmt.Printf("%d\n", lineNum)
                }</span>
        }

        <span class="cov8" title="1">fmt.Printf("\n💡 Usage examples:\n")
        fmt.Printf("  • Single line:  gh comment add %d %s %d \"Your comment\"\n", pr, filePath, lineNumbers[0])
        if len(lineNumbers) &gt; 1 </span><span class="cov8" title="1">{
                fmt.Printf("  • Range comment: gh comment add %d %s %d:%d \"Range comment\"\n", pr, filePath, lineNumbers[0], lineNumbers[len(lineNumbers)-1])
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package cmd

import (
        "encoding/json"
        "fmt"
        "os"
        "regexp"
        "strings"
        "time"

        "github.com/MakeNowJust/heredoc"
        "github.com/markusmobius/go-dateparser"
        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
)

var (
        showResolved   bool
        onlyUnresolved bool
        author         string
        quiet          bool
        hideAuthors    bool

        // Advanced filtering flags
        status   string
        since    string
        until    string
        resolved string
        listType string

        // Output format flags
        outputFormat string
        idsOnly      bool

        // Parsed time values
        sinceTime *time.Time
        untilTime *time.Time

        // Client for dependency injection (tests can override)
        listClient github.GitHubAPI
)

var listCmd = &amp;cobra.Command{
        Use:   "list [pr]",
        Short: "List comments with advanced filtering and formatting options",
        Long: heredoc.Doc(`
                List all comments on a pull request with powerful filtering capabilities.

                Comment Types:
                - Issue comments: General PR discussion, appear in main conversation tab
                - Review comments: Line-specific feedback, appear in "Files Changed" tab

                Comments can be filtered by type, author, date range, resolution status, and more.
                Output can be formatted as tables, JSON, or plain text with color coding.
                Perfect for code review workflows, comment analysis, and automation.
        `),
        Example: heredoc.Doc(`
                # Review team analysis and metrics
                $ gh comment list 123 --author "senior-dev*" --status open --since "1 week ago"
                $ gh comment list 123 --type review --author "*@company.com" --since "2024-01-01"

                # Security audit and compliance tracking
                $ gh comment list 123 --author "security-team*" --since "2024-01-01" --type review
                $ gh comment list 123 --author "bot*" --since "3 days ago" --quiet

                # Structured output for automation
                $ gh comment list 123 --format json | jq '.comments[].id'
                $ gh comment list 123 --ids-only | xargs -I {} gh comment resolve {}
                $ gh comment list 123 --format json --author "security*" &gt; security-comments.json

                # Code review workflow optimization
                $ gh comment list 123 --status open --since "1 month ago" --author "lead*"
                $ gh comment list 123 --until "2024-12-31" --type issue --status resolved

                # Team communication patterns
                $ gh comment list 123 --author "qa*" --since "3 days ago" --type review
                $ gh comment list 123 --author "*@contractor.com" --status open --since "1 month ago"

                # Blocker identification and resolution tracking
                $ gh comment list 123 --author "architect*" --status open --type review
                $ gh comment list 123 --since "critical-bug-report" --author "oncall*" --status resolved

                # Performance review analysis
                $ gh comment list 123 --author "performance-team" --since "load-test-date" --type review
                $ gh comment list 123 --status open --author "*perf*" --since "1 week ago"

                # Export for further analysis and automation
                $ gh comment list 123 --author "all-reviewers*" --since "quarter-start" --quiet | process-review-data.sh
                $ gh comment list 123 --ids-only --type review --status open | review-metrics.sh
        `),
        Args:   cobra.MaximumNArgs(1),
        PreRun: applyListConfigDefaults,
        RunE:   runList,
}

// applyListConfigDefaults applies configuration defaults to list command flags
func applyListConfigDefaults(cmd *cobra.Command, args []string) <span class="cov8" title="1">{
        config := GetConfig()

        // Apply filter defaults if flags weren't explicitly set
        if !cmd.Flags().Changed("author") &amp;&amp; config.Defaults.Author != "" </span><span class="cov8" title="1">{
                author = config.Defaults.Author
        }</span>
        <span class="cov8" title="1">if !cmd.Flags().Changed("status") &amp;&amp; config.Filters.Status != "" </span><span class="cov8" title="1">{
                status = config.Filters.Status
        }</span>
        <span class="cov8" title="1">if !cmd.Flags().Changed("type") &amp;&amp; config.Filters.Type != "" </span><span class="cov8" title="1">{
                listType = config.Filters.Type
        }</span>
        <span class="cov8" title="1">if !cmd.Flags().Changed("since") &amp;&amp; config.Filters.Since != "" </span><span class="cov8" title="1">{
                since = config.Filters.Since
        }</span>
        <span class="cov8" title="1">if !cmd.Flags().Changed("until") &amp;&amp; config.Filters.Until != "" </span><span class="cov8" title="1">{
                until = config.Filters.Until
        }</span>

        // Apply display defaults
        <span class="cov8" title="1">if !cmd.Flags().Changed("format") &amp;&amp; config.Display.Format != "table" </span><span class="cov8" title="1">{
                // Map config format to list command format
                switch config.Display.Format </span>{
                case "json":<span class="cov8" title="1">
                        outputFormat = "json"</span>
                case "quiet":<span class="cov8" title="1">
                        quiet = true</span>
                }
        }
        <span class="cov8" title="1">if !cmd.Flags().Changed("quiet") &amp;&amp; config.Display.Quiet </span><span class="cov8" title="1">{
                quiet = config.Display.Quiet
        }</span>
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(listCmd)

        // Legacy flags (kept for backward compatibility)
        listCmd.Flags().BoolVar(&amp;showResolved, "resolved", false, "Include resolved comments (legacy, use --status instead) (default: false)")
        listCmd.Flags().BoolVar(&amp;onlyUnresolved, "unresolved", false, "Show only unresolved comments (legacy, use --status instead) (default: false)")

        // Enhanced filtering flags
        listCmd.Flags().StringVar(&amp;author, "author", "", "Filter comments by author (supports wildcards: 'user*', '*@company.com') (default: all authors)")
        listCmd.Flags().StringVar(&amp;status, "status", "all", "Filter by comment status (open|resolved|all) (default: all)")
        listCmd.Flags().StringVar(&amp;since, "since", "", "Show comments created after date (e.g., '2024-01-01', '1 week ago', '3 days ago') (default: all dates)")
        listCmd.Flags().StringVar(&amp;until, "until", "", "Show comments created before date (e.g., '2024-12-31', '1 day ago') (default: all dates)")
        listCmd.Flags().StringVar(&amp;resolved, "resolved-status", "", "Filter by resolution status (pending|resolved|dismissed) (default: all)")
        listCmd.Flags().StringVar(&amp;listType, "type", "all", "Filter by comment type (issue|review|all) (default: all)")

        // Display options
        listCmd.Flags().BoolVarP(&amp;quiet, "quiet", "q", false, "Minimal output without URLs and IDs (default: false, shows full context)")
        listCmd.Flags().BoolVar(&amp;hideAuthors, "hide-authors", false, "Hide author names for privacy (default: false)")

        // Output format options
        listCmd.Flags().StringVar(&amp;outputFormat, "format", "default", "Output format (default|json) (default: default)")
        listCmd.Flags().BoolVar(&amp;idsOnly, "ids-only", false, "Output only comment IDs (one per line) (default: false)")
}</span>

func runList(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if listClient == nil </span><span class="cov8" title="1">{
                client, err := createGitHubClient()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to initialize GitHub client: %w", err)
                }</span>
                <span class="cov8" title="1">listClient = client</span>
        }

        // Parse and validate command arguments
        <span class="cov8" title="1">repository, pr, err := parseListArguments(args)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Fetch and filter comments based on criteria
        <span class="cov8" title="1">filteredComments, err := fetchAndFilterComments(listClient, repository, pr)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Format and display the output
        <span class="cov8" title="1">return formatListOutput(filteredComments, pr)</span>
}

// parseListArguments handles validation and parsing of command arguments and flags
func parseListArguments(args []string) (repository string, pr int, err error) <span class="cov8" title="1">{
        // Validate and parse filtering flags
        if err := validateAndParseFilters(); err != nil </span><span class="cov8" title="1">{
                return "", 0, err
        }</span>

        // Parse PR argument using centralized function
        <span class="cov8" title="1">if len(args) == 1 </span><span class="cov8" title="1">{
                pr, err = parsePositiveInt(args[0], "PR number")
                if err != nil </span><span class="cov8" title="1">{
                        return "", 0, err
                }</span>
                // Get repository for explicitly provided PR
                <span class="cov8" title="1">repository, err = getCurrentRepo()
                if err != nil </span><span class="cov0" title="0">{
                        return "", 0, err
                }</span>
        } else<span class="cov0" title="0"> {
                // Auto-detect PR and repository using centralized function
                repository, pr, err = getPRContext()
                if err != nil </span><span class="cov0" title="0">{
                        return "", 0, err
                }</span>
        }

        <span class="cov8" title="1">return repository, pr, nil</span>
}

// fetchAndFilterComments handles verbose output, comment fetching, and filtering
func fetchAndFilterComments(client github.GitHubAPI, repository string, pr int) ([]Comment, error) <span class="cov8" title="1">{
        if verbose </span><span class="cov8" title="1">{
                fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("PR: %d\n", pr)
                fmt.Printf("Show resolved: %v\n", showResolved)
                fmt.Printf("Only unresolved: %v\n", onlyUnresolved)
                fmt.Printf("Quiet mode: %v\n", quiet)
                fmt.Printf("Hide authors: %v\n", hideAuthors)
                if author != "" </span><span class="cov8" title="1">{
                        fmt.Printf("Filter by author: %s\n", author)
                }</span>
                <span class="cov8" title="1">fmt.Println()</span>
        }

        // Fetch comments
        <span class="cov8" title="1">comments, err := fetchAllComments(client, repository, pr)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Filter comments
        <span class="cov8" title="1">filteredComments := filterComments(comments)
        return filteredComments, nil</span>
}

// formatListOutput handles different output formats and display
func formatListOutput(filteredComments []Comment, pr int) error <span class="cov8" title="1">{
        // Handle different output formats
        if idsOnly </span><span class="cov0" title="0">{
                displayIDsOnly(filteredComments)
        }</span> else<span class="cov8" title="1"> if outputFormat == "json" </span><span class="cov0" title="0">{
                if err := displayCommentsJSON(filteredComments, pr); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to encode JSON output: %w", err)
                }</span>
        } else<span class="cov8" title="1"> {
                displayComments(filteredComments, pr)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

type Comment struct {
        ID        int       `json:"id"`
        Author    string    `json:"author"`
        Body      string    `json:"body"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
        HTMLURL   string    `json:"html_url"`

        // For line-specific comments
        Path      string `json:"path,omitempty"`
        Line      int    `json:"line,omitempty"`
        StartLine int    `json:"start_line,omitempty"`
        DiffHunk  string `json:"diff_hunk,omitempty"`
        CommitID  string `json:"commit_id,omitempty"`

        // Comment type
        Type string `json:"type"` // "issue" or "review"

        // Resolution status (for review comments)
        State string `json:"state,omitempty"` // "pending", "submitted", etc.
}

func fetchAllComments(client github.GitHubAPI, repo string, pr int) ([]Comment, error) <span class="cov8" title="1">{
        // Parse owner/repo
        parts := strings.Split(repo, "/")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid repository format: %s (expected owner/repo)", repo)
        }</span>
        <span class="cov8" title="1">owner, repoName := parts[0], parts[1]

        var allComments []Comment

        // Fetch general PR comments (issue comments)
        issueComments, err := client.ListIssueComments(owner, repoName, pr)
        if err != nil </span><span class="cov8" title="1">{
                return nil, formatActionableError("issue comments fetch", err)
        }</span>

        // Convert issue comments
        <span class="cov8" title="1">for _, comment := range issueComments </span><span class="cov8" title="1">{
                allComments = append(allComments, Comment{
                        ID:        comment.ID,
                        Author:    comment.User.Login,
                        Body:      comment.Body,
                        CreatedAt: comment.CreatedAt,
                        UpdatedAt: comment.UpdatedAt,
                        HTMLURL:   "", // TODO: Add HTMLURL to github.Comment
                        Type:      "issue",
                })
        }</span>

        // Fetch review comments (line-specific)
        <span class="cov8" title="1">reviewComments, err := client.ListReviewComments(owner, repoName, pr)
        if err != nil </span><span class="cov8" title="1">{
                return nil, formatActionableError("review comments fetch", err)
        }</span>

        // Convert review comments
        <span class="cov8" title="1">for _, comment := range reviewComments </span><span class="cov8" title="1">{
                allComments = append(allComments, Comment{
                        ID:        comment.ID,
                        Author:    comment.User.Login,
                        Body:      comment.Body,
                        CreatedAt: comment.CreatedAt,
                        UpdatedAt: comment.UpdatedAt,
                        HTMLURL:   "", // TODO: Add HTMLURL to github.Comment
                        Path:      comment.Path,
                        Line:      comment.Line,
                        CommitID:  comment.CommitID,
                        Type:      "review",
                })
        }</span>

        <span class="cov8" title="1">return allComments, nil</span>
}

func validateAndParseFilters() error <span class="cov8" title="1">{
        // Validate status flag
        validStatuses := []string{"all", "open", "resolved"}
        if status != "" &amp;&amp; !containsString(validStatuses, status) </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid status '%s'. Must be one of: %s", status, strings.Join(validStatuses, ", "))
        }</span>

        // Validate comment type flag
        <span class="cov8" title="1">validTypes := []string{"all", "issue", "review"}
        if listType != "" &amp;&amp; !containsString(validTypes, listType) </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid type '%s'. Must be one of: %s", listType, strings.Join(validTypes, ", "))
        }</span>

        // Validate output format flag
        <span class="cov8" title="1">validFormats := []string{"default", "json"}
        if outputFormat != "" &amp;&amp; !containsString(validFormats, outputFormat) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid format '%s'. Must be one of: %s", outputFormat, strings.Join(validFormats, ", "))
        }</span>

        // Handle conflicting output options
        <span class="cov8" title="1">if idsOnly &amp;&amp; outputFormat == "json" </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot use --ids-only with --format json (use --format json to get structured data including IDs)")
        }</span>

        // Parse since date
        <span class="cov8" title="1">if since != "" </span><span class="cov8" title="1">{
                parsedTime, err := parseFlexibleDate(since)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid since date '%s': %w", since, err)
                }</span>
                <span class="cov8" title="1">sinceTime = &amp;parsedTime</span>
        }

        // Parse until date
        <span class="cov8" title="1">if until != "" </span><span class="cov8" title="1">{
                parsedTime, err := parseFlexibleDate(until)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid until date '%s': %w", until, err)
                }</span>
                <span class="cov8" title="1">untilTime = &amp;parsedTime</span>
        }

        // Validate date range
        <span class="cov8" title="1">if sinceTime != nil &amp;&amp; untilTime != nil &amp;&amp; sinceTime.After(*untilTime) </span><span class="cov8" title="1">{
                return fmt.Errorf("since date (%s) cannot be after until date (%s)", since, until)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func parseFlexibleDate(dateStr string) (time.Time, error) <span class="cov8" title="1">{
        parsed, err := dateparser.Parse(nil, strings.TrimSpace(dateStr))
        if err != nil </span><span class="cov8" title="1">{
                return time.Time{}, err
        }</span>
        <span class="cov8" title="1">return parsed.Time, nil</span>
}

func filterComments(comments []Comment) []Comment <span class="cov8" title="1">{
        var filtered []Comment

        for _, comment := range comments </span><span class="cov8" title="1">{
                // Filter by author (supports wildcards)
                if author != "" &amp;&amp; !matchesAuthorFilter(comment.Author, author) </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Filter by comment type
                <span class="cov8" title="1">if listType != "all" &amp;&amp; comment.Type != listType </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Filter by status (legacy support)
                <span class="cov8" title="1">if showResolved &amp;&amp; onlyUnresolved </span>{<span class="cov0" title="0">
                        // Conflicting flags - show all
                }</span> else<span class="cov8" title="1"> if onlyUnresolved </span><span class="cov0" title="0">{
                        // Only show unresolved comments (this is a placeholder - actual resolution status would come from API)
                        // For now, we'll consider all comments as "open" since we don't have resolution data
                        if status == "resolved" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                } else<span class="cov8" title="1"> if !showResolved </span><span class="cov8" title="1">{
                        // Default behavior - don't show resolved comments
                        if status == "resolved" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                // Filter by new status flag
                <span class="cov8" title="1">if status != "all" </span><span class="cov0" title="0">{
                        // This is a placeholder for actual resolution status filtering
                        // In a real implementation, you'd check comment.ResolvedAt or similar
                        // For now, we'll treat all comments as "open"
                        if status == "resolved" </span><span class="cov0" title="0">{
                                continue</span> // Skip since we don't have resolution data yet
                        }
                }

                // Filter by date range
                <span class="cov8" title="1">if sinceTime != nil &amp;&amp; comment.CreatedAt.Before(*sinceTime) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if untilTime != nil &amp;&amp; comment.CreatedAt.After(*untilTime) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">filtered = append(filtered, comment)</span>
        }

        <span class="cov8" title="1">return filtered</span>
}

func matchesAuthorFilter(author, filter string) bool <span class="cov8" title="1">{
        // Exact match
        if author == filter </span><span class="cov8" title="1">{
                return true
        }</span>

        // Wildcard matching
        <span class="cov8" title="1">if strings.Contains(filter, "*") </span><span class="cov8" title="1">{
                // Convert wildcard pattern to regex
                pattern := strings.ReplaceAll(regexp.QuoteMeta(filter), `\*`, `.*`)
                pattern = "^" + pattern + "$"

                if matched, err := regexp.MatchString(pattern, author); err == nil &amp;&amp; matched </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        // Case-insensitive partial match
        <span class="cov8" title="1">return strings.Contains(strings.ToLower(author), strings.ToLower(filter))</span>
}

func containsString(slice []string, item string) bool <span class="cov8" title="1">{
        for _, s := range slice </span><span class="cov8" title="1">{
                if s == item </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func displayComments(comments []Comment, pr int) <span class="cov8" title="1">{
        if len(comments) == 0 </span><span class="cov8" title="1">{
                fmt.Printf("No comments found on PR #%d\n", pr)
                return
        }</span>

        // Collect unique commit IDs for summary
        <span class="cov8" title="1">commitIDs := make(map[string]bool)
        for _, comment := range comments </span><span class="cov8" title="1">{
                if comment.CommitID != "" </span><span class="cov8" title="1">{
                        commitIDs[comment.CommitID] = true
                }</span>
        }

        <span class="cov8" title="1">fmt.Printf("📝 Comments on PR #%d (%d total", pr, len(comments))
        if len(commitIDs) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf(", %d commit", len(commitIDs))
                if len(commitIDs) != 1 </span><span class="cov8" title="1">{
                        fmt.Printf("s")
                }</span>
        }
        <span class="cov8" title="1">fmt.Printf(")\n\n")

        // Group comments by type
        var issueComments, reviewComments, lineComments []Comment
        for _, comment := range comments </span><span class="cov8" title="1">{

                if comment.Type == "issue" </span><span class="cov8" title="1">{
                        issueComments = append(issueComments, comment)
                }</span> else<span class="cov8" title="1"> if comment.Type == "review" </span><span class="cov8" title="1">{
                        reviewComments = append(reviewComments, comment)
                }</span> else<span class="cov8" title="1"> {
                        lineComments = append(lineComments, comment)
                }</span>
        }

        // Safe color functions
        <span class="cov8" title="1">colorIssue := func(text string) string </span><span class="cov8" title="1">{
                if ColorIssueComment != nil </span><span class="cov8" title="1">{
                        return ColorIssueComment.Sprint(text)
                }</span>
                <span class="cov0" title="0">return text</span>
        }
        <span class="cov8" title="1">colorReview := func(text string) string </span><span class="cov8" title="1">{
                if ColorReviewComment != nil </span><span class="cov8" title="1">{
                        return ColorReviewComment.Sprint(text)
                }</span>
                <span class="cov0" title="0">return text</span>
        }
        <span class="cov8" title="1">colorHeader := func(text string) string </span><span class="cov8" title="1">{
                if ColorHeader != nil </span><span class="cov8" title="1">{
                        return ColorHeader.Sprint(text)
                }</span>
                <span class="cov0" title="0">return text</span>
        }

        // Display general PR comments
        <span class="cov8" title="1">if len(issueComments) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf("%s (%d)\n", colorIssue("💬 General PR Comments"), len(issueComments))
                fmt.Println(strings.Repeat("─", SeparatorLength))
                for i, comment := range issueComments </span><span class="cov8" title="1">{
                        displayComment(comment, i+1)
                }</span>
                <span class="cov8" title="1">fmt.Println()</span>
        }

        // Display review-level comments (parent comments that group line-specific ones)
        <span class="cov8" title="1">if len(reviewComments) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf("%s (%d)\n", colorReview("📋 Review Comments"), len(reviewComments))
                fmt.Println(strings.Repeat("─", SeparatorLength))
                for i, comment := range reviewComments </span><span class="cov8" title="1">{
                        displayComment(comment, i+1)
                }</span>
                <span class="cov8" title="1">fmt.Println()</span>
        }

        // Display line-specific comments
        <span class="cov8" title="1">if len(lineComments) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf("%s (%d)\n", colorHeader("📍 Line-Specific Comments"), len(lineComments))
                fmt.Println(strings.Repeat("─", SeparatorLength))
                for i, comment := range lineComments </span><span class="cov8" title="1">{
                        displayComment(comment, i+1)
                }</span>
        }
}

func displayComment(comment Comment, index int) <span class="cov8" title="1">{
        // Header with author and timestamp
        timeAgo := formatTimeAgo(comment.CreatedAt)

        // Safe color functions that work even if colors aren't initialized
        colorID := func(text string) string </span><span class="cov8" title="1">{
                if ColorCommentID != nil </span><span class="cov8" title="1">{
                        return ColorCommentID.Sprint(text)
                }</span>
                <span class="cov0" title="0">return text</span>
        }
        <span class="cov8" title="1">colorAuthor := func(text string) string </span><span class="cov8" title="1">{
                if ColorAuthor != nil </span><span class="cov8" title="1">{
                        return ColorAuthor.Sprint(text)
                }</span>
                <span class="cov0" title="0">return text</span>
        }
        <span class="cov8" title="1">colorTime := func(text string) string </span><span class="cov8" title="1">{
                if ColorTimestamp != nil </span><span class="cov8" title="1">{
                        return ColorTimestamp.Sprint(text)
                }</span>
                <span class="cov0" title="0">return text</span>
        }

        <span class="cov8" title="1">if hideAuthors </span><span class="cov8" title="1">{
                fmt.Printf("[%d] %s 👤 [hidden] • %s", index, colorID(fmt.Sprintf("ID:%d", comment.ID)), colorTime(timeAgo))
        }</span> else<span class="cov8" title="1"> {
                fmt.Printf("[%d] %s 👤 %s • %s", index, colorID(fmt.Sprintf("ID:%d", comment.ID)), colorAuthor(comment.Author), colorTime(timeAgo))
        }</span>

        // Show review state for review-level comments
        <span class="cov8" title="1">if comment.Type == "review" &amp;&amp; comment.State != "" </span><span class="cov0" title="0">{
                fmt.Printf(" %s", ColorizeReviewState(comment.State))
        }</span>
        <span class="cov8" title="1">fmt.Println()

        // File and line info for line-specific comments
        if comment.Path != "" </span><span class="cov8" title="1">{
                lineInfo := fmt.Sprintf("L%d", comment.Line)
                if comment.StartLine &gt; 0 &amp;&amp; comment.StartLine != comment.Line </span><span class="cov0" title="0">{
                        lineInfo = fmt.Sprintf("L%d-L%d", comment.StartLine, comment.Line)
                }</span>
                <span class="cov8" title="1">colorFile := func(text string) string </span><span class="cov8" title="1">{
                        if ColorFilePath != nil </span><span class="cov8" title="1">{
                                return ColorFilePath.Sprint(text)
                        }</span>
                        <span class="cov0" title="0">return text</span>
                }
                <span class="cov8" title="1">colorLine := func(text string) string </span><span class="cov8" title="1">{
                        if ColorLineNumber != nil </span><span class="cov8" title="1">{
                                return ColorLineNumber.Sprint(text)
                        }</span>
                        <span class="cov0" title="0">return text</span>
                }
                <span class="cov8" title="1">colorSHA := func(text string) string </span><span class="cov0" title="0">{
                        if ColorCommitSHA != nil </span><span class="cov0" title="0">{
                                return ColorCommitSHA.Sprint(text)
                        }</span>
                        <span class="cov0" title="0">return text</span>
                }

                <span class="cov8" title="1">fmt.Printf("📁 %s:%s", colorFile(comment.Path), colorLine(lineInfo))

                // Show commit ID for review comments (helps with debugging and understanding)
                if comment.CommitID != "" </span><span class="cov0" title="0">{
                        fmt.Printf(" • 📊 %s", colorSHA(comment.CommitID[:CommitSHADisplayLength])) // Show first chars of commit SHA
                }</span>
                <span class="cov8" title="1">fmt.Println()

                // Show the actual diff context if available
                if comment.DiffHunk != "" </span><span class="cov0" title="0">{
                        fmt.Printf("📝 Code Context:\n")
                        displayDiffHunk(comment.DiffHunk)
                }</span>
        }

        // Comment body (truncate if too long)
        <span class="cov8" title="1">body := strings.TrimSpace(comment.Body)
        if len(body) &gt; MaxDisplayBodyLength </span><span class="cov0" title="0">{
                body = body[:MaxDisplayBodyLength-TruncationReserve] + TruncationSuffix
        }</span>

        // Indent the comment body
        <span class="cov8" title="1">lines := strings.Split(body, "\n")
        for _, line := range lines </span><span class="cov8" title="1">{
                fmt.Printf("   %s\n", line)
        }</span>

        // Show URLs by default (AI-friendly), hide only in quiet mode
        <span class="cov8" title="1">if !quiet </span><span class="cov8" title="1">{
                colorURL := func(text string) string </span><span class="cov8" title="1">{
                        if ColorURL != nil </span><span class="cov8" title="1">{
                                return ColorURL.Sprint(text)
                        }</span>
                        <span class="cov0" title="0">return text</span>
                }
                <span class="cov8" title="1">fmt.Printf("   🔗 %s\n", colorURL(comment.HTMLURL))</span>
        }

        <span class="cov8" title="1">fmt.Println()</span>
}

func formatTimeAgo(t time.Time) string <span class="cov8" title="1">{
        now := time.Now()
        diff := now.Sub(t)

        if diff &lt; time.Minute </span><span class="cov8" title="1">{
                return "just now"
        }</span> else<span class="cov8" title="1"> if diff &lt; time.Hour </span><span class="cov8" title="1">{
                minutes := int(diff.Minutes())
                if minutes == 1 </span><span class="cov8" title="1">{
                        return "1 minute ago"
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%d minutes ago", minutes)</span>
        } else<span class="cov8" title="1"> if diff &lt; 24*time.Hour </span><span class="cov8" title="1">{
                hours := int(diff.Hours())
                if hours == 1 </span><span class="cov8" title="1">{
                        return "1 hour ago"
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%d hours ago", hours)</span>
        } else<span class="cov8" title="1"> {
                days := int(diff.Hours() / 24)
                if days == 1 </span><span class="cov8" title="1">{
                        return "1 day ago"
                }</span> else<span class="cov8" title="1"> if days &lt; 7 </span><span class="cov8" title="1">{
                        return fmt.Sprintf("%d days ago", days)
                }</span> else<span class="cov8" title="1"> {
                        return t.Format("Jan 2, 2006")
                }</span>
        }
}

func displayDiffHunk(diffHunk string) <span class="cov8" title="1">{
        // Split diff hunk into lines
        lines := strings.Split(strings.TrimSpace(diffHunk), "\n")

        for _, line := range lines </span><span class="cov8" title="1">{
                if line == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Color code the diff lines
                <span class="cov8" title="1">if strings.HasPrefix(line, "@@") </span><span class="cov8" title="1">{
                        // Diff header - show line numbers
                        fmt.Printf("   🔹 %s\n", line)
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(line, "+") </span><span class="cov8" title="1">{
                        // Added line - green
                        fmt.Printf("   ➕ %s\n", line)
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(line, "-") </span><span class="cov8" title="1">{
                        // Removed line - red
                        fmt.Printf("   ➖ %s\n", line)
                }</span> else<span class="cov8" title="1"> {
                        // Context line - neutral
                        fmt.Printf("     %s\n", line)
                }</span>
        }
        <span class="cov8" title="1">fmt.Println()</span>
}

// displayIDsOnly outputs only comment IDs, one per line
func displayIDsOnly(comments []Comment) <span class="cov8" title="1">{
        for _, comment := range comments </span><span class="cov8" title="1">{
                fmt.Printf("%d\n", comment.ID)
        }</span>
}

// displayCommentsJSON outputs comments as JSON
func displayCommentsJSON(comments []Comment, pr int) error <span class="cov8" title="1">{
        output := struct {
                PR       int       `json:"pr"`
                Total    int       `json:"total"`
                Comments []Comment `json:"comments"`
        }{
                PR:       pr,
                Total:    len(comments),
                Comments: comments,
        }

        encoder := json.NewEncoder(os.Stdout)
        encoder.SetIndent("", "  ")
        return encoder.Encode(output)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package cmd

import (
        "bytes"
        "embed"
        "fmt"
        "io/fs"
        "strings"

        "github.com/MakeNowJust/heredoc"
        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"
)

var (
        promptCategory string
        listPrompts    bool
)

//go:embed prompts/**/*.md
var promptFiles embed.FS

var promptsCmd = &amp;cobra.Command{
        Use:   "prompts [prompt-name]",
        Short: "Get AI-powered code review prompts and best practices",
        Long: heredoc.Doc(`
                Access a curated collection of professional code review prompts optimized
                for AI assistants like Claude, ChatGPT, and other automated workflows.

                These prompts follow research-backed best practices for effective code
                review communication, including psychological safety principles and
                the CREG emoji system (🔧🤔♻️📝😃📌).

                Perfect for: Senior developers, code review leads, QA teams, and AI
                assistants who need sophisticated review templates beyond basic feedback.
        `),
        Example: heredoc.Doc(`
                # List all available prompts
                $ gh comment prompts --list

                # Get specific security review prompt
                $ gh comment prompts security-audit

                # List prompts by category
                $ gh comment prompts --category performance --list

                # Get performance optimization prompt
                $ gh comment prompts performance-optimization

                # Security-focused review prompt
                $ gh comment prompts security-audit

                # Architecture review prompt
                $ gh comment prompts architecture-review
        `),
        Args: cobra.MaximumNArgs(1),
        RunE: runPrompts,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(promptsCmd)

        promptsCmd.Flags().StringVar(&amp;promptCategory, "category", "", "Filter prompts by category: security, performance, architecture, quality, ai")
        promptsCmd.Flags().BoolVar(&amp;listPrompts, "list", false, "List available prompts")
}</span>

func runPrompts(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        if listPrompts </span><span class="cov8" title="1">{
                return listAvailablePrompts()
        }</span>

        <span class="cov8" title="1">if len(args) == 0 </span><span class="cov8" title="1">{
                return listAvailablePrompts()
        }</span>

        <span class="cov8" title="1">promptName := args[0]
        prompt, exists := getPrompt(promptName)
        if !exists </span><span class="cov8" title="1">{
                fmt.Printf("❌ Prompt '%s' not found.\n\n", promptName)
                fmt.Println("Available prompts:")
                return listAvailablePrompts()
        }</span>

        <span class="cov8" title="1">fmt.Printf("📋 **%s**\n\n", prompt.Title)
        fmt.Printf("🎯 **Category**: %s\n", prompt.Category)
        fmt.Printf("⏱️  **Estimated Time**: %s\n\n", prompt.EstimatedTime)

        fmt.Println("📝 **Prompt:**")
        fmt.Println("```")
        fmt.Println(prompt.Content)
        fmt.Println("```")

        if len(prompt.Examples) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Println("\n💡 **Example Usage:**")
                for _, example := range prompt.Examples </span><span class="cov8" title="1">{
                        fmt.Printf("• %s\n", example)
                }</span>
        }

        <span class="cov8" title="1">if len(prompt.Tags) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf("\n🏷️  **Tags**: %s\n", strings.Join(prompt.Tags, ", "))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

type Prompt struct {
        Name          string
        Title         string
        Category      string
        Content       string
        Examples      []string
        Tags          []string
        EstimatedTime string
}

type PromptMetadata struct {
        Name          string   `yaml:"name"`
        Title         string   `yaml:"title"`
        Category      string   `yaml:"category"`
        EstimatedTime string   `yaml:"estimated_time"`
        Tags          []string `yaml:"tags"`
        Examples      []string `yaml:"examples"`
}

func getPrompt(name string) (Prompt, bool) <span class="cov8" title="1">{
        prompts := getAllPrompts()
        prompt, exists := prompts[name]
        return prompt, exists
}</span>

func listAvailablePrompts() error <span class="cov8" title="1">{
        prompts := getAllPrompts()

        if promptCategory != "" </span><span class="cov8" title="1">{
                fmt.Printf("📋 **Code Review Prompts - %s Category**\n\n", strings.Title(promptCategory))
        }</span> else<span class="cov8" title="1"> {
                fmt.Print("📋 **Available Code Review Prompts**\n\n")
        }</span>

        <span class="cov8" title="1">categories := make(map[string][]Prompt)
        for _, prompt := range prompts </span><span class="cov8" title="1">{
                if promptCategory != "" &amp;&amp; prompt.Category != promptCategory </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">categories[prompt.Category] = append(categories[prompt.Category], prompt)</span>
        }

        <span class="cov8" title="1">for category, categoryPrompts := range categories </span><span class="cov8" title="1">{
                fmt.Printf("## %s\n", strings.Title(category))
                for _, prompt := range categoryPrompts </span><span class="cov8" title="1">{
                        fmt.Printf("  **%s** - %s (%s)\n", prompt.Name, prompt.Title, prompt.EstimatedTime)
                        fmt.Printf("    %s\n", strings.Join(prompt.Tags, " • "))
                }</span>
                <span class="cov8" title="1">fmt.Print("\n")</span>
        }

        <span class="cov8" title="1">fmt.Println("💡 **Usage**: `gh comment prompts &lt;prompt-name&gt;` to get the full prompt")
        return nil</span>
}

func getAllPrompts() map[string]Prompt <span class="cov8" title="1">{
        prompts := make(map[string]Prompt)

        // Walk through all markdown files in the prompts directory
        fs.WalkDir(promptFiles, ".", func(path string, d fs.DirEntry, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Only process .md files
                <span class="cov8" title="1">if !strings.HasSuffix(path, ".md") </span><span class="cov8" title="1">{
                        return nil
                }</span>

                // Read the markdown file
                <span class="cov8" title="1">content, err := promptFiles.ReadFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Parse the markdown file with frontmatter
                <span class="cov8" title="1">prompt, err := parseMarkdownPrompt(content)
                if err != nil </span><span class="cov0" title="0">{
                        // Skip files that can't be parsed, but continue processing others
                        return nil
                }</span>

                <span class="cov8" title="1">prompts[prompt.Name] = prompt
                return nil</span>
        })

        <span class="cov8" title="1">return prompts</span>
}

func parseMarkdownPrompt(content []byte) (Prompt, error) <span class="cov8" title="1">{
        // Split frontmatter and content
        parts := bytes.SplitN(content, []byte("---"), 3)
        if len(parts) &lt; 3 </span><span class="cov0" title="0">{
                return Prompt{}, fmt.Errorf("invalid markdown format: missing frontmatter")
        }</span>

        // Parse YAML frontmatter
        <span class="cov8" title="1">var metadata PromptMetadata
        if err := yaml.Unmarshal(parts[1], &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return Prompt{}, fmt.Errorf("failed to parse frontmatter: %w", err)
        }</span>

        // Extract markdown content (remove leading/trailing whitespace)
        <span class="cov8" title="1">markdownContent := strings.TrimSpace(string(parts[2]))

        return Prompt{
                Name:          metadata.Name,
                Title:         metadata.Title,
                Category:      metadata.Category,
                Content:       markdownContent,
                Examples:      metadata.Examples,
                Tags:          metadata.Tags,
                EstimatedTime: metadata.EstimatedTime,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package cmd

import (
        "fmt"
        "strings"

        "github.com/MakeNowJust/heredoc"
        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
)

var (
        removeReactionFlag bool

        // Client for dependency injection (tests can override)
        reactClient github.GitHubAPI
)

var reactCmd = &amp;cobra.Command{
        Use:   "react &lt;comment-id&gt; &lt;emoji&gt;",
        Short: "Add or remove emoji reactions to comments",
        Long: heredoc.Doc(`
                Add or remove emoji reactions to any comment type.

                Supports both issue comments and review comments automatically.
                Comment type is auto-detected from the comment ID.

                Available reactions: +1, -1, laugh, confused, heart, hooray, rocket, eyes

                Comment IDs can be found in the output of 'gh comment list'.
        `),
        Example: heredoc.Doc(`
                # Add reactions to any comment type
                $ gh comment react 123456 +1
                $ gh comment react 789012 heart
                $ gh comment react 999999 rocket

                # Remove reactions
                $ gh comment react 123456 +1 --remove
                $ gh comment react 789012 heart --remove

                # Works with both issue and review comments automatically
                $ gh comment react 123456 eyes    # Works for issue comments
                $ gh comment react 789012 hooray  # Works for review comments
        `),
        Args: cobra.ExactArgs(2),
        RunE: runReact,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(reactCmd)

        reactCmd.Flags().BoolVar(&amp;removeReactionFlag, "remove", false, "Remove reaction instead of adding it")
}</span>

func runReact(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if reactClient == nil </span><span class="cov8" title="1">{
                client, err := createGitHubClient()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create GitHub client: %w", err)
                }</span>
                <span class="cov8" title="1">reactClient = client</span>
        }

        // Parse comment ID
        <span class="cov8" title="1">commentIDStr := args[0]
        commentID, err := parsePositiveInt(commentIDStr, "comment ID")
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Get reaction emoji
        <span class="cov8" title="1">reaction := args[1]

        // Validate reaction
        if !validateReaction(reaction) </span><span class="cov8" title="1">{
                return formatValidationError("reaction", reaction, "must be one of: +1, -1, laugh, confused, heart, hooray, rocket, eyes")
        }</span>

        // Get repository context
        <span class="cov8" title="1">repository, prNumber, err := getPRContext()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Parse owner/repo
        <span class="cov8" title="1">parts := strings.Split(repository, "/")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid repository format: %s (expected owner/repo)", repository)
        }</span>
        <span class="cov8" title="1">owner, repoName := parts[0], parts[1]

        if verbose </span><span class="cov0" title="0">{
                fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("Comment ID: %d\n", commentID)
                fmt.Printf("Reaction: %s\n", reaction)
                if removeReactionFlag </span><span class="cov0" title="0">{
                        fmt.Printf("Action: Remove reaction\n")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Action: Add reaction\n")
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        <span class="cov8" title="1">if dryRun </span><span class="cov0" title="0">{
                action := "add"
                if removeReactionFlag </span><span class="cov0" title="0">{
                        action = "remove"
                }</span>
                <span class="cov0" title="0">fmt.Printf("Would %s %s reaction %s comment #%d\n", action, reaction,
                        map[bool]string{true: "from", false: "to"}[removeReactionFlag], commentID)
                return nil</span>
        }

        // Perform the reaction action
        <span class="cov8" title="1">if removeReactionFlag </span><span class="cov8" title="1">{
                err = reactClient.RemoveReaction(owner, repoName, commentID, prNumber, reaction)
                if err != nil </span><span class="cov0" title="0">{
                        return formatActionableError("reaction removal", err)
                }</span>
                <span class="cov8" title="1">fmt.Printf("✅ Removed %s reaction from comment #%d\n", reaction, commentID)</span>
        } else<span class="cov8" title="1"> {
                err = reactClient.AddReaction(owner, repoName, commentID, prNumber, reaction)
                if err != nil </span><span class="cov0" title="0">{
                        return formatActionableError("reaction addition", err)
                }</span>
                <span class="cov8" title="1">fmt.Printf("✅ Added %s reaction to comment #%d\n", reaction, commentID)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func validateReaction(reaction string) bool <span class="cov8" title="1">{
        validReactions := []string{"+1", "-1", "laugh", "confused", "heart", "hooray", "rocket", "eyes"}
        for _, valid := range validReactions </span><span class="cov8" title="1">{
                if reaction == valid </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package cmd

import (
        "fmt"
        "strings"

        "github.com/MakeNowJust/heredoc"
        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
)

var (
        // Client for dependency injection (tests can override)
        resolveClient github.GitHubAPI
)

var resolveCmd = &amp;cobra.Command{
        Use:   "resolve &lt;comment-id&gt;",
        Short: "Resolve a conversation thread",
        Long: heredoc.Doc(`
                Resolve a conversation thread for a pull request review comment.

                This marks the conversation as resolved, indicating that the feedback
                has been addressed. Use the comment ID from 'gh comment list' output.

                Only review comments can be resolved - issue comments cannot be resolved
                as they don't create conversation threads.
        `),
        Example: heredoc.Doc(`
                # Resolve a conversation
                $ gh comment resolve 2246362251

                # Resolve with dry-run preview
                $ gh comment resolve --dry-run 2246362251

                # Resolve multiple conversations (pipe from list)
                $ gh comment list 123 --status open --ids-only | xargs -I {} gh comment resolve {}
        `),
        Args: cobra.ExactArgs(1),
        RunE: runResolve,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(resolveCmd)
}</span>

func runResolve(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if resolveClient == nil </span><span class="cov0" title="0">{
                client, err := createGitHubClient()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create GitHub client: %w", err)
                }</span>
                <span class="cov0" title="0">resolveClient = client</span>
        }

        // Parse comment ID
        <span class="cov8" title="1">commentID, err := parsePositiveInt(args[0], "comment ID")
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Get repository and PR context
        <span class="cov8" title="1">repository, pr, err := getPRContext()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Parse owner/repo
        <span class="cov8" title="1">parts := strings.Split(repository, "/")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid repository format: %s (expected owner/repo)", repository)
        }</span>
        <span class="cov8" title="1">owner, repoName := parts[0], parts[1]

        if verbose </span><span class="cov8" title="1">{
                fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("PR Number: %d\n", pr)
                fmt.Printf("Comment ID: %d\n", commentID)
                fmt.Println()
        }</span>

        <span class="cov8" title="1">if dryRun </span><span class="cov8" title="1">{
                fmt.Printf("Would resolve conversation for comment #%d in PR #%d\n", commentID, pr)
                return nil
        }</span>

        // Find the review thread for this comment
        <span class="cov8" title="1">threadID, err := resolveClient.FindReviewThreadForComment(owner, repoName, pr, commentID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to find review thread for comment: %w", err)
        }</span>

        // Resolve the review thread
        <span class="cov8" title="1">err = resolveClient.ResolveReviewThread(threadID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to resolve conversation: %w", err)
        }</span>

        <span class="cov8" title="1">fmt.Printf("%s\n", ColorizeSuccess(fmt.Sprintf("Resolved conversation for comment #%d", commentID)))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package cmd

import (
        "fmt"
        "strings"

        "github.com/MakeNowJust/heredoc"
        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
)

var (
        resolveConversationReviewReply bool
        noExpandSuggestionsReviewReply bool

        // Client for dependency injection (tests can override)
        reviewReplyClient github.GitHubAPI
)

var reviewReplyCmd = &amp;cobra.Command{
        Use:   "review-reply &lt;comment-id&gt; [message]",
        Short: "Reply to a review comment with a text message",
        Long: heredoc.Doc(`
                Reply to an existing review comment with a text message.

                This command is specifically for review comment threading - replying to
                line-specific comments that appear in the "Files Changed" tab. Review
                comment threading has limited GitHub API support.

                Note: Some comment IDs may return 404 errors due to GitHub API limitations
                with review comment threading. The --resolve flag works more reliably.

                For general PR discussion, use 'gh comment add' instead.
                For emoji reactions, use 'gh comment react' command.

                Comment IDs can be found in the output of 'gh comment list'.
        `),
        Example: heredoc.Doc(`
                # Reply to review comment with message
                $ gh comment review-reply 789012 "Fixed this issue"

                # Reply and resolve conversation in one operation
                $ gh comment review-reply 789012 "Addressed your feedback" --resolve

                # Just resolve conversation without adding message
                $ gh comment review-reply 789012 --resolve

                # For general PR discussion, use add command instead:
                # $ gh comment add 123 "Thanks for the review!"

                # For emoji reactions, use react command instead:
                # $ gh comment react 789012 +1
        `),
        Args: cobra.RangeArgs(1, 2),
        RunE: runReviewReply,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(reviewReplyCmd)

        reviewReplyCmd.Flags().BoolVar(&amp;resolveConversationReviewReply, "resolve", false, "Resolve the conversation after replying")
        reviewReplyCmd.Flags().BoolVar(&amp;noExpandSuggestionsReviewReply, "no-expand-suggestions", false, "Disable automatic expansion of [SUGGEST:] and &lt;&lt;&lt;SUGGEST&gt;&gt;&gt; syntax")
}</span>

func runReviewReply(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if reviewReplyClient == nil </span><span class="cov0" title="0">{
                client, err := createGitHubClient()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create GitHub client: %w", err)
                }</span>
                <span class="cov0" title="0">reviewReplyClient = client</span>
        }

        // Parse comment ID
        <span class="cov8" title="1">commentIDStr := args[0]
        commentID, err := parsePositiveInt(commentIDStr, "comment ID")
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Get message if provided
        <span class="cov8" title="1">var message string
        if len(args) &gt; 1 </span><span class="cov8" title="1">{
                message = args[1]
        }</span>

        // Validate that we have either message or resolve
        <span class="cov8" title="1">if message == "" &amp;&amp; !resolveConversationReviewReply </span><span class="cov8" title="1">{
                return fmt.Errorf("must provide either a message or --resolve")
        }</span>

        // Validate comment body length if provided
        <span class="cov8" title="1">if message != "" </span><span class="cov8" title="1">{
                if err := validateCommentBody(message); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Get repository context
        <span class="cov8" title="1">repository, prNumber, err := getPRContext()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate repository name
        <span class="cov8" title="1">if err := validateRepositoryName(repository); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Parse owner/repo
        <span class="cov8" title="1">parts := strings.Split(repository, "/")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid repository format: %s (expected owner/repo)", repository)
        }</span>
        <span class="cov8" title="1">owner, repoName := parts[0], parts[1]

        if verbose </span><span class="cov0" title="0">{
                fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("Comment ID: %d\n", commentID)
                fmt.Printf("Comment Type: review\n")
                if message != "" </span><span class="cov0" title="0">{
                        fmt.Printf("Message: %s\n", message)
                }</span>
                <span class="cov0" title="0">if resolveConversationReviewReply </span><span class="cov0" title="0">{
                        fmt.Printf("Resolve Conversation: true\n")
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        <span class="cov8" title="1">if dryRun </span><span class="cov0" title="0">{
                fmt.Printf("Would reply to review comment #%d:\n", commentID)
                if message != "" </span><span class="cov0" title="0">{
                        fmt.Printf("Message: %s\n", message)
                }</span>
                <span class="cov0" title="0">if resolveConversationReviewReply </span><span class="cov0" title="0">{
                        fmt.Printf("Resolve Conversation: true\n")
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Handle message reply
        <span class="cov8" title="1">if message != "" </span><span class="cov8" title="1">{
                // Expand suggestions if enabled
                if !noExpandSuggestionsReviewReply </span><span class="cov8" title="1">{
                        message = expandSuggestions(message)
                }</span>

                // Reply to review comment
                <span class="cov8" title="1">_, err = reviewReplyClient.CreateReviewCommentReply(owner, repoName, commentID, message)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create reply: %w", err)
                }</span>
                <span class="cov8" title="1">fmt.Printf("✅ Replied to review comment #%d: %s\n", commentID, message)</span>
        }

        // Handle resolve conversation
        <span class="cov8" title="1">if resolveConversationReviewReply </span><span class="cov8" title="1">{
                // Find the thread ID for this comment
                threadID, err := reviewReplyClient.FindReviewThreadForComment(owner, repoName, prNumber, commentID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to find review thread: %w", err)
                }</span>

                // Resolve the thread
                <span class="cov8" title="1">err = reviewReplyClient.ResolveReviewThread(threadID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to resolve conversation: %w", err)
                }</span>
                <span class="cov8" title="1">fmt.Printf("✅ Resolved conversation for review comment #%d\n", commentID)</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package cmd

import (
        "fmt"
        "sort"
        "strconv"
        "strings"

        "github.com/MakeNowJust/heredoc"
        "github.com/silouanwright/gh-comment/internal/github"
        "github.com/spf13/cobra"
)

var (
        // Client for dependency injection (tests can override)
        reviewClient github.GitHubAPI

        // Review-specific flags
        reviewEventFlag    string
        reviewCommentsFlag []string
)

var reviewCmd = &amp;cobra.Command{
        Use:   "review &lt;pr&gt; &lt;body&gt;",
        Short: "Create a code review with line-specific comments",
        Long: heredoc.Doc(`
                Create a code review with multiple line-specific comments attached to code.

                This command creates review comments that appear in the "Files Changed" tab,
                attached to specific lines or ranges. Perfect for comprehensive code reviews
                where you want to comment on multiple code locations and submit a review
                decision (APPROVE/REQUEST_CHANGES/COMMENT) in one operation.

                For general PR discussion comments, use: 'gh comment add'
        `),
        Example: heredoc.Doc(`
                # Security-focused comprehensive review
                $ gh comment review 123 "Security audit complete - critical issues found" \
                  --comment src/api.js:6:"Use crypto.randomBytes(32) instead of Math.random() for token generation" \
                  --comment src/api.js:8:10:"This endpoint lacks rate limiting - vulnerable to DoS attacks" \
                  --comment tests/auth_test.js:2:"Input sanitization missing - SQL injection risk" \
                  --event REQUEST_CHANGES

                # Performance optimization review
                $ gh comment review 123 "Performance review - optimization opportunities identified" \
                  --comment src/main.go:3:4:"Extract this N+1 query to a single batch operation" \
                  --comment src/api.js:4:"Consider Redis clustering for this high-traffic endpoint" \
                  --comment src/main.go:4:"Add performance metrics for this critical path" \
                  --event COMMENT

                # Architecture migration approval
                $ gh comment review 123 "Migration to microservices architecture approved" \
                  --comment service-layer.js:45:"Excellent separation of concerns in the new service layer" \
                  --comment api-gateway.go:123:130:"API gateway implementation follows best practices" \
                  --comment docker-compose.yml:67:"Container orchestration setup looks solid" \
                  --event APPROVE

                # Code quality and maintainability review
                $ gh comment review 123 "Code quality review - refactoring needed" \
                  --comment legacy-handler.js:200:250:"This function is doing too much - extract into separate services" \
                  --comment utils.go:45:"Consider using dependency injection pattern here" \
                  --comment test-helpers.js:89:"Add integration tests for this critical business logic" \
                  --event REQUEST_CHANGES
        `),
        Args: cobra.RangeArgs(1, 2),
        RunE: runReview,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(reviewCmd)
        reviewCmd.Flags().StringVar(&amp;reviewEventFlag, "event", "COMMENT", "Review event (APPROVE|REQUEST_CHANGES|COMMENT) (default: COMMENT)")
        reviewCmd.Flags().StringArrayVar(&amp;reviewCommentsFlag, "comment", []string{}, "Add comment in format file:line:message or file:start:end:message (default: empty)")
}</span>

func runReview(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Initialize client if not set (production use)
        if reviewClient == nil </span><span class="cov0" title="0">{
                client, err := createGitHubClient()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create GitHub client: %w", err)
                }</span>
                <span class="cov0" title="0">reviewClient = client</span>
        }

        <span class="cov8" title="1">var pr int
        var body string
        var err error

        // Parse arguments
        if len(args) == 2 </span><span class="cov8" title="1">{
                // PR number and body provided
                pr, err = strconv.Atoi(args[0])
                if err != nil </span><span class="cov8" title="1">{
                        return formatValidationError("PR number", args[0], "must be a valid integer")
                }</span>
                <span class="cov8" title="1">body = args[1]</span>
        } else<span class="cov8" title="1"> if len(args) == 1 </span><span class="cov8" title="1">{
                // Check if it's a PR number or review body
                if prNum, err := strconv.Atoi(args[0]); err == nil </span><span class="cov8" title="1">{
                        // It's a PR number
                        pr = prNum
                }</span> else<span class="cov8" title="1"> {
                        // It's a review body, auto-detect PR
                        _, pr, err = getPRContext()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">body = args[0]</span>
                }
        }

        // Validate event type
        <span class="cov8" title="1">validEvents := []string{"APPROVE", "REQUEST_CHANGES", "COMMENT"}
        isValidEvent := false
        for _, validEvent := range validEvents </span><span class="cov8" title="1">{
                if reviewEventFlag == validEvent </span><span class="cov8" title="1">{
                        isValidEvent = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !isValidEvent </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid event type: %s (must be APPROVE, REQUEST_CHANGES, or COMMENT)", reviewEventFlag)
        }</span>

        // Validate that we have either a body or comments
        <span class="cov8" title="1">if body == "" &amp;&amp; len(reviewCommentsFlag) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("review must have either a body message or comments (use --comment)")
        }</span>

        // Validate review body length if provided
        <span class="cov8" title="1">if body != "" </span><span class="cov8" title="1">{
                if err := validateCommentBody(body); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Get repository context
        <span class="cov8" title="1">repository, err := getCurrentRepo()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get repository: %w", err)
        }</span>

        // Validate repository name
        <span class="cov8" title="1">if err := validateRepositoryName(repository); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // If PR number wasn't parsed from args, try to auto-detect it
        <span class="cov8" title="1">if pr == 0 </span><span class="cov0" title="0">{
                if prNumber &gt; 0 </span><span class="cov0" title="0">{
                        pr = prNumber
                }</span> else<span class="cov0" title="0"> {
                        detectedPR, err := getCurrentPR()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to detect PR number: %w (try specifying --pr)", err)
                        }</span>
                        <span class="cov0" title="0">pr = detectedPR</span>
                }
        }

        // Parse owner/repo
        <span class="cov8" title="1">parts := strings.Split(repository, "/")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid repository format: %s (expected owner/repo)", repository)
        }</span>
        <span class="cov8" title="1">owner, repoName := parts[0], parts[1]

        // Parse and validate review comments first (before dry run)
        var reviewCommentInputs []github.ReviewCommentInput
        for i, commentSpec := range reviewCommentsFlag </span><span class="cov8" title="1">{
                commentInput, err := parseReviewCommentSpec(commentSpec)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid comment %d (%s): %w", i+1, commentSpec, err)
                }</span>

                // Validate line exists in diff if validation is enabled
                <span class="cov8" title="1">if validateDiff </span><span class="cov8" title="1">{
                        if err := validateCommentLine(reviewClient, owner, repoName, pr, commentInput); err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("comment %d validation failed (%s): %w", i+1, commentSpec, err)
                        }</span>
                }

                <span class="cov8" title="1">reviewCommentInputs = append(reviewCommentInputs, commentInput)</span>
        }

        <span class="cov8" title="1">if verbose </span><span class="cov8" title="1">{
                fmt.Printf("Repository: %s\n", repository)
                fmt.Printf("PR: %d\n", pr)
                fmt.Printf("Review body: %s\n", body)
                fmt.Printf("Review event: %s\n", reviewEventFlag)
                fmt.Printf("Comments: %d\n", len(reviewCommentsFlag))
                fmt.Println()
        }</span>

        <span class="cov8" title="1">if dryRun </span><span class="cov8" title="1">{
                fmt.Printf("Would create review on PR #%d:\n", pr)
                fmt.Printf("Body: %s\n", body)
                fmt.Printf("Event: %s\n", reviewEventFlag)
                fmt.Printf("Comments: %d\n", len(reviewCommentsFlag))
                for i, comment := range reviewCommentsFlag </span><span class="cov8" title="1">{
                        fmt.Printf("  %d. %s\n", i+1, comment)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        // Create the review
        <span class="cov8" title="1">review := github.ReviewInput{
                Body:     body,
                Event:    reviewEventFlag,
                Comments: reviewCommentInputs,
        }

        err = reviewClient.CreateReview(owner, repoName, pr, review)
        if err != nil </span><span class="cov0" title="0">{
                return formatActionableError("review creation", err)
        }</span>

        // Display success message
        <span class="cov8" title="1">eventText := ""
        switch reviewEventFlag </span>{
        case "APPROVE":<span class="cov8" title="1">
                eventText = "approved"</span>
        case "REQUEST_CHANGES":<span class="cov8" title="1">
                eventText = "requested changes"</span>
        case "COMMENT":<span class="cov8" title="1">
                eventText = "commented on"</span>
        }

        <span class="cov8" title="1">fmt.Printf("✅ Successfully created review and %s PR #%d", eventText, pr)
        if len(reviewCommentInputs) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf(" with %d comments", len(reviewCommentInputs))
        }</span>
        <span class="cov8" title="1">fmt.Println()

        return nil</span>
}

// parseReviewCommentSpec parses a comment specification in the format:
// file:line:message or file:start:end:message
func parseReviewCommentSpec(spec string) (github.ReviewCommentInput, error) <span class="cov8" title="1">{
        // Handle quoted messages properly
        var filePath, lineSpec, message string

        // Check if message is quoted
        if strings.Contains(spec, ":'") &amp;&amp; strings.HasSuffix(spec, "'") </span><span class="cov0" title="0">{
                // Message is quoted with single quotes
                quoteIndex := strings.Index(spec, ":'")
                message = spec[quoteIndex+2 : len(spec)-1] // Remove :' and trailing '
                fileAndLine := spec[:quoteIndex]

                // Split file and line
                lastColonIndex := strings.LastIndex(fileAndLine, ":")
                if lastColonIndex == -1 </span><span class="cov0" title="0">{
                        return github.ReviewCommentInput{}, fmt.Errorf("format must be file:line:message or file:start:end:message")
                }</span>
                <span class="cov0" title="0">filePath = fileAndLine[:lastColonIndex]
                lineSpec = fileAndLine[lastColonIndex+1:]</span>
        } else<span class="cov8" title="1"> if strings.Contains(spec, ":\"") &amp;&amp; strings.HasSuffix(spec, "\"") </span><span class="cov0" title="0">{
                // Message is quoted with double quotes
                quoteIndex := strings.Index(spec, ":\"")
                message = spec[quoteIndex+2 : len(spec)-1] // Remove :" and trailing "
                fileAndLine := spec[:quoteIndex]

                // Split file and line
                lastColonIndex := strings.LastIndex(fileAndLine, ":")
                if lastColonIndex == -1 </span><span class="cov0" title="0">{
                        return github.ReviewCommentInput{}, fmt.Errorf("format must be file:line:message or file:start:end:message")
                }</span>
                <span class="cov0" title="0">filePath = fileAndLine[:lastColonIndex]
                lineSpec = fileAndLine[lastColonIndex+1:]</span>
        } else<span class="cov8" title="1"> {
                // Message is not quoted, use the old logic
                // Try to parse as range format first
                colonCount := strings.Count(spec, ":")
                if colonCount &gt;= 3 </span><span class="cov8" title="1">{
                        // Try file:start:end:message format
                        parts := strings.SplitN(spec, ":", 4)
                        if len(parts) == 4 </span><span class="cov8" title="1">{
                                // Check if parts[1] and parts[2] are both numbers
                                if _, err1 := strconv.Atoi(parts[1]); err1 == nil </span><span class="cov8" title="1">{
                                        if _, err2 := strconv.Atoi(parts[2]); err2 == nil </span><span class="cov8" title="1">{
                                                // Valid range format
                                                filePath = parts[0]
                                                lineSpec = parts[1] + ":" + parts[2]
                                                message = parts[3]
                                        }</span>
                                }
                        }
                }

                // If not range format, try simple format
                <span class="cov8" title="1">if filePath == "" </span><span class="cov8" title="1">{
                        parts := strings.SplitN(spec, ":", 3)
                        if len(parts) &lt; 3 </span><span class="cov8" title="1">{
                                return github.ReviewCommentInput{}, fmt.Errorf("format must be file:line:message or file:start:end:message")
                        }</span>
                        <span class="cov8" title="1">filePath = parts[0]
                        lineSpec = parts[1]
                        message = strings.Join(parts[2:], ":")</span>
                }
        }

        <span class="cov8" title="1">if filePath == "" </span><span class="cov8" title="1">{
                return github.ReviewCommentInput{}, fmt.Errorf("file path cannot be empty")
        }</span>
        <span class="cov8" title="1">if message == "" </span><span class="cov8" title="1">{
                return github.ReviewCommentInput{}, fmt.Errorf("message cannot be empty")
        }</span>

        // Validate file path
        <span class="cov8" title="1">if err := validateFilePath(filePath); err != nil </span><span class="cov0" title="0">{
                return github.ReviewCommentInput{}, err
        }</span>

        // Validate comment body length
        <span class="cov8" title="1">if err := validateCommentBody(message); err != nil </span><span class="cov0" title="0">{
                return github.ReviewCommentInput{}, err
        }</span>

        <span class="cov8" title="1">comment := github.ReviewCommentInput{
                Body: expandSuggestions(message),
                Path: filePath,
                Side: "RIGHT", // Default to RIGHT side (additions/new lines)
        }

        // Parse line specification (single line or range)
        if strings.Contains(lineSpec, "-") || strings.Contains(lineSpec, ":") </span><span class="cov8" title="1">{
                // Range format: start-end or start:end
                var rangeParts []string
                if strings.Contains(lineSpec, "-") </span><span class="cov8" title="1">{
                        rangeParts = strings.Split(lineSpec, "-")
                }</span> else<span class="cov8" title="1"> {
                        rangeParts = strings.Split(lineSpec, ":")
                }</span>
                <span class="cov8" title="1">if len(rangeParts) != 2 </span><span class="cov8" title="1">{
                        return github.ReviewCommentInput{}, fmt.Errorf("range format must be start-end or start:end")
                }</span>

                <span class="cov8" title="1">startLine, err := strconv.Atoi(strings.TrimSpace(rangeParts[0]))
                if err != nil </span><span class="cov8" title="1">{
                        return github.ReviewCommentInput{}, fmt.Errorf("invalid start line: %w", err)
                }</span>

                <span class="cov8" title="1">endLine, err := strconv.Atoi(strings.TrimSpace(rangeParts[1]))
                if err != nil </span><span class="cov8" title="1">{
                        return github.ReviewCommentInput{}, fmt.Errorf("invalid end line: %w", err)
                }</span>

                <span class="cov8" title="1">if startLine &lt;= 0 || endLine &lt;= 0 </span><span class="cov8" title="1">{
                        return github.ReviewCommentInput{}, fmt.Errorf("line numbers must be positive")
                }</span>

                <span class="cov8" title="1">if startLine &gt; endLine </span><span class="cov8" title="1">{
                        return github.ReviewCommentInput{}, fmt.Errorf("start line (%d) cannot be greater than end line (%d)", startLine, endLine)
                }</span>

                <span class="cov8" title="1">comment.StartLine = startLine
                comment.Line = endLine</span>
        } else<span class="cov8" title="1"> {
                // Single line format
                line, err := strconv.Atoi(lineSpec)
                if err != nil </span><span class="cov8" title="1">{
                        return github.ReviewCommentInput{}, fmt.Errorf("invalid line number: %w", err)
                }</span>

                <span class="cov8" title="1">if line &lt;= 0 </span><span class="cov8" title="1">{
                        return github.ReviewCommentInput{}, fmt.Errorf("line number must be positive")
                }</span>

                <span class="cov8" title="1">comment.Line = line</span>
        }

        <span class="cov8" title="1">return comment, nil</span>
}

// validateCommentLine validates that the line(s) specified in a review comment exist in the PR diff
func validateCommentLine(client github.GitHubAPI, owner, repo string, pr int, comment github.ReviewCommentInput) error <span class="cov8" title="1">{
        // Fetch PR diff
        diff, err := client.FetchPRDiff(owner, repo, pr)
        if err != nil </span><span class="cov0" title="0">{
                // If we can't fetch the diff, skip validation rather than blocking the comment
                if verbose </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: Could not fetch PR diff for validation: %v\n", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Find the requested file in the diff
        <span class="cov8" title="1">var targetFile *github.DiffFile
        for i := range diff.Files </span><span class="cov8" title="1">{
                if diff.Files[i].Filename == comment.Path </span><span class="cov8" title="1">{
                        targetFile = &amp;diff.Files[i]
                        break</span>
                }
        }

        <span class="cov8" title="1">if targetFile == nil </span><span class="cov8" title="1">{
                // Build helpful error message with available files
                var availableFiles []string
                for _, file := range diff.Files </span><span class="cov8" title="1">{
                        availableFiles = append(availableFiles, file.Filename)
                }</span>

                <span class="cov8" title="1">errorMsg := fmt.Sprintf("file '%s' not found in PR #%d diff", comment.Path, pr)
                if len(availableFiles) &gt; 0 </span><span class="cov8" title="1">{
                        errorMsg += "\n\n💡 Available files in this PR:\n"
                        for _, filename := range availableFiles </span><span class="cov8" title="1">{
                                errorMsg += fmt.Sprintf("  • %s\n", filename)
                        }</span>
                        <span class="cov8" title="1">errorMsg += fmt.Sprintf("\nTip: Use 'gh comment lines %d &lt;file&gt;' to see commentable lines", pr)</span>
                }
                <span class="cov8" title="1">return fmt.Errorf("%s", errorMsg)</span>
        }

        // Validate line numbers exist in the diff
        <span class="cov8" title="1">var linesToCheck []int
        if comment.StartLine &gt; 0 </span><span class="cov8" title="1">{
                // Range comment: check all lines from StartLine to Line
                for line := comment.StartLine; line &lt;= comment.Line; line++ </span><span class="cov8" title="1">{
                        linesToCheck = append(linesToCheck, line)
                }</span>
        } else<span class="cov8" title="1"> {
                // Single line comment
                linesToCheck = []int{comment.Line}
        }</span>

        <span class="cov8" title="1">var invalidLines []int
        for _, line := range linesToCheck </span><span class="cov8" title="1">{
                if !targetFile.Lines[line] </span><span class="cov8" title="1">{
                        invalidLines = append(invalidLines, line)
                }</span>
        }

        <span class="cov8" title="1">if len(invalidLines) &gt; 0 </span><span class="cov8" title="1">{
                // Build helpful error message with available lines
                var availableLines []int
                for lineNum := range targetFile.Lines </span><span class="cov8" title="1">{
                        availableLines = append(availableLines, lineNum)
                }</span>

                // Sort available lines for better display
                <span class="cov8" title="1">sort.Ints(availableLines)

                // Group consecutive lines for cleaner display
                ranges := groupConsecutiveLines(availableLines)

                var rangeStrings []string
                for _, r := range ranges </span><span class="cov8" title="1">{
                        if r.start == r.end </span><span class="cov0" title="0">{
                                rangeStrings = append(rangeStrings, fmt.Sprintf("%d", r.start))
                        }</span> else<span class="cov8" title="1"> {
                                rangeStrings = append(rangeStrings, fmt.Sprintf("%d-%d", r.start, r.end))
                        }</span>
                }

                <span class="cov8" title="1">errorMsg := fmt.Sprintf("line(s) %v do not exist in diff for file '%s'", invalidLines, comment.Path)
                if len(availableLines) &gt; 0 </span><span class="cov8" title="1">{
                        errorMsg += fmt.Sprintf("\n\n💡 Available lines for comments: %s", strings.Join(rangeStrings, ", "))
                        errorMsg += fmt.Sprintf("\n\nTip: Use 'gh comment lines %d %s' to see detailed line information", pr, comment.Path)
                }</span> else<span class="cov0" title="0"> {
                        errorMsg += fmt.Sprintf("\n\n💡 No commentable lines found in '%s' - file may not have changes in this PR", comment.Path)
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("%s", errorMsg)</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package cmd

import (
        "fmt"
        "os"
        "strconv"
        "strings"

        "github.com/MakeNowJust/heredoc"
        "github.com/cli/go-gh/v2"
        "github.com/spf13/cobra"
)

var (
        // Global flags
        prNumber     int
        repo         string
        validateDiff bool
        dryRun       bool
        verbose      bool
        configPath   string
        noColor      bool
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &amp;cobra.Command{
        Use:   "gh-comment",
        Short: "Strategic GitHub PR commenting and review management",
        Long: heredoc.Doc(`
                gh-comment provides professional-grade tools for GitHub pull request
                comment management, systematic code reviews, and review process automation.

                Designed for developers, code review leads, and teams who need sophisticated
                comment workflows beyond GitHub's web interface capabilities.

                Comment Types:
                • Issue comments: General PR discussion, appear in main conversation tab
                • Review comments: Line-specific feedback, appear in "Files Changed" tab

                Strategic GitHub PR Commenting - Beyond the Web Interface:

                gh-comment is designed for professional code review workflows that require:
                • Systematic line-by-line code analysis with context
                • Bulk comment operations for comprehensive reviews
                • Advanced filtering for comment analysis and metrics
                • Automation integration for CI/CD review processes
                • Data export for review process optimization

                Perfect for: Senior developers, code review leads, QA teams, and DevOps engineers
                who need sophisticated comment management beyond GitHub's web interface.
        `),
        Example: heredoc.Doc(`
                Commands:
                  add                     Add general PR discussion comments
                  batch                   Process multiple comments from YAML configuration
                  close-pending-review    Submit GUI-created pending reviews
                  edit                    Modify existing comments
                  lines                   Show commentable lines in PR files
                  list                    List and filter comments with advanced options
                  prompts                 Get AI-powered code review prompts and best practices
                  react                   Add or remove emoji reactions to comments
                  resolve                 Resolve conversation threads
                  review                  Create line-specific code reviews
                  review-reply            Reply to review comments with text messages
                  help                    Help about any command

                Global Flags:
                  -p, --pr int        PR number (auto-detect from branch if omitted)
                  -R, --repo string   Repository (owner/repo format)
                      --dry-run       Show what would be commented without executing
                  -v, --verbose       Show detailed API interactions
                      --validate      Validate line exists in diff before commenting (default true)

                Filtering Flags (list command):
                      --author string     Filter by author (supports wildcards: 'user*')
                      --since string      Show comments after date ('2024-01-01', '1 week ago')
                      --until string      Show comments before date
                      --status string     Filter by status: open, resolved, all
                      --type string       Filter by type: issue, review, all
                  -q, --quiet            Minimal output for scripts

                Review Flags:
                      --event string      Review event: APPROVE, REQUEST_CHANGES, COMMENT
                      --comment strings   Add comments: file:line:message

                Examples:
                # Basic Operations
                $ gh comment list 123                           List all comments on PR #123
                $ gh comment add 123 "Looks good overall!"     Add general discussion comment

                # Issue Comments (General PR Discussion)
                $ gh comment add 123 "LGTM! Just waiting for CI to pass"
                $ gh comment add 123 "Thanks for addressing the security concerns"
                $ gh comment review-reply 12345 "Good point, I'll make those changes"

                # Review Comments (Line-Specific Code Feedback)
                $ gh comment review 123 "Code review complete" \
                  --comment src/api.js:42:"Add rate limiting middleware" \
                  --comment src/main.go:3:4:"Refactor for OAuth2 compliance" \
                  --event REQUEST_CHANGES

                # Advanced Filtering (Power User Features)
                $ gh comment list 123 --author "senior-dev*" --status open --since "1 week ago"
                $ gh comment list 123 --type review --author "*@company.com" --since "2024-01-01"
                $ gh comment list 123 --status resolved --until "2024-01-01" --quiet

                # Review Workflows (Professional Code Review)
                $ gh comment review 123 "Migration review complete" \
                  --comment src/api.js:42:"Add rate limiting middleware" \
                  --comment src/auth.js:15:20:"Update to OAuth2 flow" \
                  --comment tests/api_test.go:100:"Add edge case tests" \
                  --event REQUEST_CHANGES

                $ gh comment review 123 "Security audit findings" \
                  --comment src/api.js:8:"Use crypto.randomBytes(32) for tokens" \
                  --comment api.js:134:140:"Extract business logic to service layer"

                # Batch Operations (Systematic Reviews)
                $ gh comment batch 123 review-config.yaml
                $ gh comment batch 456 security-checklist.yaml --dry-run
                $ gh comment batch 789 bulk-comments.yaml --verbose

                # Conversation Management
                $ gh comment review-reply 2246362251 "Fixed in commit abc123" --resolve
                $ gh comment react 3141344022 +1
                $ gh comment react 2246362251 rocket
                $ gh comment react 3141344022 heart --remove
                $ gh comment resolve 2246362251

                # Data Export &amp; Analysis (Automation)
                $ gh comment list 123 --quiet | grep "👤" | cut -d' ' -f2 | sort | uniq -c
                $ gh comment list 123 --since "2024-01-01" --quiet | tee q1-review-data.txt
                $ gh comment list 123 --author "qa-team*" --quiet | analyze-feedback.py

                # Automation &amp; CI Integration with Suggestion Syntax
                $ gh comment add 123 src/security.js 67 "[SUGGEST: use crypto.randomBytes(32)]"
                $ gh comment add 123 src/api.js 42 "[SUGGEST:+2: const timeout = 5000;]"
                $ gh comment add 123 src/utils.js 15 "[SUGGEST:-1: import { validateInput } from './validators';]"
                $ for file in $(git diff --name-only); do gh comment add 123 "$file" 1 "Auto-generated security scan results"; done
                $ gh comment list --since "1 week ago" --type review --status open | review-blocker-analysis.sh

                # Advanced Comment Management
                $ gh comment edit 2246362251 "Updated: This rate limiting logic handles concurrent requests properly"
                $ gh comment list 123 --author "bot*" --quiet | grep "ID:" | cut -d':' -f2 | xargs -I {} gh comment resolve {}
                $ gh comment add 123 performance.js 89:95 "Consider caching this expensive calculation"

                # Suggestion Syntax (Auto-expand to GitHub suggestion blocks):
                Basic syntax:     [SUGGEST: improved_code]
                Offset syntax:    [SUGGEST:+N: code_for_N_lines_below]
                                  [SUGGEST:-N: code_for_N_lines_above]
                Multi-line:       &lt;&lt;&lt;SUGGEST
                                  multi_line_code
                                  SUGGEST&gt;&gt;&gt;

                Examples:
                $ gh comment add 123 src/api.js 42 "[SUGGEST: const timeout = 5000;]"
                $ gh comment add 123 src/api.js 40 "[SUGGEST:+2: // Add error handling]"
                $ gh comment add 123 src/api.js 45 "[SUGGEST:-1: import { logger } from './utils';]"
        `),
        Version: "1.0.0",
}

// Execute adds all child commands to the root command and sets flags appropriately.
func Execute() error <span class="cov8" title="1">{
        return rootCmd.Execute()
}</span>

func init() <span class="cov8" title="1">{
        // Global flags
        rootCmd.PersistentFlags().IntVarP(&amp;prNumber, "pr", "p", 0, "PR number (default: auto-detect from branch)")
        rootCmd.PersistentFlags().StringVarP(&amp;repo, "repo", "R", "", "Repository in owner/repo format (default: auto-detect from current directory)")
        rootCmd.PersistentFlags().StringVar(&amp;configPath, "config", "", "Configuration file path (default: search standard locations)")

        rootCmd.PersistentFlags().BoolVar(&amp;validateDiff, "validate", true, "Validate line exists in diff before commenting (default: true)")
        rootCmd.PersistentFlags().BoolVar(&amp;dryRun, "dry-run", false, "Show what would be commented without executing (default: false)")
        rootCmd.PersistentFlags().BoolVarP(&amp;verbose, "verbose", "v", false, "Show detailed API interactions (default: false)")
        rootCmd.PersistentFlags().BoolVar(&amp;noColor, "no-color", false, "Disable colored output (default: false)")

        // Load configuration and initialize colors before command execution
        cobra.OnInitialize(initializeConfig, initializeColors)
}</span>

// initializeColors initializes the color system
func initializeColors() <span class="cov8" title="1">{
        InitColors()
}</span>

// initializeConfig loads the configuration and applies defaults
func initializeConfig() <span class="cov8" title="1">{
        err := LoadGlobalConfig(configPath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Warning: Failed to load configuration: %v\n", err)
                return
        }</span>

        <span class="cov8" title="1">config := GetConfig()

        // Apply config defaults if flags weren't explicitly set
        applyConfigDefaults(config)</span>
}

// applyConfigDefaults applies configuration defaults to global variables
func applyConfigDefaults(config *Config) <span class="cov8" title="1">{
        // Only apply defaults if values weren't set via flags
        if repo == "" &amp;&amp; config.Defaults.Repository != "" </span><span class="cov0" title="0">{
                repo = config.Defaults.Repository
        }</span>
        <span class="cov8" title="1">if prNumber == 0 &amp;&amp; config.Defaults.PR != 0 </span><span class="cov0" title="0">{
                prNumber = config.Defaults.PR
        }</span>

        // Apply behavior defaults (these could be overridden by flags)
        <span class="cov8" title="1">if !rootCmd.PersistentFlags().Changed("dry-run") </span><span class="cov8" title="1">{
                dryRun = config.Behavior.DryRun
        }</span>
        <span class="cov8" title="1">if !rootCmd.PersistentFlags().Changed("verbose") </span><span class="cov8" title="1">{
                verbose = config.Behavior.Verbose
        }</span>
        <span class="cov8" title="1">if !rootCmd.PersistentFlags().Changed("validate") </span><span class="cov8" title="1">{
                validateDiff = config.Behavior.Validate
        }</span>
}

// Helper function to get current repository if not specified
func getCurrentRepo() (string, error) <span class="cov8" title="1">{
        if repo != "" </span><span class="cov8" title="1">{
                return repo, nil
        }</span>

        // Use gh CLI to get current repository
        <span class="cov8" title="1">stdout, _, err := gh.Exec("repo", "view", "--json", "nameWithOwner", "-q", ".nameWithOwner")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get current repository: %w", err)
        }</span>

        <span class="cov8" title="1">return strings.TrimSpace(stdout.String()), nil</span>
}

// Helper function to get current PR number if not specified
func getCurrentPR() (int, error) <span class="cov8" title="1">{
        if prNumber != 0 </span><span class="cov8" title="1">{
                return prNumber, nil
        }</span>

        // Use gh CLI to get PR for current branch
        <span class="cov8" title="1">stdout, _, err := gh.Exec("pr", "view", "--json", "number", "-q", ".number")
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("failed to get current PR: %w (try specifying --pr)", err)
        }</span>

        <span class="cov0" title="0">prStr := strings.TrimSpace(stdout.String())
        pr, err := strconv.Atoi(prStr)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid PR number: %s", prStr)
        }</span>

        <span class="cov0" title="0">return pr, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package cmd

import (
        "regexp"
        "strconv"
        "strings"
)

// expandSuggestions processes inline suggestion syntax and converts to GitHub markdown
func expandSuggestions(message string) string <span class="cov8" title="1">{
        // First handle multi-line suggestions: &lt;&lt;&lt;SUGGEST\ncode\nSUGGEST&gt;&gt;&gt;
        message = expandMultilineSuggestions(message)

        // Then handle inline suggestions: [SUGGEST: code]
        message = expandInlineSuggestions(message)

        return message
}</span>

// expandInlineSuggestions handles [SUGGEST: code] and [SUGGEST:&lt;offset&gt;: code] syntax
func expandInlineSuggestions(message string) string <span class="cov8" title="1">{
        // Use a more sophisticated approach to handle nested brackets
        result := message
        for </span><span class="cov8" title="1">{
                start := strings.Index(result, "[SUGGEST:")
                if start == -1 </span><span class="cov8" title="1">{
                        break</span> // No more suggestions found
                }

                // Find the matching closing bracket by counting bracket depth
                <span class="cov8" title="1">bracketCount := 0
                suggestStart := start + len("[SUGGEST:")
                end := -1

                for i := suggestStart; i &lt; len(result); i++ </span><span class="cov8" title="1">{
                        char := result[i]
                        if char == '[' </span><span class="cov8" title="1">{
                                bracketCount++
                        }</span> else<span class="cov8" title="1"> if char == ']' </span><span class="cov8" title="1">{
                                if bracketCount == 0 </span><span class="cov8" title="1">{
                                        end = i
                                        break</span>
                                }
                                <span class="cov8" title="1">bracketCount--</span>
                        }
                }

                <span class="cov8" title="1">if end == -1 </span><span class="cov8" title="1">{
                        break</span> // No matching closing bracket found
                }

                // Extract the content and parse for offset syntax
                <span class="cov8" title="1">content := strings.TrimSpace(result[suggestStart:end])
                offset, code := parseOffsetSuggestion(content)

                // Replace the [SUGGEST: code] or [SUGGEST:&lt;offset&gt;: code] with GitHub suggestion syntax
                var replacement string
                if offset != 0 </span><span class="cov8" title="1">{
                        // Format with offset for GitHub
                        replacement = "\n\n```suggestion:" + formatOffset(offset) + "\n" + code + "\n```\n\n"
                }</span> else<span class="cov8" title="1"> {
                        // Standard suggestion format
                        replacement = "\n\n```suggestion\n" + code + "\n```\n\n"
                }</span>

                // Replace this occurrence and continue searching
                <span class="cov8" title="1">result = result[:start] + replacement + result[end+1:]</span>
        }

        <span class="cov8" title="1">return result</span>
}

// parseOffsetSuggestion parses content for offset syntax: "&lt;offset&gt;: code" or just "code"
func parseOffsetSuggestion(content string) (int, string) <span class="cov8" title="1">{
        // Check for offset pattern: +N: or -N: or N:
        offsetPattern := regexp.MustCompile(`^([+-]?\d+):\s*(.*)$`)
        matches := offsetPattern.FindStringSubmatch(content)

        if len(matches) == 3 </span><span class="cov8" title="1">{
                // Parse the offset
                offsetStr := matches[1]
                code := strings.TrimSpace(matches[2])

                offset, err := strconv.Atoi(offsetStr)
                if err != nil || offset &lt; -999 || offset &gt; 999 </span><span class="cov8" title="1">{
                        // Invalid offset, treat as regular suggestion
                        return 0, content
                }</span>

                <span class="cov8" title="1">return offset, code</span>
        }

        // No offset found, return as regular suggestion
        <span class="cov8" title="1">return 0, content</span>
}

// formatOffset formats the offset for GitHub suggestion syntax
func formatOffset(offset int) string <span class="cov8" title="1">{
        if offset &gt; 0 </span><span class="cov8" title="1">{
                return "+" + strconv.Itoa(offset)
        }</span>
        <span class="cov8" title="1">return strconv.Itoa(offset)</span>
}

// expandMultilineSuggestions handles &lt;&lt;&lt;SUGGEST\ncode\nSUGGEST&gt;&gt;&gt; syntax
func expandMultilineSuggestions(message string) string <span class="cov8" title="1">{
        // Regex to match &lt;&lt;&lt;SUGGEST...code...SUGGEST&gt;&gt;&gt; blocks (with flexible whitespace)
        re := regexp.MustCompile(`(?s)&lt;&lt;&lt;SUGGEST\s*\n(.*?)\nSUGGEST&gt;&gt;&gt;`)

        return re.ReplaceAllStringFunc(message, func(match string) string </span><span class="cov8" title="1">{
                // Extract the code part
                submatches := re.FindStringSubmatch(match)
                if len(submatches) &lt; 2 </span><span class="cov0" title="0">{
                        return match // Return original if parsing fails
                }</span>

                <span class="cov8" title="1">code := strings.TrimSpace(submatches[1])
                return "\n\n```suggestion\n" + code + "\n```\n\n"</span>
        })
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
